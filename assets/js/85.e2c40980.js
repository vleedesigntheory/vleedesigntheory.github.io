(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{287:function(e,n,t){"use strict";t.r(n);var a=t(0),r=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"动态渲染拓扑图方案探究"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#动态渲染拓扑图方案探究"}},[e._v("#")]),e._v(" 动态渲染拓扑图方案探究")]),e._v(" "),t("h2",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/topology20210122/topology01.jpg",alt:"图片"}})]),e._v(" "),t("p",[e._v("拓扑图是数据可视化领域一种比较常见的展示类型，目前业界常见的可视化展现的方案有ECharts、HighCharts、D3、AntV等。当前的项目使用的是基于ECharts的静态关系图渲染，为了后续可能扩展成动态的拓扑图渲染，本文探索了ECharts的原理以及G6的原理，也算是对自研一个可视化库的基本实现方法做了一个梳理。")]),e._v(" "),t("h2",{attrs:{id:"方案选择"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方案选择"}},[e._v("#")]),e._v(" 方案选择")]),e._v(" "),t("ul",[t("li",[e._v("ECharts\n"),t("ul",[t("li",[e._v("关系图")])])]),e._v(" "),t("li",[e._v("AntV\n"),t("ul",[t("li",[e._v("G6\n"),t("ul",[t("li",[e._v("Graphin")])])])])])]),e._v(" "),t("h2",{attrs:{id:"源码解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#源码解析"}},[e._v("#")]),e._v(" 源码解析")]),e._v(" "),t("h3",{attrs:{id:"echarts源码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#echarts源码"}},[e._v("#")]),e._v(" ECharts源码")]),e._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/topology20210122/topology02.jpg",alt:"图片"}})]),e._v(" "),t("p",[e._v("整个ECharts核心对外输出是一个大的ECharts类，所有的类型都是基于其进行new出来的实例，而其核心是基于对ZRender这样一个Canvas的封装")]),e._v(" "),t("h4",{attrs:{id:"echarts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#echarts"}},[e._v("#")]),e._v(" ECharts")]),e._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/topology20210122/topology03.jpg",alt:"图片"}})]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class ECharts extends Eventful {\n    // 公共属性\n    group: string;\n    // 私有属性\n    private _zr: zrender.ZRenderType;\n    private _dom: HTMLElement;\n    private _model: GlobalModel;\n    private _throttledZrFlush: zrender.ZRenderType extends {flush: infer R} ? R : never;\n    private _theme: ThemeOption;\n    private _locale: LocaleOption;\n    private _chartsViews: ChartView[] = [];\n    private _chartsMap: {[viewId: string]: ChartView} = {};\n    private _componentsViews: ComponentView[] = [];\n    private _componentsMap: {[viewId: string]: ComponentView} = {};\n    private _coordSysMgr: CoordinateSystemManager;\n    private _api: ExtensionAPI;\n    private _scheduler: Scheduler;\n    private _messageCenter: MessageCenter;\n    private _pendingActions: Payload[] = [];\n    private _disposed: boolean;\n    private _loadingFX: LoadingEffect;\n    private _labelManager: LabelManager;\n    private [OPTION_UPDATED_KEY]: boolean | {silent: boolean};\n    private [IN_MAIN_PROCESS_KEY]: boolean;\n    private [CONNECT_STATUS_KEY]: ConnectStatus;\n    private [STATUS_NEEDS_UPDATE_KEY]: boolean;\n    // 保护属性\n    protected _$eventProcessor: never;\n\n    constructor(\n        dom: HTMLElement,\n        theme?: string | ThemeOption,\n        opts?: {\n            locale?: string | LocaleOption,\n            renderer?: RendererType,\n            devicePixelRatio?: number,\n            useDirtyRect?: boolean,\n            width?: number,\n            height?: number\n        }\n    ) {\n        super(new ECEventProcessor());\n\n        opts = opts || {};\n\n        \n        if (typeof theme === 'string') {\n            theme = themeStorage[theme] as object;\n        }\n\n        this._dom = dom;\n\n        let defaultRenderer = 'canvas';\n\n        const zr = this._zr = zrender.init(dom, {\n            renderer: opts.renderer || defaultRenderer,\n            devicePixelRatio: opts.devicePixelRatio,\n            width: opts.width,\n            height: opts.height,\n            useDirtyRect: opts.useDirtyRect == null ? defaultUseDirtyRect : opts.useDirtyRect\n        });\n\n        this._locale = createLocaleObject(opts.locale || SYSTEM_LANG);\n\n        this._coordSysMgr = new CoordinateSystemManager();\n\n        const api = this._api = createExtensionAPI(this);\n\n        this._scheduler = new Scheduler(this, api, dataProcessorFuncs, visualFuncs);\n\n        this._initEvents();\n\n        zr.animation.on('frame', this._onframe, this);\n\n        bindRenderedEvent(zr, this);\n\n        bindMouseEvent(zr, this);\n\n    }\n\n    private _onframe(): void {}\n\n    getDom(): HTMLElement {\n        return this._dom;\n    }\n\n    getId(): string {\n        return this.id;\n    }\n\n    getZr(): zrender.ZRenderType {\n        return this._zr;\n    }\n\n    setOption<Opt extends ECBasicOption>(option: Opt, notMerge?: boolean | SetOptionOpts, lazyUpdate?: boolean): void {\n        if (lazyUpdate) {\n            this[OPTION_UPDATED_KEY] = {silent: silent};\n            this[IN_MAIN_PROCESS_KEY] = false;\n            this.getZr().wakeUp();\n        }\n        else {\n            prepare(this);\n\n            updateMethods.update.call(this);\n            this._zr.flush();\n\n            this[OPTION_UPDATED_KEY] = false;\n            this[IN_MAIN_PROCESS_KEY] = false;\n\n            flushPendingActions.call(this, silent);\n            triggerUpdatedEvent.call(this, silent);\n        }\n    }\n\n    private getModel(): GlobalModel {\n        return this._model;\n    }\n\n    getRenderedCanvas(opts?: {\n        backgroundColor?: ZRColor\n        pixelRatio?: number\n    }): HTMLCanvasElement {\n        if (!env.canvasSupported) {\n            return;\n        }\n        opts = zrUtil.extend({}, opts || {});\n        opts.pixelRatio = opts.pixelRatio || this.getDevicePixelRatio();\n        opts.backgroundColor = opts.backgroundColor\n            || this._model.get('backgroundColor');\n        const zr = this._zr;\n        return (zr.painter as CanvasPainter).getRenderedCanvas(opts);\n    }\n\n\n    private _initEvents(): void {\n        each(MOUSE_EVENT_NAMES, (eveName) => {\n            const handler = (e: ElementEvent) => {\n                const ecModel = this.getModel();\n                const el = e.target;\n                let params: ECEvent;\n                const isGlobalOut = eveName === 'globalout';\n                if (isGlobalOut) {\n                    params = {} as ECEvent;\n                }\n                else {\n                    el && findEventDispatcher(el, (parent) => {\n                        const ecData = getECData(parent);\n                        if (ecData && ecData.dataIndex != null) {\n                            const dataModel = ecData.dataModel || ecModel.getSeriesByIndex(ecData.seriesIndex);\n                            params = (\n                                dataModel && dataModel.getDataParams(ecData.dataIndex, ecData.dataType) || {}\n                            ) as ECEvent;\n                            return true;\n                        }\n                        // If element has custom eventData of components\n                        else if (ecData.eventData) {\n                            params = zrUtil.extend({}, ecData.eventData) as ECEvent;\n                            return true;\n                        }\n                    }, true);\n                }\n\n\n                if (params) {\n                    let componentType = params.componentType;\n                    let componentIndex = params.componentIndex;\n                    if (componentType === 'markLine'\n                        || componentType === 'markPoint'\n                        || componentType === 'markArea'\n                    ) {\n                        componentType = 'series';\n                        componentIndex = params.seriesIndex;\n                    }\n                    const model = componentType && componentIndex != null\n                        && ecModel.getComponent(componentType, componentIndex);\n                    const view = model && this[\n                        model.mainType === 'series' ? '_chartsMap' : '_componentsMap'\n                    ][model.__viewId];\n\n                    params.event = e;\n                    params.type = eveName;\n\n                    (this._$eventProcessor as ECEventProcessor).eventInfo = {\n                        targetEl: el,\n                        packedEvent: params,\n                        model: model,\n                        view: view\n                    };\n\n                    this.trigger(eveName, params);\n                }\n            };\n            (handler as any).zrEventfulCallAtLast = true;\n            this._zr.on(eveName, handler, this);\n        });\n\n        each(eventActionMap, (actionType, eventType) => {\n            this._messageCenter.on(eventType, function (event) {\n                this.trigger(eventType, event);\n            }, this);\n        });\n\n        // Extra events\n        // TODO register?\n        each(\n            ['selectchanged'],\n            (eventType) => {\n                this._messageCenter.on(eventType, function (event) {\n                    this.trigger(eventType, event);\n                }, this);\n            }\n        );\n\n        handleLegacySelectEvents(this._messageCenter, this, this._api);\n    }\n\n    dispatchAction(\n        payload: Payload,\n        opt?: boolean | {\n            silent?: boolean,\n            flush?: boolean | undefined\n        }\n    ): void {\n        const silent = opt.silent;\n        doDispatchAction.call(this, payload, silent);\n\n        const flush = opt.flush;\n        if (flush) {\n            this._zr.flush();\n        }\n        else if (flush !== false && env.browser.weChat) {\n            this._throttledZrFlush();\n        }\n\n        flushPendingActions.call(this, silent);\n\n        triggerUpdatedEvent.call(this, silent);\n    }\n}\n")])])]),t("h4",{attrs:{id:"zrender"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#zrender"}},[e._v("#")]),e._v(" ZRender")]),e._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/topology20210122/topology04.png",alt:"图片"}})]),e._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/topology20210122/topology05.jpg",alt:"图片"}})]),e._v(" "),t("p",[e._v("ZRender是典型的MVC架构，其中M为Storage，主要对数据进行CRUD管理；V为Painter，对Canvas或SVG的生命周期及视图进行管理；C为Handler，负责事件的交互处理，实现dom事件的模拟封装")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class ZRender {\n    // 公共属性\n    dom: HTMLElement\n    id: number\n    storage: Storage\n    painter: PainterBase\n    handler: Handler\n    animation: Animation\n    // 私有属性\n    private _sleepAfterStill = 10;\n    private _stillFrameAccum = 0;\n    private _needsRefresh = true\n    private _needsRefreshHover = true\n    private _darkMode = false;\n    private _backgroundColor: string | GradientObject | PatternObject;\n\n    constructor(id: number, dom: HTMLElement, opts?: ZRenderInitOpt) {\n        opts = opts || {};\n\n        /**\n         * @type {HTMLDomElement}\n         */\n        this.dom = dom;\n\n        this.id = id;\n\n        const storage = new Storage();\n\n        let rendererType = opts.renderer || 'canvas';\n\n        // TODO WebGL\n        if (useVML) {\n            throw new Error('IE8 support has been dropped since 5.0');\n        }\n\n        if (!painterCtors[rendererType]) {\n            // Use the first registered renderer.\n            rendererType = zrUtil.keys(painterCtors)[0];\n        }\n        if (!painterCtors[rendererType]) {\n            throw new Error(`Renderer '${rendererType}' is not imported. Please import it first.`);\n        }\n\n        opts.useDirtyRect = opts.useDirtyRect == null\n            ? false\n            : opts.useDirtyRect;\n\n        const painter = new painterCtors[rendererType](dom, storage, opts, id);\n\n        this.storage = storage;\n        this.painter = painter;\n\n        const handerProxy = (!env.node && !env.worker)\n            ? new HandlerProxy(painter.getViewportRoot(), painter.root)\n            : null;\n        this.handler = new Handler(storage, painter, handerProxy, painter.root);\n\n        this.animation = new Animation({\n            stage: {\n                update: () => this._flush(true)\n            }\n        });\n        this.animation.start();\n    }\n\n    /**\n     * 添加元素\n     */\n    add(el: Element) {\n        \n    }\n\n    /**\n     * 删除元素\n     */\n    remove(el: Element) {\n        \n    }\n    \n\n    refresh() {\n        this._needsRefresh = true;\n        // Active the animation again.\n        this.animation.start();\n    }\n\n    private _flush(fromInside?: boolean) {\n        let triggerRendered;\n\n        const start = new Date().getTime();\n        if (this._needsRefresh) {\n            triggerRendered = true;\n            this.refreshImmediately(fromInside);\n        }\n\n        if (this._needsRefreshHover) {\n            triggerRendered = true;\n            this.refreshHoverImmediately();\n        }\n        const end = new Date().getTime();\n\n        if (triggerRendered) {\n            this._stillFrameAccum = 0;\n            this.trigger('rendered', {\n                elapsedTime: end - start\n            });\n        }\n        else if (this._sleepAfterStill > 0) {\n            this._stillFrameAccum++;\n            // Stop the animiation after still for 10 frames.\n            if (this._stillFrameAccum > this._sleepAfterStill) {\n                this.animation.stop();\n            }\n        }\n    }\n\n    on<Ctx>(eventName: string, eventHandler: EventCallback<Ctx, unknown> | EventCallback<Ctx, unknown, ElementEvent>, context?: Ctx): this {\n        this.handler.on(eventName, eventHandler, context);\n        return this;\n    }\n\n    off(eventName?: string, eventHandler?: EventCallback<unknown, unknown> | EventCallback<unknown, unknown, ElementEvent>) {\n        this.handler.off(eventName, eventHandler);\n    }\n\n    trigger(eventName: string, event?: unknown) {\n        this.handler.trigger(eventName, event);\n    }\n\n    clear() {\n        \n    }\n\n    \n    dispose() {\n        \n    }\n}\n")])])]),t("h3",{attrs:{id:"g6源码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#g6源码"}},[e._v("#")]),e._v(" G6源码")]),e._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/topology20210122/topology06.png",alt:"图片"}})]),e._v(" "),t("p",[e._v("G6是Ant\bV专门针对图开源的一个库，其底层通过对边和点的定义，以及对位置的确定，来进行图的绘制，其主要包括五大内容：1、图的元素：点、边、分组等；2、图的算法：DFS、BFS、图检测、最短路径、中心度等；3、图布局：force、circle、grid等；4、图渲染：Canvas及SVG等；5、图交互：框选、点选、拖拽等；而Graphin是基于G6的使用React封装的落地方案")]),e._v(" "),t("h4",{attrs:{id:"g6"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#g6"}},[e._v("#")]),e._v(" G6")]),e._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/topology20210122/topology07.jpg",alt:"图片"}})]),e._v(" "),t("p",[e._v("和ECharts的核心思路是一致的，都是基于MVC的模型，但是G6针对图的特点对元素进行了细化，用御术的话说就是“G6是面粉，ECharts是面条”，果然同一个作者开发的思路都是极其的相似")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export default abstract class AbstractGraph extends EventEmitter implements IAbstractGraph {\n  protected animating: boolean;\n  protected cfg: GraphOptions & { [key: string]: any };\n  protected undoStack: Stack;\n  protected redoStack: Stack;\n\n  public destroyed: boolean;\n\n  constructor(cfg: GraphOptions) {\n    super();\n    this.cfg = deepMix(this.getDefaultCfg(), cfg);\n    this.init();\n    this.animating = false;\n    this.destroyed = false;\n\n    if (this.cfg.enabledStack) {\n      this.undoStack = new Stack(this.cfg.maxStep);\n      this.redoStack = new Stack(this.cfg.maxStep);\n    }\n  }\n\n  protected init() {\n    this.initCanvas();\n    const viewController = new ViewController(this);\n    const modeController = new ModeController(this);\n    const itemController = new ItemController(this);\n    const stateController = new StateController(this);\n\n    this.set({\n      viewController,\n      modeController,\n      itemController,\n      stateController,\n    });\n\n    this.initLayoutController();\n\n    this.initEventController();\n\n    this.initGroups();\n\n    this.initPlugins();\n  }\n\n  protected abstract initLayoutController(): void;\n\n  protected abstract initEventController(): void;\n\n  protected abstract initCanvas(): void;\n\n  protected abstract initPlugins(): void;\n\n  protected initGroups(): void {\n    const canvas: ICanvas = this.get('canvas');\n    const el: HTMLElement = this.get('canvas').get('el');\n    const { id } = el;\n\n    const group: IGroup = canvas.addGroup({\n      id: `${id}-root`,\n      className: Global.rootContainerClassName,\n    });\n\n    if (this.get('groupByTypes')) {\n      const edgeGroup: IGroup = group.addGroup({\n        id: `${id}-edge`,\n        className: Global.edgeContainerClassName,\n      });\n\n      const nodeGroup: IGroup = group.addGroup({\n        id: `${id}-node`,\n        className: Global.nodeContainerClassName,\n      });\n\n      const comboGroup: IGroup = group.addGroup({\n        id: `${id}-combo`,\n        className: Global.comboContainerClassName,\n      });\n\n      // 用于存储自定义的群组\n      comboGroup.toBack();\n\n      this.set({ nodeGroup, edgeGroup, comboGroup });\n    }\n    const delegateGroup: IGroup = group.addGroup({\n      id: `${id}-delegate`,\n      className: Global.delegateContainerClassName,\n    });\n    this.set({ delegateGroup });\n    this.set('group', group);\n  }\n\n  public node(nodeFn: (config: NodeConfig) => Partial<NodeConfig>): void {\n    if (typeof nodeFn === 'function') {\n      this.set('nodeMapper', nodeFn);\n    }\n  }\n\n  public edge(edgeFn: (config: EdgeConfig) => Partial<EdgeConfig>): void {\n    if (typeof edgeFn === 'function') {\n      this.set('edgeMapper', edgeFn);\n    }\n  }\n\n  public combo(comboFn: (config: ComboConfig) => Partial<ComboConfig>): void {\n    if (typeof comboFn === 'function') {\n      this.set('comboMapper', comboFn);\n    }\n  }\n\n  public addBehaviors(\n    behaviors: string | ModeOption | ModeType[],\n    modes: string | string[],\n  ): AbstractGraph {\n    const modeController: ModeController = this.get('modeController');\n    modeController.manipulateBehaviors(behaviors, modes, true);\n    return this;\n  }\n\n  public removeBehaviors(\n    behaviors: string | ModeOption | ModeType[],\n    modes: string | string[],\n  ): AbstractGraph {\n    const modeController: ModeController = this.get('modeController');\n    modeController.manipulateBehaviors(behaviors, modes, false);\n    return this;\n  }\n\n  public paint(): void {\n    this.emit('beforepaint');\n    this.get('canvas').draw();\n    this.emit('afterpaint');\n  }\n\n  public render(): void {\n    const self = this;\n    this.set('comboSorted', false);\n    const data: GraphData = this.get('data');\n\n    if (this.get('enabledStack')) {\n      // render 之前清空 redo 和 undo 栈\n      this.clearStack();\n    }\n\n    if (!data) {\n      throw new Error('data must be defined first');\n    }\n\n    const { nodes = [], edges = [], combos = [] } = data;\n\n    this.clear();\n\n    this.emit('beforerender');\n\n    each(nodes, (node: NodeConfig) => {\n      self.add('node', node, false, false);\n    });\n\n    // process the data to tree structure\n    if (combos && combos.length !== 0) {\n      const comboTrees = plainCombosToTrees(combos, nodes);\n      this.set('comboTrees', comboTrees);\n      // add combos\n      self.addCombos(combos);\n    }\n\n    each(edges, (edge: EdgeConfig) => {\n      self.add('edge', edge, false, false);\n    });\n\n    const animate = self.get('animate');\n    if (self.get('fitView') || self.get('fitCenter')) {\n      self.set('animate', false);\n    }\n\n    // layout\n    const layoutController = self.get('layoutController');\n    if (layoutController) {\n      layoutController.layout(success);\n      if (this.destroyed) return;\n    } else {\n      if (self.get('fitView')) {\n        self.fitView();\n      }\n      if (self.get('fitCenter')) {\n        self.fitCenter();\n      }\n      self.emit('afterrender');\n      self.set('animate', animate);\n    }\n    // 将在 onLayoutEnd 中被调用\n    function success() {\n      // fitView 与 fitCenter 共存时，fitView 优先，fitCenter 不再执行\n      if (self.get('fitView')) {\n        self.fitView();\n      } else if (self.get('fitCenter')) {\n        self.fitCenter();\n      }\n      self.autoPaint();\n      self.emit('afterrender');\n      if (self.get('fitView') || self.get('fitCenter')) {\n        self.set('animate', animate);\n      }\n    }\n\n    if (!this.get('groupByTypes')) {\n      if (combos && combos.length !== 0) {\n        this.sortCombos();\n      } else {\n        // 为提升性能，选择数量少的进行操作\n        if (data.nodes && data.edges && data.nodes.length < data.edges.length) {\n          const nodesArr = this.getNodes();\n\n          // 遍历节点实例，将所有节点提前。\n          nodesArr.forEach((node) => {\n            node.toFront();\n          });\n        } else {\n          const edgesArr = this.getEdges();\n\n          // 遍历节点实例，将所有节点提前。\n          edgesArr.forEach((edge) => {\n            edge.toBack();\n          });\n        }\n      }\n    }\n\n    if (this.get('enabledStack')) {\n      this.pushStack('render');\n    }\n  }\n}\n")])])]),t("h4",{attrs:{id:"graphin"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#graphin"}},[e._v("#")]),e._v(" Graphin")]),e._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/topology20210122/topology08.jpg",alt:"图片"}})]),e._v(" "),t("p",[e._v("Graphin是基于G6封装的React组件，可以直接进行使用")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("import React, { ErrorInfo } from 'react';\nimport G6, { Graph as IGraph, GraphOptions, GraphData, TreeGraphData } from '@antv/g6';\n\nclass Graphin extends React.PureComponent<GraphinProps, GraphinState> {\n  static registerNode: RegisterFunction = (nodeName, options, extendedNodeName) => {\n    G6.registerNode(nodeName, options, extendedNodeName);\n  };\n\n  static registerEdge: RegisterFunction = (edgeName, options, extendedEdgeName) => {\n    G6.registerEdge(edgeName, options, extendedEdgeName);\n  };\n\n  static registerCombo: RegisterFunction = (comboName, options, extendedComboName) => {\n    G6.registerCombo(comboName, options, extendedComboName);\n  };\n\n  static registerBehavior(behaviorName: string, behavior: any) {\n    G6.registerBehavior(behaviorName, behavior);\n  }\n\n  static registerFontFamily(iconLoader: IconLoader): { [icon: string]: any } {\n    /**  注册 font icon */\n    const iconFont = iconLoader();\n    const { glyphs, fontFamily } = iconFont;\n    const icons = glyphs.map((item) => {\n      return {\n        name: item.name,\n        unicode: String.fromCodePoint(item.unicode_decimal),\n      };\n    });\n\n    return new Proxy(icons, {\n      get: (target, propKey: string) => {\n        const matchIcon = target.find((icon) => {\n          return icon.name === propKey;\n        });\n        if (!matchIcon) {\n          console.error(`%c fontFamily:${fontFamily},does not found ${propKey} icon`);\n          return '';\n        }\n        return matchIcon?.unicode;\n      },\n    });\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static registerLayout(layoutName: string, layout: any) {\n    G6.registerLayout(layoutName, layout);\n  }\n\n  graphDOM: HTMLDivElement | null = null;\n  graph: IGraph;\n  layout: LayoutController;\n  width: number;\n  height: number;\n  isTree: boolean;\n  data: GraphinTreeData | GraphinData | undefined;\n  options: GraphOptions;\n  apis: ApisType;\n  theme: ThemeData;\n\n  constructor(props: GraphinProps) {\n    super(props);\n\n    const {\n      data,\n      layout,\n      width,\n      height,\n\n      ...otherOptions\n    } = props;\n\n    this.data = data;\n    this.isTree =\n      Boolean(props.data && props.data.children) || TREE_LAYOUTS.indexOf(String(layout && layout.type)) !== -1;\n    this.graph = {} as IGraph;\n    this.height = Number(height);\n    this.width = Number(width);\n\n    this.theme = {} as ThemeData;\n    this.apis = {} as ApisType;\n\n    this.state = {\n      isReady: false,\n      context: {\n        graph: this.graph,\n        apis: this.apis,\n        theme: this.theme,\n      },\n    };\n\n    this.options = { ...otherOptions } as GraphOptions;\n    this.layout = {} as LayoutController;\n  }\n\n  initData = (data: GraphinProps['data']) => {\n    if (data.children) {\n      this.isTree = true;\n    }\n    console.time('clone data');\n    this.data = cloneDeep(data);\n    console.timeEnd('clone data');\n  };\n\n  initGraphInstance = () => {\n    const {\n      theme,\n      data,\n      layout,\n      width,\n      height,\n      defaultCombo,\n      defaultEdge,\n      defaultNode,\n      nodeStateStyles,\n      edgeStateStyles,\n      comboStateStyles,\n      modes = { default: [] },\n      animate,\n      ...otherOptions\n    } = this.props;\n    const { clientWidth, clientHeight } = this.graphDOM as HTMLDivElement;\n    this.initData(data);\n\n    this.width = Number(width) || clientWidth || 500;\n    this.height = Number(height) || clientHeight || 500;\n\n    const themeResult = getDefaultStyleByTheme(theme);\n\n    const {\n      defaultNodeStyle,\n      defaultEdgeStyle,\n      defaultComboStyle,\n      defaultNodeStatusStyle,\n      defaultEdgeStatusStyle,\n      defaultComboStatusStyle,\n    } = themeResult;\n    this.theme = themeResult as ThemeData;\n    this.isTree = Boolean(data.children) || TREE_LAYOUTS.indexOf(String(layout && layout.type)) !== -1;\n    const isGraphinNodeType = defaultNode?.type === undefined || defaultNode?.type === defaultNodeStyle.type;\n    const isGraphinEdgeType = defaultEdge?.type === undefined || defaultEdge?.type === defaultEdgeStyle.type;\n\n    this.options = {\n      container: this.graphDOM,\n      renderer: 'canvas',\n      width: this.width,\n      height: this.height,\n      animate: animate !== false,\n      /** 默认样式 */\n      defaultNode: isGraphinNodeType ? deepMix({}, defaultNodeStyle, defaultNode) : defaultNode,\n      defaultEdge: isGraphinEdgeType ? deepMix({}, defaultEdgeStyle, defaultEdge) : defaultEdge,\n      defaultCombo: deepMix({}, defaultComboStyle, defaultCombo),\n      /** status 样式 */\n      nodeStateStyles: deepMix({}, defaultNodeStatusStyle, nodeStateStyles),\n      edgeStateStyles: deepMix({}, defaultEdgeStatusStyle, edgeStateStyles),\n      comboStateStyles: deepMix({}, defaultComboStatusStyle, comboStateStyles),\n\n      modes,\n      ...otherOptions,\n    } as GraphOptions;\n\n    if (this.isTree) {\n      this.options.layout = { ...layout };\n\n      this.graph = new G6.TreeGraph(this.options);\n    } else {\n      this.graph = new G6.Graph(this.options);\n    }\n\n    this.graph.data(this.data as GraphData | TreeGraphData);\n    /** 初始化布局 */\n    if (!this.isTree) {\n      this.layout = new LayoutController(this);\n      this.layout.start();\n    }\n    this.graph.get('canvas').set('localRefresh', false);\n    this.graph.render();\n    this.initStatus();\n    this.apis = ApiController(this.graph);\n  };\n\n  updateLayout = () => {\n    this.layout.changeLayout();\n  };\n\n  componentDidMount() {\n    console.log('did mount...');\n\n    this.initGraphInstance();\n    this.setState({\n      isReady: true,\n      context: {\n        graph: this.graph,\n        apis: this.apis,\n        theme: this.theme,\n      },\n    });\n  }\n\n  updateOptions = () => {\n    const { layout, data, ...options } = this.props;\n    return options;\n  };\n\n  initStatus = () => {\n    if (!this.isTree) {\n      const { data } = this.props;\n      const { nodes = [], edges = [] } = data as GraphinData;\n      nodes.forEach((node) => {\n        const { status } = node;\n        if (status) {\n          Object.keys(status).forEach((k) => {\n            this.graph.setItemState(node.id, k, Boolean(status[k]));\n          });\n        }\n      });\n      edges.forEach((edge) => {\n        const { status } = edge;\n        if (status) {\n          Object.keys(status).forEach((k) => {\n            this.graph.setItemState(edge.id, k, Boolean(status[k]));\n          });\n        }\n      });\n    }\n  };\n\n  componentDidUpdate(prevProps: GraphinProps) {\n    console.time('did-update');\n    const isDataChange = this.shouldUpdate(prevProps, 'data');\n    const isLayoutChange = this.shouldUpdate(prevProps, 'layout');\n    const isOptionsChange = this.shouldUpdate(prevProps, 'options');\n    const isThemeChange = this.shouldUpdate(prevProps, 'theme');\n    console.timeEnd('did-update');\n    const { data } = this.props;\n    const isGraphTypeChange = prevProps.data.children !== data.children;\n\n    /** 图类型变化 */\n    if (isGraphTypeChange) {\n      this.initGraphInstance();\n      console.log('%c isGraphTypeChange', 'color:grey');\n    }\n    /** 配置变化 */\n    if (isOptionsChange) {\n      this.updateOptions();\n      console.log('isOptionsChange');\n    }\n    /** 数据变化 */\n    if (isDataChange) {\n      this.initData(data);\n      this.layout.changeLayout();\n      this.graph.data(this.data as GraphData | TreeGraphData);\n      this.graph.changeData(this.data as GraphData | TreeGraphData);\n      this.initStatus();\n      this.apis = ApiController(this.graph);\n      console.log('%c isDataChange', 'color:grey');\n      this.setState((preState) => {\n        return {\n          ...preState,\n          context: {\n            graph: this.graph,\n            apis: this.apis,\n            theme: this.theme,\n          },\n        };\n      });\n      return;\n    }\n    /** 布局变化 */\n    if (isLayoutChange) {\n      /**\n       * TODO\n       * 1. preset 前置布局判断问题\n       * 2. enablework 问题\n       * 3. G6 LayoutController 里的逻辑\n       */\n      this.layout.changeLayout();\n      this.layout.refreshPosition();\n\n      /** 走G6的layoutController */\n      // this.graph.updateLayout();\n      console.log('%c isLayoutChange', 'color:grey');\n    }\n  }\n\n  /**\n   * 组件移除的时候\n   */\n  componentWillUnmount() {\n    this.clear();\n  }\n\n  /**\n   * 组件崩溃的时候\n   * @param error\n   * @param info\n   */\n  componentDidCatch(error: Error, info: ErrorInfo) {\n    console.error('Catch component error: ', error, info);\n  }\n\n  clear = () => {\n    if (this.layout && this.layout.destroyed) {\n      this.layout.destroy(); // tree graph\n    }\n    this.layout = {} as LayoutController;\n    this.graph!.clear();\n    this.data = { nodes: [], edges: [], combos: [] };\n    this.graph!.destroy();\n  };\n\n  shouldUpdate(prevProps: GraphinProps, key: string) {\n    /* eslint-disable react/destructuring-assignment */\n    const prevVal = prevProps[key];\n    const currentVal = this.props[key] as DiffValue;\n    const isEqual = deepEqual(prevVal, currentVal);\n    return !isEqual;\n  }\n\n  render() {\n    const { isReady } = this.state;\n    const { modes, style } = this.props;\n    return (\n      <GraphinContext.Provider value={this.state.context}>\n        <div id=\"graphin-container\">\n          <div\n            data-testid=\"custom-element\"\n            className=\"graphin-core\"\n            ref={(node) => {\n              this.graphDOM = node;\n            }}\n            style={{ background: this.theme?.background, ...style }}\n          />\n          <div className=\"graphin-components\">\n            {isReady && (\n              <>\n                {\n                  /** modes 不存在的时候，才启动默认的behaviros，否则会覆盖用户自己传入的 */\n                  !modes && (\n                    <React.Fragment>\n                      {/* 拖拽画布 */}\n                      <DragCanvas />\n                      {/* 缩放画布 */}\n                      <ZoomCanvas />\n                      {/* 拖拽节点 */}\n                      <DragNode />\n                      {/* 点击节点 */}\n                      <DragCombo />\n                      {/* 点击节点 */}\n                      <ClickSelect />\n                      {/* 圈选节点 */}\n                      <BrushSelect />\n                    </React.Fragment>\n                  )\n                }\n\n                {/** resize 画布 */}\n                <ResizeCanvas graphDOM={this.graphDOM as HTMLDivElement} />\n                <Hoverable bindType=\"node\" />\n                {/* <Hoverable bindType=\"edge\" /> */}\n                {this.props.children}\n              </>\n            )}\n          </div>\n        </div>\n      </GraphinContext.Provider>\n    );\n  }\n}\n")])])]),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),t("p",[e._v("数据可视化通常是基于Canvas进行渲染的，对于简单的图形渲染，我们常常一个实例一个实例去写，缺少系统性的统筹规划的概念，对于需要解决一类问题的可视化方案，可以借鉴ECharts及G6引擎的做法，基于MVC模型，将展示、行为及数据进行分离，对于特定方案细粒度的把控可以参考G6的方案。本质上，大数据可视化展示是一个兼具大数据、视觉传达、前端等多方交叉的领域，对于怎么进行数据粒度的优美展示，可以借鉴data-ink ratio以及利用力导布局的算法（ps：引入库伦斥力及胡克弹力阻尼衰减进行动效展示，同时配合边线权重进行节点聚合），对于这方面感兴趣的同学，可以参考今年SEE Conf的"),t("a",{attrs:{href:"https://www.yuque.com/vee/blog/ksqqu2",target:"_blank",rel:"noopener noreferrer"}},[e._v("《图解万物——AntV图可视化分析解决方案》"),t("OutboundLink")],1),e._v("，数据可视化领域既专业又交叉，对于深挖此道的同学还是需要下一番功夫的。")]),e._v(" "),t("h2",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://echarts.apache.org/examples/zh/index.html#chart-type-graph",target:"_blank",rel:"noopener noreferrer"}},[e._v("ECharts关系图官网"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/apache/echarts",target:"_blank",rel:"noopener noreferrer"}},[e._v("ECharts官方源码"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://blog.csdn.net/future_todo/article/details/60956942",target:"_blank",rel:"noopener noreferrer"}},[e._v("ECharts 3.0源码简要分析1-总体架构"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/ecomfe/zrender",target:"_blank",rel:"noopener noreferrer"}},[e._v("ZRender官方源码"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://www.cnblogs.com/hhstuhacker/p/zrender-source-advance-frame.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("ZRender源码分析1：总体结构"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://www.cnblogs.com/hhstuhacker/p/zrender-source-storage-advance.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("ZRender源码分析2：Storage(Model层)"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://www.cnblogs.com/hhstuhacker/p/zrender-source-painter-part1.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("ZRender源码分析3：Painter(View层)-上"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://www.cnblogs.com/hhstuhacker/p/zrender-source-painter-part2.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("ZRender源码分析4：Painter(View层)-中"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://www.cnblogs.com/hhstuhacker/p/zrender-source-painter-shape.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("ZRender源码分析5：Shape绘图详解"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://www.cnblogs.com/hhstuhacker/p/zrender-source-painter-shape-path.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("ZRender源码分析6：Shape对象详解之路径"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://g6.antv.vision/zh",target:"_blank",rel:"noopener noreferrer"}},[e._v("G6官网"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/antvis/G6",target:"_blank",rel:"noopener noreferrer"}},[e._v("G6官方源码"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://www.yuque.com/antv/g6/gbc3i3",target:"_blank",rel:"noopener noreferrer"}},[e._v("G6源码阅读-part1-运行主流程"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://www.yuque.com/antv/g6/hz2vzh",target:"_blank",rel:"noopener noreferrer"}},[e._v("G6源码阅读-Part2-Item与Shape"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://www.yuque.com/antv/g6/yb3hmn",target:"_blank",rel:"noopener noreferrer"}},[e._v("G6源码阅读-Part3-绘制Paint"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/antvis/graphin",target:"_blank",rel:"noopener noreferrer"}},[e._v("Graphin官方源码"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://graphin.antv.vision/zh",target:"_blank",rel:"noopener noreferrer"}},[e._v("Graphin官网"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);n.default=r.exports}}]);
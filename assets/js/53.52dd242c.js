(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{256:function(e,t,n){"use strict";n.r(t);var r=n(0),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"vee-cli脚手架实践-下"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vee-cli脚手架实践-下"}},[e._v("#")]),e._v(" vee-cli脚手架实践(下)")]),e._v(" "),n("h2",{attrs:{id:"前言"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),n("p",[e._v("书接上回 "),n("a",{attrs:{href:"https://vleedesigntheory.github.io/tech/front/cli20200702.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("vee-cli脚手架实践(中)"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("上回主要介绍了create.js脚本的模板选择与拉取，本篇旨在讲述选择对应模板后编译以及最后的npm发包")]),e._v(" "),n("h2",{attrs:{id:"模板编译"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#模板编译"}},[e._v("#")]),e._v(" 模板编译")]),e._v(" "),n("h3",{attrs:{id:"依赖包"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#依赖包"}},[e._v("#")]),e._v(" 依赖包")]),e._v(" "),n("p",[n("img",{attrs:{src:"/tech/front/cli20200703/cli01.jpeg",alt:"图片"}})]),e._v(" "),n("p",[e._v("[包目录结构]")]),e._v(" "),n("ul",[n("li",[e._v("metalsmith (用于遍历文件夹，判断是否需要进行模板渲染)")]),e._v(" "),n("li",[e._v("consolidate (统一所有的模板引擎)")])]),e._v(" "),n("p",[e._v("[目录描述] 对于有模板引擎渲染的仓库，一般会有一个ask.js，")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("module.exports = [\n    {\n      type: 'confirm',\n      name: 'private',\n      message: 'ths resgistery is private?',\n    },\n    {\n      type: 'input',\n      name: 'author',\n      message: 'author?',\n    },\n    {\n      type: 'input',\n      name: 'description',\n      message: 'description?',\n    },\n    {\n      type: 'input',\n      name: 'license',\n      message: 'license?',\n    },\n  ]\n")])])]),n("p",[e._v("与用户进行命令行交互后，将对应的内容动态注入到模板中，这里常用的模板引擎有ejs、handlebars等，consolidate将这里用到的引擎进行了统一，可以自由选择")]),e._v(" "),n("h3",{attrs:{id:"逻辑代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#逻辑代码"}},[e._v("#")]),e._v(" 逻辑代码")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 判断是否存在ask.js文件\nif(!fs.existsSync(path.join(result, 'ask.js'))) {\n    // 直接下载\n    await ncpPro(result, path.resolve(projectName));\n} else {\n    // 模板渲染后再拷贝\n    await new Promise((resolve,reject) => {\n      MetalSmith(__dirname)\n        .source(result)\n        .destination(path.resolve(projectName))\n        .use(async (files, metal, done) => {\n            const a = require(path.join(result, 'ask.js'));\n            const r = await Inquirer.prompt(a);\n            const m = metal.metadata();\n            Object.assign(m, r);\n            delete files['ask.js'];\n            done()\n        })\n        .use((files, metal, done) => {\n            const meta = metal.metadata();\n            Object.keys(files).forEach(async (file) => {\n                let c = files[file].contents.toString();\n                // 只有js和json文件才去做处理\n                if(file.includes('js') || file.includes('json')) {\n                    // 判断是否是模板 可用正则匹配\n                    if(c.includes('<%')) {\n                        c = await renderPro(c, meta);\n                        files[file].contents = Buffer.from(c);\n                    }\n                }\n            })\n            done()\n        })\n        .build((err) => {\n            if(err) {\n                reject()\n            } else {\n                resolve()\n            }\n        })\n    })\n}\n")])])]),n("p",[e._v("这里主要是对之前直接down仓库内容复制做了扩展，判断是否需要进行模板编译，也就是用户是否需要再次输入内容，动态的注入到拉取的模板中，这里还可以选择更多的其他配置，但大致原理基本一致，具体详细的可以参看"),n("a",{attrs:{href:"https://github.com/vuejs/vue-cli",target:"_blank",rel:"noopener noreferrer"}},[e._v("vue-cli源码"),n("OutboundLink")],1),e._v("，其中对其他部分也做了更为详尽的扩展")]),e._v(" "),n("h3",{attrs:{id:"相关包源码分析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#相关包源码分析"}},[e._v("#")]),e._v(" 相关包源码分析")]),e._v(" "),n("h4",{attrs:{id:"metalsmith"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#metalsmith"}},[e._v("#")]),e._v(" metalsmith")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("var assert = require('assert')\nvar clone = require('clone')\nvar fs = require('co-fs-extra')\nvar matter = require('gray-matter')\nvar Mode = require('stat-mode')\nvar path = require('path')\nvar readdir = require('recursive-readdir')\nvar rm = require('rimraf')\nvar thunkify = require('thunkify')\nvar unyield = require('unyield')\nvar utf8 = require('is-utf8')\nvar Ware = require('ware')\n\nreaddir = thunkify(readdir)\nrm = thunkify(rm)\n\n\nvar isBoolean = function(b) {return typeof b === 'boolean'}\nvar isNumber  = function(n) {return typeof n === 'number' && !Number.isNaN(n)}\nvar isObject  = function(o) {return o !== null && typeof o === 'object'}\nvar isString  = function(s) {return typeof s === 'string'}\n\nmodule.exports = Metalsmith\n\n\nfunction Metalsmith(directory){\n  if (!(this instanceof Metalsmith)) return new Metalsmith(directory)\n  assert(directory, 'You must pass a working directory path.')\n  this.plugins = []\n  this.ignores = []\n  this.directory(directory)\n  this.metadata({})\n  this.source('src')\n  this.destination('build')\n  this.concurrency(Infinity)\n  this.clean(true)\n  this.frontmatter(true)\n}\n\nMetalsmith.prototype.use = function(plugin){\n  this.plugins.push(plugin)\n  return this\n}\n\n\nMetalsmith.prototype.directory = function(directory){\n  if (!arguments.length) return path.resolve(this._directory)\n  assert(isString(directory), 'You must pass a directory path string.')\n  this._directory = directory\n  return this\n}\n\n\nMetalsmith.prototype.metadata = function(metadata){\n  if (!arguments.length) return this._metadata\n  assert(isObject(metadata), 'You must pass a metadata object.')\n  this._metadata = clone(metadata)\n  return this\n}\n\n\nMetalsmith.prototype.source = function(path){\n  if (!arguments.length) return this.path(this._source)\n  assert(isString(path), 'You must pass a source path string.')\n  this._source = path\n  return this\n}\n\nMetalsmith.prototype.destination = function(path){\n  if (!arguments.length) return this.path(this._destination)\n  assert(isString(path), 'You must pass a destination path string.')\n  this._destination = path\n  return this\n}\n\nMetalsmith.prototype.concurrency = function(max){\n  if (!arguments.length) return this._concurrency\n  assert(isNumber(max), 'You must pass a number for concurrency.')\n  this._concurrency = max\n  return this\n}\n\nMetalsmith.prototype.clean = function(clean){\n  if (!arguments.length) return this._clean\n  assert(isBoolean(clean), 'You must pass a boolean.')\n  this._clean = clean\n  return this\n}\n\nMetalsmith.prototype.frontmatter = function(frontmatter){\n  if (!arguments.length) return this._frontmatter\n  assert(isBoolean(frontmatter), 'You must pass a boolean.')\n  this._frontmatter = frontmatter\n  return this\n}\n\nMetalsmith.prototype.ignore = function(files){\n  if (!arguments.length) return this.ignores.slice()\n  this.ignores = this.ignores.concat(files)\n  return this\n}\n\nMetalsmith.prototype.path = function(){\n  var paths = [].slice.call(arguments)\n  paths.unshift(this.directory())\n  return path.resolve.apply(path, paths)\n}\n\nMetalsmith.prototype.build = unyield(function*(){\n  var clean = this.clean()\n  var dest = this.destination()\n  if (clean) yield rm(path.join(dest, '*'), { glob: { dot: true } })\n\n  var files = yield this.process()\n  yield this.write(files)\n  return files\n})\n\nMetalsmith.prototype.process = unyield(function*(){\n  var files = yield this.read()\n  files = yield this.run(files)\n  return files\n})\n\nMetalsmith.prototype.run = unyield(function*(files, plugins){\n  var ware = new Ware(plugins || this.plugins)\n  var run = thunkify(ware.run.bind(ware))\n  var res = yield run(files, this)\n  return res[0]\n})\n\nMetalsmith.prototype.read = unyield(function*(dir){\n  dir = dir || this.source()\n  var read = this.readFile.bind(this)\n  var concurrency = this.concurrency()\n  var ignores = this.ignores || null\n  var paths = yield readdir(dir, ignores)\n  var files = []\n  var complete = 0\n  var batch\n\n  while (complete < paths.length) {\n    batch = paths.slice(complete, complete + concurrency)\n    batch = yield batch.map(read)\n    files = files.concat(batch)\n    complete += concurrency\n  }\n\n  return paths.reduce(memoizer, {})\n\n  function memoizer(memo, file, i) {\n    file = path.relative(dir, file)\n    memo[file] = files[i]\n    return memo\n  }\n})\n\nMetalsmith.prototype.readFile = unyield(function*(file){\n  var src = this.source()\n  var ret = {}\n\n  if (!path.isAbsolute(file)) file = path.resolve(src, file)\n\n  try {\n    var frontmatter = this.frontmatter()\n    var stats = yield fs.stat(file)\n    var buffer = yield fs.readFile(file)\n    var parsed\n\n    if (frontmatter && utf8(buffer)) {\n      try {\n        parsed = matter(buffer.toString())\n      } catch (e) {\n        var err = new Error('Invalid frontmatter in the file at: ' + file)\n        err.code = 'invalid_frontmatter'\n        throw err\n      }\n      ret = parsed.data\n      ret.contents = (Buffer.hasOwnProperty('from'))\n        ? Buffer.from(parsed.content) \n        : new Buffer(parsed.content)\n    } else {\n      ret.contents = buffer\n    }\n\n    ret.mode = Mode(stats).toOctal()\n    ret.stats = stats\n  } catch (e) {\n    if (e.code == 'invalid_frontmatter') throw e\n    e.message = 'Failed to read the file at: ' + file + '\\n\\n' + e.message\n    e.code = 'failed_read'\n    throw e\n  }\n\n  return ret\n})\n\nMetalsmith.prototype.write = unyield(function*(files, dir){\n  dir = dir || this.destination()\n  var write = this.writeFile.bind(this)\n  var concurrency = this.concurrency()\n  var keys = Object.keys(files)\n  var complete = 0\n  var batch\n\n  while (complete < keys.length) {\n    batch = keys.slice(complete, complete + concurrency)\n    yield batch.map(writer)\n    complete += concurrency\n  }\n\n  function writer(key){\n    var file = path.resolve(dir, key)\n    return write(file, files[key])\n  }\n})\n\nMetalsmith.prototype.writeFile = unyield(function*(file, data){\n  var dest = this.destination()\n  if (!path.isAbsolute(file)) file = path.resolve(dest, file)\n\n  try {\n    yield fs.outputFile(file, data.contents)\n    if (data.mode) yield fs.chmod(file, data.mode)\n  } catch (e) {\n    e.message = 'Failed to write the file at: ' + file + '\\n\\n' + e.message\n    throw e\n  }\n})\n")])])]),n("p",[e._v("metalsmith用的是挂在原型上的写法，通过插件的链式传递方法进行数据的透传，属于原型设计模式的应用，对于js来说原型模式是天生存在的，因而对于希望通过链式传递且写法且变量不多的小型库而言，这种方式不失为一种好的方法，对链式调用有兴趣的同学可以研究下"),n("a",{attrs:{href:"https://github.com/jquery/jquery",target:"_blank",rel:"noopener noreferrer"}},[e._v("jQuery源码"),n("OutboundLink")],1),e._v("及"),n("a",{attrs:{href:"https://github.com/koajs/koa",target:"_blank",rel:"noopener noreferrer"}},[e._v("koa源码"),n("OutboundLink")],1),e._v("，虽然大型库组织不是一种模式的展现，但是其中小部分还是有异曲同工的地方的，对于链式调用的实现方法也可以有一个横向的扩展和对比")]),e._v(" "),n("h4",{attrs:{id:"consolidate"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#consolidate"}},[e._v("#")]),e._v(" consolidate")]),e._v(" "),n("p",[e._v("consolidate主要是对不同模板引擎的选择分发，这里挑选了最核心的几个功能函数")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function cache(options, compiled) {\n    \n  if (compiled && options.filename && options.cache) {\n    delete readCache[options.filename];\n    cacheStore[options.filename] = compiled;\n    return compiled;\n  }\n\n  if (options.filename && options.cache) {\n    return cacheStore[options.filename];\n  }\n\n  return compiled;\n}\n\nfunction read(path, options, cb) {\n  var str = readCache[path];\n  var cached = options.cache && str && typeof str === 'string';\n\n  if (cached) return cb(null, str);\n\n  fs.readFile(path, 'utf8', function(err, str) {\n    if (err) return cb(err);\n    str = str.replace(/^\\uFEFF/, '');\n    if (options.cache) readCache[path] = str;\n    cb(null, str);\n  });\n}\n\nfunction readPartials(path, options, cb) {\n  if (!options.partials) return cb();\n  var keys = Object.keys(options.partials);\n  var partials = {};\n\n  function next(index) {\n    if (index === keys.length) return cb(null, partials);\n    var key = keys[index];\n    var partialPath = options.partials[key];\n\n    if (partialPath === undefined || partialPath === null || partialPath === false) {\n      return next(++index);\n    }\n\n    var file;\n    if (isAbsolute(partialPath)) {\n      if (extname(partialPath) !== '') {\n        file = partialPath;\n      } else {\n        file = join(partialPath + extname(path));\n      }\n    } else {\n      file = join(dirname(path), partialPath + extname(path));\n    }\n\n    read(file, options, function(err, str) {\n      if (err) return cb(err);\n      partials[key] = str;\n      next(++index);\n    });\n  }\n\n  next(0);\n}\n\nfunction fromStringRenderer(name) {\n  return function(path, options, cb) {\n    options.filename = path;\n\n    return promisify(cb, function(cb) {\n      readPartials(path, options, function(err, partials) {\n        var extend = (requires.extend || (requires.extend = require('util')._extend));\n        var opts = extend({}, options);\n        opts.partials = partials;\n        if (err) return cb(err);\n        if (cache(opts)) {\n          exports[name].render('', opts, cb);\n        } else {\n          read(path, opts, function(err, str) {\n            if (err) return cb(err);\n            exports[name].render(str, opts, cb);\n          });\n        }\n      });\n    });\n  };\n}\n")])])]),n("p",[e._v("consolidate这个库也是tj大佬写的，其主要思路是通过读取[read]对应文件里的字符[readPartials]获取到需要的字符后对字符进行查找对应名称[fromStringRenderer]的渲染，其中读取过程做了[cache]优化，剩下的就是对对应的模板渲染引擎的分发，从而做到了汇聚分发的效果，整体思路还是很明确的，另外多说一句，tj大佬似乎对类生成器函数处理有种蜜汁喜爱，各种库都有它的影子，对生成器方式处理感兴趣的同学，可以参考"),n("a",{attrs:{href:"https://github.com/we452366/co",target:"_blank",rel:"noopener noreferrer"}},[e._v("co库源码"),n("OutboundLink")],1)]),e._v(" "),n("h2",{attrs:{id:"发包"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#发包"}},[e._v("#")]),e._v(" 发包")]),e._v(" "),n("h3",{attrs:{id:"连接npm"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#连接npm"}},[e._v("#")]),e._v(" 连接npm")]),e._v(" "),n("p",[n("img",{attrs:{src:"/tech/front/cli20200703/cli02.jpeg",alt:"图片"}})]),e._v(" "),n("p",[e._v("连接npm源(如果没有nrm，需要"),n("code",[e._v("npm i nrm -g")]),e._v(") => 填写npm官网的个人用户信息")]),e._v(" "),n("h3",{attrs:{id:"发布到npm"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#发布到npm"}},[e._v("#")]),e._v(" 发布到npm")]),e._v(" "),n("p",[n("img",{attrs:{src:"/tech/front/cli20200703/cli03.png",alt:"图片"}})]),e._v(" "),n("p",[e._v("对于整个npm发包等感兴趣的同学，可以参考"),n("a",{attrs:{href:"https://docs.npmjs.com/cli-documentation/",target:"_blank",rel:"noopener noreferrer"}},[e._v("npm文档"),n("OutboundLink")],1),e._v("，也可以参考这篇文章"),n("a",{attrs:{href:"https://segmentfault.com/a/1190000015939001",target:"_blank",rel:"noopener noreferrer"}},[e._v("npm包的发布与删除"),n("OutboundLink")],1)]),e._v(" "),n("h3",{attrs:{id:"验证"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#验证"}},[e._v("#")]),e._v(" 验证")]),e._v(" "),n("p",[n("img",{attrs:{src:"/tech/front/cli20200703/cli04.png",alt:"图片"}})]),e._v(" "),n("p",[e._v("搜索npmjs官网上，可以查找到，"),n("code",[e._v("npm unlink")]),e._v("后或换一台机器，可以"),n("code",[e._v("npm i vee-cli")]),e._v("进行包下载，这样一个脚手架的发包就完成了")]),e._v(" "),n("h2",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),n("p",[e._v("脚手架是前端工程化领域的基本项，个人认为掌握前端脚手架的开发是十分重要的，这三篇内容\n"),n("a",{attrs:{href:"https://vleedesigntheory.github.io/tech/front/cli20200701.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("vee-cli脚手架实践(上)"),n("OutboundLink")],1),e._v(" "),n("a",{attrs:{href:"https://vleedesigntheory.github.io/tech/front/cli20200702.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("vee-cli脚手架实践(中)"),n("OutboundLink")],1),e._v(" "),n("a",{attrs:{href:"https://vleedesigntheory.github.io/tech/front/cli20200703.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("vee-cli脚手架实践(下)"),n("OutboundLink")],1),e._v("\n旨在提供一个大概思路及样板，目前只包含了")]),e._v(" "),n("blockquote",[n("p",[e._v("1、命令行；2、模板拉取；")])]),e._v(" "),n("p",[e._v("，其相对于成熟的脚手架如vue-cli、create-react-app、@angular/cli等来说，还有很多很多工作要做，包括")]),e._v(" "),n("blockquote",[n("p",[e._v("3、本地服务；4、打包构建；5、集成部署；6、周边其他")])]),e._v(" "),n("p",[e._v("等都还需要完善，想要在工程化领域有所建树的同学，不妨在这几个方面多下下功夫")]),e._v(" "),n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/we452366/vee-cli",target:"_blank",rel:"noopener noreferrer"}},[e._v("vee-cli源代码"),n("OutboundLink")],1),n("br")])]),e._v(" "),n("h2",{attrs:{id:"参考"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"https://github.com/segmentio/metalsmith",target:"_blank",rel:"noopener noreferrer"}},[e._v("metalsmith.js源码"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://github.com/tj/consolidate.js",target:"_blank",rel:"noopener noreferrer"}},[e._v("consolidate.js源码"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://github.com/we452366/co",target:"_blank",rel:"noopener noreferrer"}},[e._v("co.js源码"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://github.com/jquery/jquery",target:"_blank",rel:"noopener noreferrer"}},[e._v("jquery.js源码"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://github.com/koajs/koa",target:"_blank",rel:"noopener noreferrer"}},[e._v("koa.js源码"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://segmentfault.com/q/1010000018137835/",target:"_blank",rel:"noopener noreferrer"}},[e._v("npm包可以修改名字吗？"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://segmentfault.com/a/1190000017867834",target:"_blank",rel:"noopener noreferrer"}},[e._v("用Angular脚手架搭建项目"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://www.jianshu.com/p/27d111a50a06?utm_campaign=haruki&utm_content=note&utm_medium=reader_share&utm_source=qq",target:"_blank",rel:"noopener noreferrer"}},[e._v("React（脚手架）"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2015/05/co.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("co 函数库的含义和用法"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://www.zhihu.com/question/32524504",target:"_blank",rel:"noopener noreferrer"}},[e._v("有哪些好用的前端模板引擎？"),n("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=a.exports}}]);
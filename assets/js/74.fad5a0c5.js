(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{278:function(e,n,t){"use strict";t.r(n);var r=t(0),s=Object(r.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"react17源码浅析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react17源码浅析"}},[e._v("#")]),e._v(" react17源码浅析")]),e._v(" "),t("h2",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/react20210305/react01.png",alt:"图片"}})]),e._v(" "),t("p",[e._v("React17自去年十月发布以来，出现了几个比较重要的变化。首先，17作为一个过渡版本，其明确了在react中的定位，即：承上启下，作为渐进式框架的首版本，在后续的18、19等版本中会进行渐进升级而不是强制进行硬切换；其次，17结合最新的浏览器的特性做了一些更改和优化，比如对合成事件系统的优化；最后，自16以来的基于Fiber架构的模式对整个react性能优化在每个小版本中也会不断的进行逐步的微调，每次的微调都透露着react大佬们的一些思路与思考。本文以react17.0.0版本的源码入手，着重从react-reconciler和scheduler这两个模块中的部分源码进行拆解和浅析，希望能够窥一斑而见全豹，揣度各位大佬的一些架构思路和想法，从而拓宽一些个人的眼界，然个人水平有限，难免管窥蠡测，对react的理解也可能有所偏颇，本着想将这样一个庞大的架构简洁分析出来的想法，希望能对各位同学有所启发，对于更为经典的部分，仍需要各位去品读源码，我们仍然应该对源码保持着一颗敬畏之心，随着技术的提升，每每品读都会有不同的感受！")]),e._v(" "),t("h2",{attrs:{id:"目录结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#目录结构"}},[e._v("#")]),e._v(" 目录结构")]),e._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/react20210305/react02.png",alt:"图片"}})]),e._v(" "),t("p",[e._v("react目录比较大，涉猎的也比较多，这里只显示可能会涉及部分的目录")]),e._v(" "),t("ul",[t("li",[e._v("packages\n"),t("ul",[t("li",[e._v("react\n"),t("ul",[t("li",[e._v("src\n"),t("ul",[t("li",[e._v("jsx\n"),t("ul",[t("li",[e._v("ReactJSX.js")]),e._v(" "),t("li",[e._v("ReactJSXElement.js (定义了jsx)")]),e._v(" "),t("li",[e._v("ReactJSXElementValidator.js")])])]),e._v(" "),t("li",[e._v("React.js")]),e._v(" "),t("li",[e._v("ReactBaseClasses.js （setState及forceState)")]),e._v(" "),t("li",[e._v("ReactContext.js (context上下文及Provider和Consumer)")]),e._v(" "),t("li",[e._v("ReactElement.js (定义了ReactElement的格式)")]),e._v(" "),t("li",[e._v("ReactForwardRef.js (Ref的定义)")]),e._v(" "),t("li",[e._v("ReactHooks.js (ReactHooks相关，不是本文重点，可以参看之前的文章)")]),e._v(" "),t("li",[e._v("ReactLazy.js")]),e._v(" "),t("li",[e._v("ReactMemo.js")]),e._v(" "),t("li",[e._v("ReactMutableSource.js")]),e._v(" "),t("li",[e._v("ReactStartTransition.js (批量更新的事务的概念)")])])])])]),e._v(" "),t("li",[e._v("react-dom\n"),t("ul",[t("li",[e._v("src\n"),t("ul",[t("li",[e._v("clients\n"),t("ul",[t("li",[e._v("ReactDOMHostConfig.js")]),e._v(" "),t("li",[e._v("ReactDOMLegacy.js")]),e._v(" "),t("li",[e._v("ReactDOMRoot.js (三种模式：legacy模式、blocking模式、concurrent模式)")])])]),e._v(" "),t("li",[e._v("events\n"),t("ul",[t("li",[e._v("EventListeners.js")]),e._v(" "),t("li",[e._v("ReactDOMEventListeners.js")]),e._v(" "),t("li",[e._v("SyntheticEvent.js")])])]),e._v(" "),t("li",[e._v("server (React Sever Component相关，不展开讲了)")])])])])]),e._v(" "),t("li",[e._v("react-reconciler\n"),t("ul",[t("li",[e._v("src\n"),t("ul",[t("li",[e._v("ReactChildFiber.js")]),e._v(" "),t("li",[e._v("ReactFiber.js")]),e._v(" "),t("li",[e._v("ReactFiberBeginWork.js")]),e._v(" "),t("li",[e._v("ReactFiberCommitWork.js")]),e._v(" "),t("li",[e._v("ReactFiberCompleteWork.js")]),e._v(" "),t("li",[e._v("ReactFiberLane.js")]),e._v(" "),t("li",[e._v("ReactFiberReconciler.js")]),e._v(" "),t("li",[e._v("ReactFiberRoot.js")]),e._v(" "),t("li",[e._v("ReactFiberWorkLoop.js")])])])])]),e._v(" "),t("li",[e._v("scheduler\n"),t("ul",[t("li",[e._v("src\n"),t("ul",[t("li",[e._v("Scheduler.js")]),e._v(" "),t("li",[e._v("SchedulerMinHeap.js")]),e._v(" "),t("li",[e._v("SchedulerPostTask.js")]),e._v(" "),t("li",[e._v("SchedulerProfiling.js")])])])])])])])]),e._v(" "),t("h2",{attrs:{id:"源码解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#源码解析"}},[e._v("#")]),e._v(" 源码解析")]),e._v(" "),t("p",[e._v("整个React的Fiber架构的核心在于对浏览器进行了时间分片处理（ps：Firefox新版本自身也实现了时间分片），抹掉了平台的差异，从而使得浏览器处理时候可以将控制权交出去，避免了js线程过多占用而阻塞渲染线程，实现了更细粒度的调度，即为：协程或纤程的调度")]),e._v(" "),t("h3",{attrs:{id:"react"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react"}},[e._v("#")]),e._v(" React")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",{staticStyle:{"text-align":"left"}},[e._v("文件名")]),e._v(" "),t("th",{staticStyle:{"text-align":"center"}},[e._v("作用")]),e._v(" "),t("th",{staticStyle:{"text-align":"right"}},[e._v("备注")])])]),e._v(" "),t("tbody",[t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("jsx-runtime.js")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("jsx解释器")]),e._v(" "),t("td",{staticStyle:{"text-align":"right"}},[e._v("编译jsx")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("ReactElement.js")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("React元素的格式")]),e._v(" "),t("td",{staticStyle:{"text-align":"right"}},[e._v("React的结点格式信息")])])])]),e._v(" "),t("h4",{attrs:{id:"jsx-runtime-js"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jsx-runtime-js"}},[e._v("#")]),e._v(" jsx-runtime.js")]),e._v(" "),t("p",[e._v("react17之后不再需要对每个react组件进行react的import，其内置了一个jsx-runtime的运行时，感兴趣的同学可以看一下这个"),t("a",{attrs:{href:"https://cdn.bootcdn.net/ajax/libs/react/15.7.0/cjs/react-jsx-dev-runtime.development.js",target:"_blank",rel:"noopener noreferrer"}},[e._v("react-jsx-dev-runtime.development.js"),t("OutboundLink")],1),e._v("，简单来说就是利用正则对jsx进行了一层浅的转化，本质jsx是对js的一种扩展")]),e._v(" "),t("h4",{attrs:{id:"reactelement-js"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reactelement-js"}},[e._v("#")]),e._v(" ReactElement.js")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const ReactElement = function(\n  type,\n  key,\n  ref,\n  self,\n  source,\n  owner,\n  props\n) {\n  const element = {\n    $$typeof: REACT_ELEMENT_TYPE,\n    type: type,\n    key: key,\n    ref: ref,\n    props: props\n  }\n}\n")])])]),t("h3",{attrs:{id:"react-dom"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react-dom"}},[e._v("#")]),e._v(" React-DOM")]),e._v(" "),t("p",[e._v("这里主要对合成事件及DOM的一些处理进行了阐述")]),e._v(" "),t("h2",[e._v("DOM处理")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",{staticStyle:{"text-align":"left"}},[e._v("文件名")]),e._v(" "),t("th",{staticStyle:{"text-align":"center"}},[e._v("作用")]),e._v(" "),t("th",{staticStyle:{"text-align":"right"}},[e._v("备注")])])]),e._v(" "),t("tbody",[t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("ReactDOMHostConfig.js")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("appendChildToContainer等")]),e._v(" "),t("td",{staticStyle:{"text-align":"right"}},[e._v("原生dom操作")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("ReactDOMLegacy.js")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("legacyRenderSubtreeIntoContainer")]),e._v(" "),t("td",{staticStyle:{"text-align":"right"}},[e._v("未启用异步渲染的dom操作")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("ReactDOMRoot.js")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("createRoot、createLegacyRoot、createBlockingRoot")]),e._v(" "),t("td",{staticStyle:{"text-align":"right"}},[e._v("三种模式的根组件")])])])]),e._v(" "),t("p",[e._v("React17的进行了模式的设置，分别为：Legacy模式、Concurrent模式、Blocking模式，其中Concurrent模式是启用fiber分片的异步渲染方式，而Legacy模式则仍是15的同步渲染模式，Blocking则是介于二者之间的模式，React有意按照这样一种渐进的方式进行过度")]),e._v(" "),t("h2",[e._v("合成事件")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",{staticStyle:{"text-align":"left"}},[e._v("文件名")]),e._v(" "),t("th",{staticStyle:{"text-align":"center"}},[e._v("作用")]),e._v(" "),t("th",{staticStyle:{"text-align":"right"}},[e._v("备注")])])]),e._v(" "),t("tbody",[t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("EventListeners.js")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("addEventCaptureListener、addEventBubbleListener")]),e._v(" "),t("td",{staticStyle:{"text-align":"right"}},[e._v("原生事件监听")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("ReactDOMEventListeners.js")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("dispatchEvent")]),e._v(" "),t("td",{staticStyle:{"text-align":"right"}},[e._v("React的事件")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("SyntheticEvent.js")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("createSyntheticEvent")]),e._v(" "),t("td",{staticStyle:{"text-align":"right"}},[e._v("合成事件")])])])]),e._v(" "),t("h4",{attrs:{id:"reactdomeventlisteners-js"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reactdomeventlisteners-js"}},[e._v("#")]),e._v(" ReactDOMEventListeners.js")]),e._v(" "),t("p",[e._v("核心是dispatchEvent进行事件的分发，17之后不再将事件全部冒泡到document去代理，这和浏览器的改进有关，不再需要代理绑定，浏览器可以对更细粒度的区域进行监听")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function dispatchDiscreateEvent() {\n\n}\n\nfunction dispatchBlockingEvent() {\n\n}\n\nexport function dispatchEvent(\n  domEventName: DOMEventName,\n  eventSystemFlags: EventSystemFlags,\n  targetContainer: EventTarget,\n  nativeEvent: AnyNativeEvent,\n): void {\n  if (\n    allowReplay &&\n    hasQueuedDiscreteEvents() &&\n    isReplayableDiscreteEvent(domEventName)\n  ) {\n    queueDiscreteEvent(\n      null, // Flags that we're not actually blocked on anything as far as we know.\n      domEventName,\n      eventSystemFlags,\n      targetContainer,\n      nativeEvent,\n    );\n    return;\n  }\n\n  const blockedOn = attemptToDispatchEvent(\n    domEventName,\n    eventSystemFlags,\n    targetContainer,\n    nativeEvent,\n  );\n\n  if (blockedOn === null) {\n    // We successfully dispatched this event.\n    if (allowReplay) {\n      clearIfContinuousEvent(domEventName, nativeEvent);\n    }\n    return;\n  }\n\n  if (allowReplay) {\n    if (isReplayableDiscreteEvent(domEventName)) {\n      queueDiscreteEvent(\n        blockedOn,\n        domEventName,\n        eventSystemFlags,\n        targetContainer,\n        nativeEvent,\n      );\n      return;\n    }\n    if (\n      queueIfContinuousEvent(\n        blockedOn,\n        domEventName,\n        eventSystemFlags,\n        targetContainer,\n        nativeEvent,\n      )\n    ) {\n      return;\n    }\n    clearIfContinuousEvent(domEventName, nativeEvent);\n  }\n  dispatchEventForPluginEventSystem(\n    domEventName,\n    eventSystemFlags,\n    nativeEvent,\n    null,\n    targetContainer,\n  );\n}\n")])])]),t("h3",{attrs:{id:"scheduler"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#scheduler"}},[e._v("#")]),e._v(" Scheduler")]),e._v(" "),t("p",[e._v("本质是根据任务开始时间和过期时间利用小顶堆的优先队列而进行的时间分片处理及调度")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",{staticStyle:{"text-align":"left"}},[e._v("文件名")]),e._v(" "),t("th",{staticStyle:{"text-align":"center"}},[e._v("作用")]),e._v(" "),t("th",{staticStyle:{"text-align":"right"}},[e._v("备注")])])]),e._v(" "),t("tbody",[t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("Scheduler.js")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("workLoop")]),e._v(" "),t("td",{staticStyle:{"text-align":"right"}},[e._v("调度入口")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("SchedulerMinHeap.js")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("小顶堆")]),e._v(" "),t("td",{staticStyle:{"text-align":"right"}},[e._v("优先队列的小顶堆")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("SchedulerPostTask.js")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("unstable_scheduleCallback、unstable_shouldYield")]),e._v(" "),t("td",{staticStyle:{"text-align":"right"}},[e._v("调度方法")])])])]),e._v(" "),t("h4",{attrs:{id:"schdeuler-js"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#schdeuler-js"}},[e._v("#")]),e._v(" Schdeuler.js")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function advanceTimers(currentTime) {\n  let timer = peek(timerQueue);\n  while (timer !== null) {\n    if (timer.callback === null) {\n      pop(timerQueue);\n    } else if (timer.startTime <= currentTime) {\n      pop(timerQueue);\n      timer.sortIndex = timer.expirationTime;\n      push(taskQueue, timer);\n      if (enableProfiling) {\n        markTaskStart(timer, currentTime);\n        timer.isQueued = true;\n      }\n    } else {\n      return;\n    }\n    timer = peek(timerQueue);\n  }\n}\n\nfunction handleTimeout(currentTime) {\n  isHostTimeoutScheduled = false;\n  advanceTimers(currentTime);\n\n  if (!isHostCallbackScheduled) {\n    if (peek(taskQueue) !== null) {\n      isHostCallbackScheduled = true;\n      requestHostCallback(flushWork);\n    } else {\n      const firstTimer = peek(timerQueue);\n      if (firstTimer !== null) {\n        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n      }\n    }\n  }\n}\n\nfunction workLoop(hasTimeRemaining, initialTime) {\n  let currentTime = initialTime;\n  advanceTimers(currentTime);\n  currentTask = peek(taskQueue);\n  while (\n    currentTask !== null &&\n    !(enableSchedulerDebugging && isSchedulerPaused)\n  ) {\n    if (\n      currentTask.expirationTime > currentTime &&\n      (!hasTimeRemaining || shouldYieldToHost())\n    ) {\n      // This currentTask hasn't expired, and we've reached the deadline.\n      break;\n    }\n    const callback = currentTask.callback;\n    if (typeof callback === 'function') {\n      currentTask.callback = null;\n      currentPriorityLevel = currentTask.priorityLevel;\n      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n      markTaskRun(currentTask, currentTime);\n      const continuationCallback = callback(didUserCallbackTimeout);\n      currentTime = getCurrentTime();\n      if (typeof continuationCallback === 'function') {\n        currentTask.callback = continuationCallback;\n        markTaskYield(currentTask, currentTime);\n      } else {\n        if (enableProfiling) {\n          markTaskCompleted(currentTask, currentTime);\n          currentTask.isQueued = false;\n        }\n        if (currentTask === peek(taskQueue)) {\n          pop(taskQueue);\n        }\n      }\n      advanceTimers(currentTime);\n    } else {\n      pop(taskQueue);\n    }\n    currentTask = peek(taskQueue);\n  }\n  // Return whether there's additional work\n  if (currentTask !== null) {\n    return true;\n  } else {\n    const firstTimer = peek(timerQueue);\n    if (firstTimer !== null) {\n      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n    }\n    return false;\n  }\n}\n")])])]),t("h4",{attrs:{id:"schedulerminheap-js"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#schedulerminheap-js"}},[e._v("#")]),e._v(" SchedulerMinHeap.js")]),e._v(" "),t("p",[e._v("小顶堆的实现，可对比优先队列的考察，具体可以看一下leetcode的这道题 "),t("a",{attrs:{href:"https://leetcode-cn.com/problems/merge-k-sorted-lists/",target:"_blank",rel:"noopener noreferrer"}},[e._v("23. 合并K个升序链表"),t("OutboundLink")],1),e._v("，以及对fiber应用的扩展思考 "),t("a",{attrs:{href:"https://leetcode-cn.com/problems/partition-list/",target:"_blank",rel:"noopener noreferrer"}},[e._v("86. 分隔链表"),t("OutboundLink")],1)]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("type Heap = Array<Node>;\ntype Node = {|\n  id: number,\n  sortIndex: number,\n|};\n\nexport function push(heap: Heap, node: Node): void {\n  const index = heap.length;\n  heap.push(node);\n  siftUp(heap, node, index);\n}\n\nexport function peek(heap: Heap): Node | null {\n  const first = heap[0];\n  return first === undefined ? null : first;\n}\n\nexport function pop(heap: Heap): Node | null {\n  const first = heap[0];\n  if (first !== undefined) {\n    const last = heap.pop();\n    if (last !== first) {\n      heap[0] = last;\n      siftDown(heap, last, 0);\n    }\n    return first;\n  } else {\n    return null;\n  }\n}\n\nfunction siftUp(heap, node, i) {\n  let index = i;\n  while (true) {\n    const parentIndex = (index - 1) >>> 1;\n    const parent = heap[parentIndex];\n    if (parent !== undefined && compare(parent, node) > 0) {\n      // The parent is larger. Swap positions.\n      heap[parentIndex] = node;\n      heap[index] = parent;\n      index = parentIndex;\n    } else {\n      // The parent is smaller. Exit.\n      return;\n    }\n  }\n}\n\nfunction siftDown(heap, node, i) {\n  let index = i;\n  const length = heap.length;\n  while (index < length) {\n    const leftIndex = (index + 1) * 2 - 1;\n    const left = heap[leftIndex];\n    const rightIndex = leftIndex + 1;\n    const right = heap[rightIndex];\n\n    // If the left or right node is smaller, swap with the smaller of those.\n    if (left !== undefined && compare(left, node) < 0) {\n      if (right !== undefined && compare(right, left) < 0) {\n        heap[index] = right;\n        heap[rightIndex] = node;\n        index = rightIndex;\n      } else {\n        heap[index] = left;\n        heap[leftIndex] = node;\n        index = leftIndex;\n      }\n    } else if (right !== undefined && compare(right, node) < 0) {\n      heap[index] = right;\n      heap[rightIndex] = node;\n      index = rightIndex;\n    } else {\n      // Neither child is smaller. Exit.\n      return;\n    }\n  }\n}\n\nfunction compare(a, b) {\n  // Compare sort index first, then task id.\n  const diff = a.sortIndex - b.sortIndex;\n  return diff !== 0 ? diff : a.id - b.id;\n}\n")])])]),t("h4",{attrs:{id:"scheduleposttask-js"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#scheduleposttask-js"}},[e._v("#")]),e._v(" SchedulePostTask.js")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const getCurrentTime = perf.now.bind(perf);\n\nexport function unstable_shouldYield() {\n  return getCurrentTime() >= deadline;\n}\n\nexport function unstable_scheduleCallback<T>(\n  priorityLevel: PriorityLevel,\n  callback: SchedulerCallback<T>,\n  options?: {delay?: number},\n): CallbackNode {\n  let postTaskPriority;\n  switch (priorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n      postTaskPriority = 'user-blocking';\n      break;\n    case LowPriority:\n    case NormalPriority:\n      postTaskPriority = 'user-visible';\n      break;\n    case IdlePriority:\n      postTaskPriority = 'background';\n      break;\n    default:\n      postTaskPriority = 'user-visible';\n      break;\n  }\n\n  const controller = new TaskController();\n  const postTaskOptions = {\n    priority: postTaskPriority,\n    delay: typeof options === 'object' && options !== null ? options.delay : 0,\n    signal: controller.signal,\n  };\n\n  const node = {\n    _controller: controller,\n  };\n\n  scheduler\n    .postTask(\n      runTask.bind(null, priorityLevel, postTaskPriority, node, callback),\n      postTaskOptions,\n    )\n    .catch(handleAbortError);\n\n  return node;\n}\n\nfunction runTask<T>(\n  priorityLevel: PriorityLevel,\n  postTaskPriority: PostTaskPriorityLevel,\n  node: CallbackNode,\n  callback: SchedulerCallback<T>,\n) {\n  deadline = getCurrentTime() + yieldInterval;\n  try {\n    currentPriorityLevel_DEPRECATED = priorityLevel;\n    const didTimeout_DEPRECATED = false;\n    const result = callback(didTimeout_DEPRECATED);\n    if (typeof result === 'function') {\n      const continuation: SchedulerCallback<T> = (result: any);\n      const continuationController = new TaskController();\n      const continuationOptions = {\n        priority: postTaskPriority,\n        signal: continuationController.signal,\n      };\n      node._controller = continuationController;\n      scheduler\n        .postTask(\n          runTask.bind(\n            null,\n            priorityLevel,\n            postTaskPriority,\n            node,\n            continuation,\n          ),\n          continuationOptions,\n        )\n        .catch(handleAbortError);\n    }\n  } catch (error) {\n    setTimeout(() => {\n      throw error;\n    });\n  } finally {\n    currentPriorityLevel_DEPRECATED = NormalPriority;\n  }\n}\n")])])]),t("h3",{attrs:{id:"reconciler-renderer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reconciler-renderer"}},[e._v("#")]),e._v(" Reconciler & Renderer")]),e._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/react20210305/react03.jpeg",alt:"图片"}})]),e._v(" "),t("p",[e._v("在经过了Scheduler的分片及调度后，将分片后的单元调度进合成器中，Reconciler阶段的主要目的是找寻不同，从而对虚拟dom的不同进行fiber层级的派发和合并；对于浏览器的分片可以利用setTimeout及MessageChannel来实现，具体浏览器是如何实现setTimeout的，可以看一下这个"),t("a",{attrs:{href:"https://blog.csdn.net/u013448372/article/details/108425124",target:"_blank",rel:"noopener noreferrer"}},[e._v("浏览器工作原理(16) - setTimeout实现原理"),t("OutboundLink")],1),e._v("，")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",{staticStyle:{"text-align":"left"}},[e._v("文件名")]),e._v(" "),t("th",{staticStyle:{"text-align":"center"}},[e._v("作用")]),e._v(" "),t("th",{staticStyle:{"text-align":"right"}},[e._v("备注")])])]),e._v(" "),t("tbody",[t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("ReactChildFiber.js")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("ChildReconciler")]),e._v(" "),t("td",{staticStyle:{"text-align":"right"}},[e._v("子fiber")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("ReactFiber.js")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("Fiber")]),e._v(" "),t("td",{staticStyle:{"text-align":"right"}},[e._v("创建fiber等")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("ReactFiberBeginWork.js")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("beginwork")]),e._v(" "),t("td",{staticStyle:{"text-align":"right"}},[e._v("开始任务")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("ReactFiberCommitWork.js")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("commitwork")]),e._v(" "),t("td",{staticStyle:{"text-align":"right"}},[e._v("提交任务")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("ReactFiberCompleteWork.js")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("completework")]),e._v(" "),t("td",{staticStyle:{"text-align":"right"}},[e._v("完成任务")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("ReactFiberLane.js")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("lane")]),e._v(" "),t("td",{staticStyle:{"text-align":"right"}},[e._v("车道模型")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("ReactFiberReconciler.js")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("createContainer、updateContainer")]),e._v(" "),t("td",{staticStyle:{"text-align":"right"}},[e._v("容器")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("ReactFiberRoot.js")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("createFiberRoot")]),e._v(" "),t("td",{staticStyle:{"text-align":"right"}},[e._v("Fiber根节点")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("ReactFiberWorkLoop.js")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("all")]),e._v(" "),t("td",{staticStyle:{"text-align":"right"}},[e._v("循环的各种方法")])])])]),e._v(" "),t("h4",{attrs:{id:"reactchildfiber-js"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reactchildfiber-js"}},[e._v("#")]),e._v(" ReactChildFiber.js")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function ChildReconciler(shouldTrackSideEffects) {\n\tfunction deleteChild() {}\n\tfunction deleteRemainingChildren() {}\n\tfunction mapRemainingChildren() {}\n\tfunction useFiber() {}\n\tfunction placeChild() {}\n\tfunction placeSingleChild() {}\n\tfunction updateTextNode() {}\n\tfunction updateElement() {}\n\tfunction updatePortal() {}\n\tfunction updateFragment() {}\n\tfunction createChild() {}\n\tfunction updateSlot() {}\n\tfunction updateFromMap() {}\n\tfunction warnOnInvalidKey() {}\n\tfunction reconcileChildrenArray() {}\n\tfunction reconcileChildrenIterator() {}\n\tfunction reconcileSingleElement() {}\n\tfunction reconcileSinglePortal() {}\n\tfunction reconcileChildFibers() {}\n\treturn reconcileChildFibers;\n}\n")])])]),t("h4",{attrs:{id:"reactfiber-js"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reactfiber-js"}},[e._v("#")]),e._v(" ReactFiber.js")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function FiberNode(\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: null | string,\n  mode: TypeOfMode,\n) {\n  // Instance\n  this.tag = tag;\n  this.key = key;\n  this.elementType = null;\n  this.type = null;\n  this.stateNode = null;\n\n  // Fiber\n  this.return = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  this.pendingProps = pendingProps;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n  this.dependencies = null;\n\n  this.mode = mode;\n\n  // Effects\n  this.flags = NoFlags;\n  this.subtreeFlags = NoFlags;\n  this.deletions = null;\n\n  this.lanes = NoLanes;\n  this.childLanes = NoLanes;\n\n  this.alternate = null;\n\n  if (enableProfilerTimer) {\n    // Note: The following is done to avoid a v8 performance cliff.\n    //\n    // Initializing the fields below to smis and later updating them with\n    // double values will cause Fibers to end up having separate shapes.\n    // This behavior/bug has something to do with Object.preventExtension().\n    // Fortunately this only impacts DEV builds.\n    // Unfortunately it makes React unusably slow for some applications.\n    // To work around this, initialize the fields below with doubles.\n    //\n    // Learn more about this here:\n    // https://github.com/facebook/react/issues/14365\n    // https://bugs.chromium.org/p/v8/issues/detail?id=8538\n    this.actualDuration = Number.NaN;\n    this.actualStartTime = Number.NaN;\n    this.selfBaseDuration = Number.NaN;\n    this.treeBaseDuration = Number.NaN;\n\n    // It's okay to replace the initial doubles with smis after initialization.\n    // This won't trigger the performance cliff mentioned above,\n    // and it simplifies other profiler code (including DevTools).\n    this.actualDuration = 0;\n    this.actualStartTime = -1;\n    this.selfBaseDuration = 0;\n    this.treeBaseDuration = 0;\n  }\n\n  if (__DEV__) {\n    // This isn't directly used but is handy for debugging internals:\n    this._debugID = debugCounter++;\n    this._debugSource = null;\n    this._debugOwner = null;\n    this._debugNeedsRemount = false;\n    this._debugHookTypes = null;\n    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {\n      Object.preventExtensions(this);\n    }\n  }\n}\n\nconst createFiber = function() {}\n\nexport const createWorkInProgress = function() {}\nexport const resetWorkInProgress = function() {}\n\nexport const createHostRootFiber = function() {}\n")])])]),t("h4",{attrs:{id:"reactfiberbeginwork-js"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reactfiberbeginwork-js"}},[e._v("#")]),e._v(" ReactFiberBeginWork.js")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function beginWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n): Fiber | null {\n  const updateLanes = workInProgress.lanes;\n\n  if (__DEV__) {\n    if (workInProgress._debugNeedsRemount && current !== null) {\n      // This will restart the begin phase with a new fiber.\n      return remountFiber(\n        current,\n        workInProgress,\n        createFiberFromTypeAndProps(\n          workInProgress.type,\n          workInProgress.key,\n          workInProgress.pendingProps,\n          workInProgress._debugOwner || null,\n          workInProgress.mode,\n          workInProgress.lanes,\n        ),\n      );\n    }\n  }\n\n  if (current !== null) {\n    const oldProps = current.memoizedProps;\n    const newProps = workInProgress.pendingProps;\n\n    if (\n      oldProps !== newProps ||\n      hasLegacyContextChanged() ||\n      // Force a re-render if the implementation changed due to hot reload:\n      (__DEV__ ? workInProgress.type !== current.type : false)\n    ) {\n      // If props or context changed, mark the fiber as having performed work.\n      // This may be unset if the props are determined to be equal later (memo).\n      didReceiveUpdate = true;\n    } else if (!includesSomeLane(renderLanes, updateLanes)) {\n      didReceiveUpdate = false;\n      // This fiber does not have any pending work. Bailout without entering\n      // the begin phase. There's still some bookkeeping we that needs to be done\n      // in this optimized path, mostly pushing stuff onto the stack.\n      switch (workInProgress.tag) {\n        case HostRoot:\n          pushHostRootContext(workInProgress);\n          resetHydrationState();\n          break;\n        case HostComponent:\n          pushHostContext(workInProgress);\n          break;\n        case ClassComponent: {\n          const Component = workInProgress.type;\n          if (isLegacyContextProvider(Component)) {\n            pushLegacyContextProvider(workInProgress);\n          }\n          break;\n        }\n        case HostPortal:\n          pushHostContainer(\n            workInProgress,\n            workInProgress.stateNode.containerInfo,\n          );\n          break;\n        case ContextProvider: {\n          const newValue = workInProgress.memoizedProps.value;\n          pushProvider(workInProgress, newValue);\n          break;\n        }\n        case Profiler:\n          if (enableProfilerTimer) {\n            // Reset effect durations for the next eventual effect phase.\n            // These are reset during render to allow the DevTools commit hook a chance to read them,\n            const stateNode = workInProgress.stateNode;\n            stateNode.effectDuration = 0;\n            stateNode.passiveEffectDuration = 0;\n          }\n          break;\n        case SuspenseComponent: {\n          const state: SuspenseState | null = workInProgress.memoizedState;\n          if (state !== null) {\n            if (enableSuspenseServerRenderer) {\n              if (state.dehydrated !== null) {\n                pushSuspenseContext(\n                  workInProgress,\n                  setDefaultShallowSuspenseContext(suspenseStackCursor.current),\n                );\n                // We know that this component will suspend again because if it has\n                // been unsuspended it has committed as a resolved Suspense component.\n                // If it needs to be retried, it should have work scheduled on it.\n                workInProgress.flags |= DidCapture;\n                // We should never render the children of a dehydrated boundary until we\n                // upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.\n                return null;\n              }\n            }\n\n            // If this boundary is currently timed out, we need to decide\n            // whether to retry the primary children, or to skip over it and\n            // go straight to the fallback. Check the priority of the primary\n            // child fragment.\n            const primaryChildFragment: Fiber = (workInProgress.child: any);\n            const primaryChildLanes = primaryChildFragment.childLanes;\n            if (includesSomeLane(renderLanes, primaryChildLanes)) {\n              // The primary children have pending work. Use the normal path\n              // to attempt to render the primary children again.\n              return updateSuspenseComponent(\n                current,\n                workInProgress,\n                renderLanes,\n              );\n            } else {\n              // The primary child fragment does not have pending work marked\n              // on it\n              pushSuspenseContext(\n                workInProgress,\n                setDefaultShallowSuspenseContext(suspenseStackCursor.current),\n              );\n              // The primary children do not have pending work with sufficient\n              // priority. Bailout.\n              const child = bailoutOnAlreadyFinishedWork(\n                current,\n                workInProgress,\n                renderLanes,\n              );\n              if (child !== null) {\n                // The fallback children have pending work. Skip over the\n                // primary children and work on the fallback.\n                return child.sibling;\n              } else {\n                return null;\n              }\n            }\n          } else {\n            pushSuspenseContext(\n              workInProgress,\n              setDefaultShallowSuspenseContext(suspenseStackCursor.current),\n            );\n          }\n          break;\n        }\n        case SuspenseListComponent: {\n          const didSuspendBefore = (current.flags & DidCapture) !== NoFlags;\n\n          const hasChildWork = includesSomeLane(\n            renderLanes,\n            workInProgress.childLanes,\n          );\n\n          if (didSuspendBefore) {\n            if (hasChildWork) {\n              // If something was in fallback state last time, and we have all the\n              // same children then we're still in progressive loading state.\n              // Something might get unblocked by state updates or retries in the\n              // tree which will affect the tail. So we need to use the normal\n              // path to compute the correct tail.\n              return updateSuspenseListComponent(\n                current,\n                workInProgress,\n                renderLanes,\n              );\n            }\n            // If none of the children had any work, that means that none of\n            // them got retried so they'll still be blocked in the same way\n            // as before. We can fast bail out.\n            workInProgress.flags |= DidCapture;\n          }\n\n          // If nothing suspended before and we're rendering the same children,\n          // then the tail doesn't matter. Anything new that suspends will work\n          // in the \"together\" mode, so we can continue from the state we had.\n          const renderState = workInProgress.memoizedState;\n          if (renderState !== null) {\n            // Reset to the \"together\" mode in case we've started a different\n            // update in the past but didn't complete it.\n            renderState.rendering = null;\n            renderState.tail = null;\n          }\n          pushSuspenseContext(workInProgress, suspenseStackCursor.current);\n\n          if (hasChildWork) {\n            break;\n          } else {\n            // If none of the children had any work, that means that none of\n            // them got retried so they'll still be blocked in the same way\n            // as before. We can fast bail out.\n            return null;\n          }\n        }\n        case OffscreenComponent:\n        case LegacyHiddenComponent: {\n          // Need to check if the tree still needs to be deferred. This is\n          // almost identical to the logic used in the normal update path,\n          // so we'll just enter that. The only difference is we'll bail out\n          // at the next level instead of this one, because the child props\n          // have not changed. Which is fine.\n          // TODO: Probably should refactor `beginWork` to split the bailout\n          // path from the normal path. I'm tempted to do a labeled break here\n          // but I won't :)\n          workInProgress.lanes = NoLanes;\n          return updateOffscreenComponent(current, workInProgress, renderLanes);\n        }\n      }\n      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n    } else {\n      if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n        // This is a special case that only exists for legacy mode.\n        // See https://github.com/facebook/react/pull/19216.\n        didReceiveUpdate = true;\n      } else {\n        // An update was scheduled on this fiber, but there are no new props\n        // nor legacy context. Set this to false. If an update queue or context\n        // consumer produces a changed value, it will set this to true. Otherwise,\n        // the component will assume the children have not changed and bail out.\n        didReceiveUpdate = false;\n      }\n    }\n  } else {\n    didReceiveUpdate = false;\n  }\n\n  // Before entering the begin phase, clear pending update priority.\n  // TODO: This assumes that we're about to evaluate the component and process\n  // the update queue. However, there's an exception: SimpleMemoComponent\n  // sometimes bails out later in the begin phase. This indicates that we should\n  // move this assignment out of the common path and into each branch.\n  workInProgress.lanes = NoLanes;\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent: {\n      return mountIndeterminateComponent(\n        current,\n        workInProgress,\n        workInProgress.type,\n        renderLanes,\n      );\n    }\n    case LazyComponent: {\n      const elementType = workInProgress.elementType;\n      return mountLazyComponent(\n        current,\n        workInProgress,\n        elementType,\n        updateLanes,\n        renderLanes,\n      );\n    }\n    case FunctionComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      return updateFunctionComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderLanes,\n      );\n    }\n    case ClassComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      return updateClassComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderLanes,\n      );\n    }\n    case HostRoot:\n      return updateHostRoot(current, workInProgress, renderLanes);\n    case HostComponent:\n      return updateHostComponent(current, workInProgress, renderLanes);\n    case HostText:\n      return updateHostText(current, workInProgress);\n    case SuspenseComponent:\n      return updateSuspenseComponent(current, workInProgress, renderLanes);\n    case HostPortal:\n      return updatePortalComponent(current, workInProgress, renderLanes);\n    case ForwardRef: {\n      const type = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === type\n          ? unresolvedProps\n          : resolveDefaultProps(type, unresolvedProps);\n      return updateForwardRef(\n        current,\n        workInProgress,\n        type,\n        resolvedProps,\n        renderLanes,\n      );\n    }\n    case Fragment:\n      return updateFragment(current, workInProgress, renderLanes);\n    case Mode:\n      return updateMode(current, workInProgress, renderLanes);\n    case Profiler:\n      return updateProfiler(current, workInProgress, renderLanes);\n    case ContextProvider:\n      return updateContextProvider(current, workInProgress, renderLanes);\n    case ContextConsumer:\n      return updateContextConsumer(current, workInProgress, renderLanes);\n    case MemoComponent: {\n      const type = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      // Resolve outer props first, then resolve inner props.\n      let resolvedProps = resolveDefaultProps(type, unresolvedProps);\n      if (__DEV__) {\n        if (workInProgress.type !== workInProgress.elementType) {\n          const outerPropTypes = type.propTypes;\n          if (outerPropTypes) {\n            checkPropTypes(\n              outerPropTypes,\n              resolvedProps, // Resolved for outer only\n              'prop',\n              getComponentName(type),\n            );\n          }\n        }\n      }\n      resolvedProps = resolveDefaultProps(type.type, resolvedProps);\n      return updateMemoComponent(\n        current,\n        workInProgress,\n        type,\n        resolvedProps,\n        updateLanes,\n        renderLanes,\n      );\n    }\n    case SimpleMemoComponent: {\n      return updateSimpleMemoComponent(\n        current,\n        workInProgress,\n        workInProgress.type,\n        workInProgress.pendingProps,\n        updateLanes,\n        renderLanes,\n      );\n    }\n    case IncompleteClassComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      return mountIncompleteClassComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderLanes,\n      );\n    }\n    case SuspenseListComponent: {\n      return updateSuspenseListComponent(current, workInProgress, renderLanes);\n    }\n    case FundamentalComponent: {\n      if (enableFundamentalAPI) {\n        return updateFundamentalComponent(current, workInProgress, renderLanes);\n      }\n      break;\n    }\n    case ScopeComponent: {\n      if (enableScopeAPI) {\n        return updateScopeComponent(current, workInProgress, renderLanes);\n      }\n      break;\n    }\n    case Block: {\n      if (enableBlocksAPI) {\n        const block = workInProgress.type;\n        const props = workInProgress.pendingProps;\n        return updateBlock(current, workInProgress, block, props, renderLanes);\n      }\n      break;\n    }\n    case OffscreenComponent: {\n      return updateOffscreenComponent(current, workInProgress, renderLanes);\n    }\n    case LegacyHiddenComponent: {\n      return updateLegacyHiddenComponent(current, workInProgress, renderLanes);\n    }\n  }\n  invariant(\n    false,\n    'Unknown unit of work tag (%s). This error is likely caused by a bug in ' +\n      'React. Please file an issue.',\n    workInProgress.tag,\n  );\n}\n")])])]),t("h4",{attrs:{id:"reactfibercommitwork-js"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reactfibercommitwork-js"}},[e._v("#")]),e._v(" ReactFiberCommitWork.js")]),e._v(" "),t("p",[e._v("对不同的真实dom类型进行对应提交")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function commitWork(current: Fiber | null, finishedWork: Fiber): void {\n  if (!supportsMutation) {\n    switch (finishedWork.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case MemoComponent:\n      case SimpleMemoComponent:\n      case Block: {\n        // Layout effects are destroyed during the mutation phase so that all\n        // destroy functions for all fibers are called before any create functions.\n        // This prevents sibling component effects from interfering with each other,\n        // e.g. a destroy function in one component should never override a ref set\n        // by a create function in another component during the same commit.\n        if (\n          enableProfilerTimer &&\n          enableProfilerCommitHooks &&\n          finishedWork.mode & ProfileMode\n        ) {\n          try {\n            startLayoutEffectTimer();\n            commitHookEffectListUnmount(\n              HookLayout | HookHasEffect,\n              finishedWork,\n              finishedWork.return,\n            );\n          } finally {\n            recordLayoutEffectDuration(finishedWork);\n          }\n        } else {\n          commitHookEffectListUnmount(\n            HookLayout | HookHasEffect,\n            finishedWork,\n            finishedWork.return,\n          );\n        }\n        return;\n      }\n      case Profiler: {\n        return;\n      }\n      case SuspenseComponent: {\n        commitSuspenseComponent(finishedWork);\n        attachSuspenseRetryListeners(finishedWork);\n        return;\n      }\n      case SuspenseListComponent: {\n        attachSuspenseRetryListeners(finishedWork);\n        return;\n      }\n      case HostRoot: {\n        if (supportsHydration) {\n          const root: FiberRoot = finishedWork.stateNode;\n          if (root.hydrate) {\n            // We've just hydrated. No need to hydrate again.\n            root.hydrate = false;\n            commitHydratedContainer(root.containerInfo);\n          }\n        }\n        break;\n      }\n      case OffscreenComponent:\n      case LegacyHiddenComponent: {\n        return;\n      }\n    }\n\n    commitContainer(finishedWork);\n    return;\n  }\n\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent:\n    case Block: {\n      // Layout effects are destroyed during the mutation phase so that all\n      // destroy functions for all fibers are called before any create functions.\n      // This prevents sibling component effects from interfering with each other,\n      // e.g. a destroy function in one component should never override a ref set\n      // by a create function in another component during the same commit.\n      if (\n        enableProfilerTimer &&\n        enableProfilerCommitHooks &&\n        finishedWork.mode & ProfileMode\n      ) {\n        try {\n          startLayoutEffectTimer();\n          commitHookEffectListUnmount(\n            HookLayout | HookHasEffect,\n            finishedWork,\n            finishedWork.return,\n          );\n        } finally {\n          recordLayoutEffectDuration(finishedWork);\n        }\n      } else {\n        commitHookEffectListUnmount(\n          HookLayout | HookHasEffect,\n          finishedWork,\n          finishedWork.return,\n        );\n      }\n      return;\n    }\n    case ClassComponent: {\n      return;\n    }\n    case HostComponent: {\n      const instance: Instance = finishedWork.stateNode;\n      if (instance != null) {\n        // Commit the work prepared earlier.\n        const newProps = finishedWork.memoizedProps;\n        // For hydration we reuse the update path but we treat the oldProps\n        // as the newProps. The updatePayload will contain the real change in\n        // this case.\n        const oldProps = current !== null ? current.memoizedProps : newProps;\n        const type = finishedWork.type;\n        // TODO: Type the updateQueue to be specific to host components.\n        const updatePayload: null | UpdatePayload = (finishedWork.updateQueue: any);\n        finishedWork.updateQueue = null;\n        if (updatePayload !== null) {\n          commitUpdate(\n            instance,\n            updatePayload,\n            type,\n            oldProps,\n            newProps,\n            finishedWork,\n          );\n        }\n      }\n      return;\n    }\n    case HostText: {\n      invariant(\n        finishedWork.stateNode !== null,\n        'This should have a text node initialized. This error is likely ' +\n          'caused by a bug in React. Please file an issue.',\n      );\n      const textInstance: TextInstance = finishedWork.stateNode;\n      const newText: string = finishedWork.memoizedProps;\n      // For hydration we reuse the update path but we treat the oldProps\n      // as the newProps. The updatePayload will contain the real change in\n      // this case.\n      const oldText: string =\n        current !== null ? current.memoizedProps : newText;\n      commitTextUpdate(textInstance, oldText, newText);\n      return;\n    }\n    case HostRoot: {\n      if (supportsHydration) {\n        const root: FiberRoot = finishedWork.stateNode;\n        if (root.hydrate) {\n          // We've just hydrated. No need to hydrate again.\n          root.hydrate = false;\n          commitHydratedContainer(root.containerInfo);\n        }\n      }\n      return;\n    }\n    case Profiler: {\n      return;\n    }\n    case SuspenseComponent: {\n      commitSuspenseComponent(finishedWork);\n      attachSuspenseRetryListeners(finishedWork);\n      return;\n    }\n    case SuspenseListComponent: {\n      attachSuspenseRetryListeners(finishedWork);\n      return;\n    }\n    case IncompleteClassComponent: {\n      return;\n    }\n    case FundamentalComponent: {\n      if (enableFundamentalAPI) {\n        const fundamentalInstance = finishedWork.stateNode;\n        updateFundamentalComponent(fundamentalInstance);\n        return;\n      }\n      break;\n    }\n    case ScopeComponent: {\n      if (enableScopeAPI) {\n        const scopeInstance = finishedWork.stateNode;\n        prepareScopeUpdate(scopeInstance, finishedWork);\n        return;\n      }\n      break;\n    }\n    case OffscreenComponent:\n    case LegacyHiddenComponent: {\n      const newState: OffscreenState | null = finishedWork.memoizedState;\n      const isHidden = newState !== null;\n      hideOrUnhideAllChildren(finishedWork, isHidden);\n      return;\n    }\n  }\n  invariant(\n    false,\n    'This unit of work tag should not have side-effects. This error is ' +\n      'likely caused by a bug in React. Please file an issue.',\n  );\n}\n")])])]),t("h4",{attrs:{id:"reactfibercompletework-js"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reactfibercompletework-js"}},[e._v("#")]),e._v(" ReactFiberCompleteWork.js")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function completeWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n): Fiber | null {\n  const newProps = workInProgress.pendingProps;\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent:\n    case LazyComponent:\n    case SimpleMemoComponent:\n    case FunctionComponent:\n    case ForwardRef:\n    case Fragment:\n    case Mode:\n    case ContextConsumer:\n    case MemoComponent:\n      bubbleProperties(workInProgress);\n      return null;\n    case ClassComponent: {\n      const Component = workInProgress.type;\n      if (isLegacyContextProvider(Component)) {\n        popLegacyContext(workInProgress);\n      }\n      bubbleProperties(workInProgress);\n      return null;\n    }\n    case HostRoot: {\n      popHostContainer(workInProgress);\n      popTopLevelLegacyContextObject(workInProgress);\n      resetMutableSourceWorkInProgressVersions();\n      const fiberRoot = (workInProgress.stateNode: FiberRoot);\n      if (fiberRoot.pendingContext) {\n        fiberRoot.context = fiberRoot.pendingContext;\n        fiberRoot.pendingContext = null;\n      }\n      if (current === null || current.child === null) {\n        // If we hydrated, pop so that we can delete any remaining children\n        // that weren't hydrated.\n        const wasHydrated = popHydrationState(workInProgress);\n        if (wasHydrated) {\n          // If we hydrated, then we'll need to schedule an update for\n          // the commit side-effects on the root.\n          markUpdate(workInProgress);\n        } else if (!fiberRoot.hydrate) {\n          // Schedule an effect to clear this container at the start of the next commit.\n          // This handles the case of React rendering into a container with previous children.\n          // It's also safe to do for updates too, because current.child would only be null\n          // if the previous render was null (so the the container would already be empty).\n          workInProgress.flags |= Snapshot;\n        }\n      }\n      updateHostContainer(current, workInProgress);\n      bubbleProperties(workInProgress);\n      return null;\n    }\n    case HostComponent: {\n      popHostContext(workInProgress);\n      const rootContainerInstance = getRootHostContainer();\n      const type = workInProgress.type;\n      if (current !== null && workInProgress.stateNode != null) {\n        updateHostComponent(\n          current,\n          workInProgress,\n          type,\n          newProps,\n          rootContainerInstance,\n        );\n\n        if (current.ref !== workInProgress.ref) {\n          markRef(workInProgress);\n        }\n      } else {\n        if (!newProps) {\n          invariant(\n            workInProgress.stateNode !== null,\n            'We must have new props for new mounts. This error is likely ' +\n              'caused by a bug in React. Please file an issue.',\n          );\n          // This can happen when we abort work.\n          bubbleProperties(workInProgress);\n          return null;\n        }\n\n        const currentHostContext = getHostContext();\n        // TODO: Move createInstance to beginWork and keep it on a context\n        // \"stack\" as the parent. Then append children as we go in beginWork\n        // or completeWork depending on whether we want to add them top->down or\n        // bottom->up. Top->down is faster in IE11.\n        const wasHydrated = popHydrationState(workInProgress);\n        if (wasHydrated) {\n          // TODO: Move this and createInstance step into the beginPhase\n          // to consolidate.\n          if (\n            prepareToHydrateHostInstance(\n              workInProgress,\n              rootContainerInstance,\n              currentHostContext,\n            )\n          ) {\n            // If changes to the hydrated node need to be applied at the\n            // commit-phase we mark this as such.\n            markUpdate(workInProgress);\n          }\n        } else {\n          const instance = createInstance(\n            type,\n            newProps,\n            rootContainerInstance,\n            currentHostContext,\n            workInProgress,\n          );\n\n          appendAllChildren(instance, workInProgress, false, false);\n\n          workInProgress.stateNode = instance;\n\n          // Certain renderers require commit-time effects for initial mount.\n          // (eg DOM renderer supports auto-focus for certain elements).\n          // Make sure such renderers get scheduled for later work.\n          if (\n            finalizeInitialChildren(\n              instance,\n              type,\n              newProps,\n              rootContainerInstance,\n              currentHostContext,\n            )\n          ) {\n            markUpdate(workInProgress);\n          }\n        }\n\n        if (workInProgress.ref !== null) {\n          // If there is a ref on a host node we need to schedule a callback\n          markRef(workInProgress);\n        }\n      }\n      bubbleProperties(workInProgress);\n      return null;\n    }\n    case HostText: {\n      const newText = newProps;\n      if (current && workInProgress.stateNode != null) {\n        const oldText = current.memoizedProps;\n        // If we have an alternate, that means this is an update and we need\n        // to schedule a side-effect to do the updates.\n        updateHostText(current, workInProgress, oldText, newText);\n      } else {\n        if (typeof newText !== 'string') {\n          invariant(\n            workInProgress.stateNode !== null,\n            'We must have new props for new mounts. This error is likely ' +\n              'caused by a bug in React. Please file an issue.',\n          );\n          // This can happen when we abort work.\n        }\n        const rootContainerInstance = getRootHostContainer();\n        const currentHostContext = getHostContext();\n        const wasHydrated = popHydrationState(workInProgress);\n        if (wasHydrated) {\n          if (prepareToHydrateHostTextInstance(workInProgress)) {\n            markUpdate(workInProgress);\n          }\n        } else {\n          workInProgress.stateNode = createTextInstance(\n            newText,\n            rootContainerInstance,\n            currentHostContext,\n            workInProgress,\n          );\n        }\n      }\n      bubbleProperties(workInProgress);\n      return null;\n    }\n    case Profiler: {\n      const didBailout = bubbleProperties(workInProgress);\n      if (!didBailout) {\n        // Use subtreeFlags to determine which commit callbacks should fire.\n        // TODO: Move this logic to the commit phase, since we already check if\n        // a fiber's subtree contains effects. Refactor the commit phase's\n        // depth-first traversal so that we can put work tag-specific logic\n        // before or after committing a subtree's effects.\n        const OnRenderFlag = Update;\n        const OnCommitFlag = Callback;\n        const OnPostCommitFlag = Passive;\n        const subtreeFlags = workInProgress.subtreeFlags;\n        const flags = workInProgress.flags;\n        let newFlags = flags;\n\n        // Call onRender any time this fiber or its subtree are worked on.\n        if (\n          (flags & PerformedWork) !== NoFlags ||\n          (subtreeFlags & PerformedWork) !== NoFlags\n        ) {\n          newFlags |= OnRenderFlag;\n        }\n\n        // Call onCommit only if the subtree contains layout work, or if it\n        // contains deletions, since those might result in unmount work, which\n        // we include in the same measure.\n        // TODO: Can optimize by using a static flag to track whether a tree\n        // contains layout effects, like we do for passive effects.\n        if (\n          (flags & (LayoutMask | Deletion)) !== NoFlags ||\n          (subtreeFlags & (LayoutMask | Deletion)) !== NoFlags\n        ) {\n          newFlags |= OnCommitFlag;\n        }\n\n        // Call onPostCommit only if the subtree contains passive work.\n        // Don't have to check for deletions, because Deletion is already\n        // a passive flag.\n        if (\n          (flags & PassiveMask) !== NoFlags ||\n          (subtreeFlags & PassiveMask) !== NoFlags\n        ) {\n          newFlags |= OnPostCommitFlag;\n        }\n        workInProgress.flags = newFlags;\n      } else {\n        // This fiber and its subtree bailed out, so don't fire any callbacks.\n      }\n\n      return null;\n    }\n    case SuspenseComponent: {\n      popSuspenseContext(workInProgress);\n      const nextState: null | SuspenseState = workInProgress.memoizedState;\n\n      if (enableSuspenseServerRenderer) {\n        if (nextState !== null && nextState.dehydrated !== null) {\n          if (current === null) {\n            const wasHydrated = popHydrationState(workInProgress);\n            invariant(\n              wasHydrated,\n              'A dehydrated suspense component was completed without a hydrated node. ' +\n                'This is probably a bug in React.',\n            );\n            prepareToHydrateHostSuspenseInstance(workInProgress);\n            if (enableSchedulerTracing) {\n              markSpawnedWork(OffscreenLane);\n            }\n            bubbleProperties(workInProgress);\n            if (enableProfilerTimer) {\n              if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                const isTimedOutSuspense = nextState !== null;\n                if (isTimedOutSuspense) {\n                  // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n                  const primaryChildFragment = workInProgress.child;\n                  if (primaryChildFragment !== null) {\n                    // $FlowFixMe Flow doens't support type casting in combiation with the -= operator\n                    workInProgress.treeBaseDuration -= ((primaryChildFragment.treeBaseDuration: any): number);\n                  }\n                }\n              }\n            }\n            return null;\n          } else {\n            // We should never have been in a hydration state if we didn't have a current.\n            // However, in some of those paths, we might have reentered a hydration state\n            // and then we might be inside a hydration state. In that case, we'll need to exit out of it.\n            resetHydrationState();\n            if ((workInProgress.flags & DidCapture) === NoFlags) {\n              // This boundary did not suspend so it's now hydrated and unsuspended.\n              workInProgress.memoizedState = null;\n            }\n            // If nothing suspended, we need to schedule an effect to mark this boundary\n            // as having hydrated so events know that they're free to be invoked.\n            // It's also a signal to replay events and the suspense callback.\n            // If something suspended, schedule an effect to attach retry listeners.\n            // So we might as well always mark this.\n            workInProgress.flags |= Update;\n            bubbleProperties(workInProgress);\n            if (enableProfilerTimer) {\n              if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                const isTimedOutSuspense = nextState !== null;\n                if (isTimedOutSuspense) {\n                  // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n                  const primaryChildFragment = workInProgress.child;\n                  if (primaryChildFragment !== null) {\n                    // $FlowFixMe Flow doens't support type casting in combiation with the -= operator\n                    workInProgress.treeBaseDuration -= ((primaryChildFragment.treeBaseDuration: any): number);\n                  }\n                }\n              }\n            }\n            return null;\n          }\n        }\n      }\n\n      if ((workInProgress.flags & DidCapture) !== NoFlags) {\n        // Something suspended. Re-render with the fallback children.\n        workInProgress.lanes = renderLanes;\n        // Do not reset the effect list.\n        if (\n          enableProfilerTimer &&\n          (workInProgress.mode & ProfileMode) !== NoMode\n        ) {\n          transferActualDuration(workInProgress);\n        }\n        // Don't bubble properties in this case.\n        return workInProgress;\n      }\n\n      const nextDidTimeout = nextState !== null;\n      let prevDidTimeout = false;\n      if (current === null) {\n        if (workInProgress.memoizedProps.fallback !== undefined) {\n          popHydrationState(workInProgress);\n        }\n      } else {\n        const prevState: null | SuspenseState = current.memoizedState;\n        prevDidTimeout = prevState !== null;\n      }\n\n      if (nextDidTimeout && !prevDidTimeout) {\n        // If this subtreee is running in blocking mode we can suspend,\n        // otherwise we won't suspend.\n        // TODO: This will still suspend a synchronous tree if anything\n        // in the concurrent tree already suspended during this render.\n        // This is a known bug.\n        if ((workInProgress.mode & BlockingMode) !== NoMode) {\n          // TODO: Move this back to throwException because this is too late\n          // if this is a large tree which is common for initial loads. We\n          // don't know if we should restart a render or not until we get\n          // this marker, and this is too late.\n          // If this render already had a ping or lower pri updates,\n          // and this is the first time we know we're going to suspend we\n          // should be able to immediately restart from within throwException.\n          const hasInvisibleChildContext =\n            current === null &&\n            workInProgress.memoizedProps.unstable_avoidThisFallback !== true;\n          if (\n            hasInvisibleChildContext ||\n            hasSuspenseContext(\n              suspenseStackCursor.current,\n              (InvisibleParentSuspenseContext: SuspenseContext),\n            )\n          ) {\n            // If this was in an invisible tree or a new render, then showing\n            // this boundary is ok.\n            renderDidSuspend();\n          } else {\n            // Otherwise, we're going to have to hide content so we should\n            // suspend for longer if possible.\n            renderDidSuspendDelayIfPossible();\n          }\n        }\n      }\n\n      if (supportsPersistence) {\n        // TODO: Only schedule updates if not prevDidTimeout.\n        if (nextDidTimeout) {\n          // If this boundary just timed out, schedule an effect to attach a\n          // retry listener to the promise. This flag is also used to hide the\n          // primary children.\n          workInProgress.flags |= Update;\n        }\n      }\n      if (supportsMutation) {\n        // TODO: Only schedule updates if these values are non equal, i.e. it changed.\n        if (nextDidTimeout || prevDidTimeout) {\n          // If this boundary just timed out, schedule an effect to attach a\n          // retry listener to the promise. This flag is also used to hide the\n          // primary children. In mutation mode, we also need the flag to\n          // *unhide* children that were previously hidden, so check if this\n          // is currently timed out, too.\n          workInProgress.flags |= Update;\n        }\n      }\n      if (\n        enableSuspenseCallback &&\n        workInProgress.updateQueue !== null &&\n        workInProgress.memoizedProps.suspenseCallback != null\n      ) {\n        // Always notify the callback\n        workInProgress.flags |= Update;\n      }\n      bubbleProperties(workInProgress);\n      if (enableProfilerTimer) {\n        if ((workInProgress.mode & ProfileMode) !== NoMode) {\n          if (nextDidTimeout) {\n            // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n            const primaryChildFragment = workInProgress.child;\n            if (primaryChildFragment !== null) {\n              // $FlowFixMe Flow doens't support type casting in combiation with the -= operator\n              workInProgress.treeBaseDuration -= ((primaryChildFragment.treeBaseDuration: any): number);\n            }\n          }\n        }\n      }\n      return null;\n    }\n    case HostPortal:\n      popHostContainer(workInProgress);\n      updateHostContainer(current, workInProgress);\n      if (current === null) {\n        preparePortalMount(workInProgress.stateNode.containerInfo);\n      }\n      bubbleProperties(workInProgress);\n      return null;\n    case ContextProvider:\n      // Pop provider fiber\n      popProvider(workInProgress);\n      bubbleProperties(workInProgress);\n      return null;\n    case IncompleteClassComponent: {\n      // Same as class component case. I put it down here so that the tags are\n      // sequential to ensure this switch is compiled to a jump table.\n      const Component = workInProgress.type;\n      if (isLegacyContextProvider(Component)) {\n        popLegacyContext(workInProgress);\n      }\n      bubbleProperties(workInProgress);\n      return null;\n    }\n    case SuspenseListComponent: {\n      popSuspenseContext(workInProgress);\n\n      const renderState: null | SuspenseListRenderState =\n        workInProgress.memoizedState;\n\n      if (renderState === null) {\n        // We're running in the default, \"independent\" mode.\n        // We don't do anything in this mode.\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n      let didSuspendAlready = (workInProgress.flags & DidCapture) !== NoFlags;\n\n      const renderedTail = renderState.rendering;\n      if (renderedTail === null) {\n        // We just rendered the head.\n        if (!didSuspendAlready) {\n          // This is the first pass. We need to figure out if anything is still\n          // suspended in the rendered set.\n\n          // If new content unsuspended, but there's still some content that\n          // didn't. Then we need to do a second pass that forces everything\n          // to keep showing their fallbacks.\n\n          // We might be suspended if something in this render pass suspended, or\n          // something in the previous committed pass suspended. Otherwise,\n          // there's no chance so we can skip the expensive call to\n          // findFirstSuspended.\n          const cannotBeSuspended =\n            renderHasNotSuspendedYet() &&\n            (current === null || (current.flags & DidCapture) === NoFlags);\n          if (!cannotBeSuspended) {\n            let row = workInProgress.child;\n            while (row !== null) {\n              const suspended = findFirstSuspended(row);\n              if (suspended !== null) {\n                didSuspendAlready = true;\n                workInProgress.flags |= DidCapture;\n                cutOffTailIfNeeded(renderState, false);\n\n                // If this is a newly suspended tree, it might not get committed as\n                // part of the second pass. In that case nothing will subscribe to\n                // its thennables. Instead, we'll transfer its thennables to the\n                // SuspenseList so that it can retry if they resolve.\n                // There might be multiple of these in the list but since we're\n                // going to wait for all of them anyway, it doesn't really matter\n                // which ones gets to ping. In theory we could get clever and keep\n                // track of how many dependencies remain but it gets tricky because\n                // in the meantime, we can add/remove/change items and dependencies.\n                // We might bail out of the loop before finding any but that\n                // doesn't matter since that means that the other boundaries that\n                // we did find already has their listeners attached.\n                const newThennables = suspended.updateQueue;\n                if (newThennables !== null) {\n                  workInProgress.updateQueue = newThennables;\n                  workInProgress.flags |= Update;\n                }\n\n                // Rerender the whole list, but this time, we'll force fallbacks\n                // to stay in place.\n                // Reset the child fibers to their original state.\n                workInProgress.subtreeFlags = NoFlags;\n                resetChildFibers(workInProgress, renderLanes);\n\n                // Set up the Suspense Context to force suspense and immediately\n                // rerender the children.\n                pushSuspenseContext(\n                  workInProgress,\n                  setShallowSuspenseContext(\n                    suspenseStackCursor.current,\n                    ForceSuspenseFallback,\n                  ),\n                );\n                // Don't bubble properties in this case.\n                return workInProgress.child;\n              }\n              row = row.sibling;\n            }\n          }\n\n          if (renderState.tail !== null && now() > getRenderTargetTime()) {\n            // We have already passed our CPU deadline but we still have rows\n            // left in the tail. We'll just give up further attempts to render\n            // the main content and only render fallbacks.\n            workInProgress.flags |= DidCapture;\n            didSuspendAlready = true;\n\n            cutOffTailIfNeeded(renderState, false);\n\n            // Since nothing actually suspended, there will nothing to ping this\n            // to get it started back up to attempt the next item. While in terms\n            // of priority this work has the same priority as this current render,\n            // it's not part of the same transition once the transition has\n            // committed. If it's sync, we still want to yield so that it can be\n            // painted. Conceptually, this is really the same as pinging.\n            // We can use any RetryLane even if it's the one currently rendering\n            // since we're leaving it behind on this node.\n            workInProgress.lanes = SomeRetryLane;\n            if (enableSchedulerTracing) {\n              markSpawnedWork(SomeRetryLane);\n            }\n          }\n        } else {\n          cutOffTailIfNeeded(renderState, false);\n        }\n        // Next we're going to render the tail.\n      } else {\n        // Append the rendered row to the child list.\n        if (!didSuspendAlready) {\n          const suspended = findFirstSuspended(renderedTail);\n          if (suspended !== null) {\n            workInProgress.flags |= DidCapture;\n            didSuspendAlready = true;\n\n            // Ensure we transfer the update queue to the parent so that it doesn't\n            // get lost if this row ends up dropped during a second pass.\n            const newThennables = suspended.updateQueue;\n            if (newThennables !== null) {\n              workInProgress.updateQueue = newThennables;\n              workInProgress.flags |= Update;\n            }\n\n            cutOffTailIfNeeded(renderState, true);\n            // This might have been modified.\n            if (\n              renderState.tail === null &&\n              renderState.tailMode === 'hidden' &&\n              !renderedTail.alternate &&\n              !getIsHydrating() // We don't cut it if we're hydrating.\n            ) {\n              // We're done.\n              bubbleProperties(workInProgress);\n              return null;\n            }\n          } else if (\n            // The time it took to render last row is greater than the remaining\n            // time we have to render. So rendering one more row would likely\n            // exceed it.\n            now() * 2 - renderState.renderingStartTime >\n              getRenderTargetTime() &&\n            renderLanes !== OffscreenLane\n          ) {\n            // We have now passed our CPU deadline and we'll just give up further\n            // attempts to render the main content and only render fallbacks.\n            // The assumption is that this is usually faster.\n            workInProgress.flags |= DidCapture;\n            didSuspendAlready = true;\n\n            cutOffTailIfNeeded(renderState, false);\n\n            // Since nothing actually suspended, there will nothing to ping this\n            // to get it started back up to attempt the next item. If we can show\n            // them, then they really have the same priority as this render.\n            // So we'll pick it back up the very next render pass once we've had\n            // an opportunity to yield for paint.\n            workInProgress.lanes = SomeRetryLane;\n            if (enableSchedulerTracing) {\n              markSpawnedWork(SomeRetryLane);\n            }\n          }\n        }\n        if (renderState.isBackwards) {\n          // The effect list of the backwards tail will have been added\n          // to the end. This breaks the guarantee that life-cycles fire in\n          // sibling order but that isn't a strong guarantee promised by React.\n          // Especially since these might also just pop in during future commits.\n          // Append to the beginning of the list.\n          renderedTail.sibling = workInProgress.child;\n          workInProgress.child = renderedTail;\n        } else {\n          const previousSibling = renderState.last;\n          if (previousSibling !== null) {\n            previousSibling.sibling = renderedTail;\n          } else {\n            workInProgress.child = renderedTail;\n          }\n          renderState.last = renderedTail;\n        }\n      }\n\n      if (renderState.tail !== null) {\n        // We still have tail rows to render.\n        // Pop a row.\n        const next = renderState.tail;\n        renderState.rendering = next;\n        renderState.tail = next.sibling;\n        renderState.renderingStartTime = now();\n        next.sibling = null;\n\n        // Restore the context.\n        // TODO: We can probably just avoid popping it instead and only\n        // setting it the first time we go from not suspended to suspended.\n        let suspenseContext = suspenseStackCursor.current;\n        if (didSuspendAlready) {\n          suspenseContext = setShallowSuspenseContext(\n            suspenseContext,\n            ForceSuspenseFallback,\n          );\n        } else {\n          suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n        }\n        pushSuspenseContext(workInProgress, suspenseContext);\n        // Do a pass over the next row.\n        // Don't bubble properties in this case.\n        return next;\n      }\n      bubbleProperties(workInProgress);\n      return null;\n    }\n    case FundamentalComponent: {\n      if (enableFundamentalAPI) {\n        const fundamentalImpl = workInProgress.type.impl;\n        let fundamentalInstance: ReactFundamentalComponentInstance<\n          any,\n          any,\n        > | null = workInProgress.stateNode;\n\n        if (fundamentalInstance === null) {\n          const getInitialState = fundamentalImpl.getInitialState;\n          let fundamentalState;\n          if (getInitialState !== undefined) {\n            fundamentalState = getInitialState(newProps);\n          }\n          fundamentalInstance = workInProgress.stateNode = createFundamentalStateInstance(\n            workInProgress,\n            newProps,\n            fundamentalImpl,\n            fundamentalState || {},\n          );\n          const instance = ((getFundamentalComponentInstance(\n            fundamentalInstance,\n          ): any): Instance);\n          fundamentalInstance.instance = instance;\n          if (fundamentalImpl.reconcileChildren === false) {\n            bubbleProperties(workInProgress);\n            return null;\n          }\n          appendAllChildren(instance, workInProgress, false, false);\n          mountFundamentalComponent(fundamentalInstance);\n        } else {\n          // We fire update in commit phase\n          const prevProps = fundamentalInstance.props;\n          fundamentalInstance.prevProps = prevProps;\n          fundamentalInstance.props = newProps;\n          fundamentalInstance.currentFiber = workInProgress;\n          if (supportsPersistence) {\n            const instance = cloneFundamentalInstance(fundamentalInstance);\n            fundamentalInstance.instance = instance;\n            appendAllChildren(instance, workInProgress, false, false);\n          }\n          const shouldUpdate = shouldUpdateFundamentalComponent(\n            fundamentalInstance,\n          );\n          if (shouldUpdate) {\n            markUpdate(workInProgress);\n          }\n        }\n        bubbleProperties(workInProgress);\n        return null;\n      }\n      break;\n    }\n    case ScopeComponent: {\n      if (enableScopeAPI) {\n        if (current === null) {\n          const scopeInstance: ReactScopeInstance = createScopeInstance();\n          workInProgress.stateNode = scopeInstance;\n          prepareScopeUpdate(scopeInstance, workInProgress);\n          if (workInProgress.ref !== null) {\n            markRef(workInProgress);\n            markUpdate(workInProgress);\n          }\n        } else {\n          if (workInProgress.ref !== null) {\n            markUpdate(workInProgress);\n          }\n          if (current.ref !== workInProgress.ref) {\n            markRef(workInProgress);\n          }\n        }\n        bubbleProperties(workInProgress);\n        return null;\n      }\n      break;\n    }\n    case Block:\n      if (enableBlocksAPI) {\n        bubbleProperties(workInProgress);\n        return null;\n      }\n      break;\n    case OffscreenComponent:\n    case LegacyHiddenComponent: {\n      popRenderLanes(workInProgress);\n      const nextState: OffscreenState | null = workInProgress.memoizedState;\n      const nextIsHidden = nextState !== null;\n\n      if (current !== null) {\n        const prevState: OffscreenState | null = current.memoizedState;\n\n        const prevIsHidden = prevState !== null;\n        if (\n          prevIsHidden !== nextIsHidden &&\n          newProps.mode !== 'unstable-defer-without-hiding'\n        ) {\n          workInProgress.flags |= Update;\n        }\n      }\n\n      // Don't bubble properties for hidden children.\n      if (\n        !nextIsHidden ||\n        includesSomeLane(subtreeRenderLanes, (OffscreenLane: Lane)) ||\n        (workInProgress.mode & ConcurrentMode) === NoMode\n      ) {\n        bubbleProperties(workInProgress);\n      }\n\n      return null;\n    }\n  }\n  invariant(\n    false,\n    'Unknown unit of work tag (%s). This error is likely caused by a bug in ' +\n      'React. Please file an issue.',\n    workInProgress.tag,\n  );\n}\n")])])]),t("h2",{attrs:{id:"实践"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实践"}},[e._v("#")]),e._v(" 实践")]),e._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/react20210305/react04.png",alt:"图片"}})]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("import {useState} from 'react';\nfunction App() {\n  let [count, setCount] = useState(100);\n  \n  function add() {\n    setCount(count++)\n    console.log('add',count)\n  };\n\n  console.log('render',count);\n  \n  return (\n    <div>\n      <h1>{count}</h1>\n      <p>我是兄弟元素</p >\n      <button onClick={add}>点我+1</button>\n    </div>\n  );\n}\n\nexport default App;\n")])])]),t("p",[t("img",{attrs:{src:"/tech/front/react20210305/react05.png",alt:"图片"}})]),e._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/react20210305/react06.png",alt:"图片"}})]),e._v(" "),t("p",[e._v("通过一个cra的实践，看一下整过react的过程，如下：")]),e._v(" "),t("blockquote",[t("p",[e._v("createRootFiber => FiberRootNode => initialUpdateQueue => updateContainer => createUpdate => scheduleUpdateOnFiber =>  renderRootSync => workLoopSync => performUnitOfWork => beginWork => updateHostRoot => processUpdateQueue => reconcileChildFibers => reconcileSingleElement => createFiberFromElement => completeUnitWork => completeWork => createInstance => createElement => finalizeInitialChildren")])]),e._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),t("p",[e._v("react16之后通过fiber对整个运行时的stack reconciler进行了修改，实现了分片的协程调度，对于层级较深的js调用栈可以实现停止与启动更细粒度的控制，从而避免js线程的长时间占用而导致的渲染线程的卡死，整体的设计体现了react架构人员的计算机素养相当的扎实，对操作系统乃至整体数据结构把控能力之强，可见一斑，从这个层面上看，国外程序员设计者确实在优化性能等方面总是从计算机最底层的思路去着手，值得我们学习与思考。")]),e._v(" "),t("h2",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://github.com/facebook/react/",target:"_blank",rel:"noopener noreferrer"}},[e._v("react17官方源码"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/GYC4SulbnbnQV6TO01Qk_A",target:"_blank",rel:"noopener noreferrer"}},[e._v("结合 React 源码，五分钟带你掌握优先队列"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/gHPH7Q6HYWbbZ4B6A-yalg",target:"_blank",rel:"noopener noreferrer"}},[e._v("如何看待 React Server Components？（网易云音乐前端团队）"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/n3kbCed6zgvuE8GIhRHvuw",target:"_blank",rel:"noopener noreferrer"}},[e._v("漫谈 React Fiber"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/VBg7C-QaYAlcMDTlmysYnA",target:"_blank",rel:"noopener noreferrer"}},[e._v("React17新特性：启发式更新算法"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/K8FgJBzJDGhctDcQYJbEpg",target:"_blank",rel:"noopener noreferrer"}},[e._v("React Fiber 源码解析"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://kaiwu.lagou.com/course/courseInfo.htm?sid=&courseId=510&lagoufrom=noapp&sharetype=wx_friend&wxinfo=2",target:"_blank",rel:"noopener noreferrer"}},[e._v("深入浅出搞定 React"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://segmentfault.com/a/1190000020736966",target:"_blank",rel:"noopener noreferrer"}},[e._v("React16源码解析"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://segmentfault.com/a/1190000022606323",target:"_blank",rel:"noopener noreferrer"}},[e._v("彻底搞懂React源码调度原理（Concurrent模式）"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://www.dazhuanlan.com/2019/10/20/5dabc56a750fd/",target:"_blank",rel:"noopener noreferrer"}},[e._v("react中的requestIdleCallback实现"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://www.cnblogs.com/zhuanzhuanfe/p/9567081.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("浅谈React16框架 - Fiber"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/110161396",target:"_blank",rel:"noopener noreferrer"}},[e._v("react scheduler 再解析篇"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/48254036",target:"_blank",rel:"noopener noreferrer"}},[e._v("浅谈React Scheduler任务管理"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/74344654?utm_source=wechat_timeline",target:"_blank",rel:"noopener noreferrer"}},[e._v("探究 React Work Loop 原理"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/231326282?utm_source=wechat_session",target:"_blank",rel:"noopener noreferrer"}},[e._v("react17 lane 算法：位运算和素数相除"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://www.jianshu.com/p/858135ecb95c",target:"_blank",rel:"noopener noreferrer"}},[e._v("React 源码解析（V16.8.4）"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://www.jianshu.com/p/18523cdaf893",target:"_blank",rel:"noopener noreferrer"}},[e._v("react源码剖析"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://react.iamkasong.com",target:"_blank",rel:"noopener noreferrer"}},[e._v("React技术揭秘"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);n.default=s.exports}}]);
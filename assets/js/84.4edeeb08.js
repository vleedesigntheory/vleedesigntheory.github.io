(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{285:function(e,t,n){"use strict";n.r(t);var r=n(0),i=Object(r.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"nexttick在项目中的实践"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#nexttick在项目中的实践"}},[e._v("#")]),e._v(" nextTick在项目中的实践")]),e._v(" "),n("h2",{attrs:{id:"前言"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),n("p",[e._v("在项目中经常需要在视图层立即显示数据，而有时候由于异步数据传递的原因，在页面上并不会立即显示页面，这时候就需要使用Vue提供的nextTick这个方法，其主要原因是Vue的数据视图是异步更新的，用官方的解释就是：")]),e._v(" "),n("blockquote",[n("p",[e._v("Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。")])]),e._v(" "),n("p",[e._v("其中说到的事件循环也是前端面试中常问到的一个点，本文不做具体展开，有兴趣的同学可参考这篇文章 "),n("a",{attrs:{href:"https://juejin.im/post/5c3d8956e51d4511dc72c200?utm_source=wechat&from=timeline",target:"_blank",rel:"noopener noreferrer"}},[e._v("一次弄懂Event Loop（彻底解决此类面试问题）"),n("OutboundLink")],1)]),e._v(" "),n("p",[n("img",{attrs:{src:"/tech/front/tick20200625/tick01.png",alt:"图片"}})]),e._v(" "),n("h2",{attrs:{id:"踩坑目录"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#踩坑目录"}},[e._v("#")]),e._v(" 踩坑目录")]),e._v(" "),n("ul",[n("li",[e._v("模板案例数据在视图上显示")]),e._v(" "),n("li",[e._v("兄弟组件间异步数据传递")]),e._v(" "),n("li",[e._v("$nextTick源码实现解析")])]),e._v(" "),n("h2",{attrs:{id:"踩坑案例"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#踩坑案例"}},[e._v("#")]),e._v(" 踩坑案例")]),e._v(" "),n("h3",{attrs:{id:"模板案例数据在视图上显示"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#模板案例数据在视图上显示"}},[e._v("#")]),e._v(" 模板案例数据在视图上显示")]),e._v(" "),n("p",[n("img",{attrs:{src:"/tech/front/tick20200625/tick02.jpeg",alt:"图片"}})]),e._v(" "),n("p",[e._v("[bug描述] 页面上点击重置后将模板视图渲染会一个固定数据下的视图")]),e._v(" "),n("p",[e._v("[bug分析] 点击后需要立即显示在页面上，这是典型的nextTick需要应用的场景")]),e._v(" "),n("p",[e._v("[解决方案]")]),e._v(" "),n("p",[e._v("此处还有一个坑就是对于数组类型的监听是基于一个地址的，因而如果需要Vue的Watcher能够监视到就需要符合数组监听的那几种方法，这里直接新建，相当于每次的地址都会发生变化，因而可以监听到")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("    async resetTemplate() {\n      this.template = [];\n      await this.$nextTick(function() {\n          this.template = [\n          {\n            week: '1',\n            starttime: '00:00:00',\n            endtime: '00:00:00'\n          },\n          {\n            week: '2',\n            starttime: '00:00:00',\n            endtime: '00:00:00'\n          },\n          {\n            week: '3',\n            starttime: '00:00:00',\n            endtime: '00:00:00'\n          },\n          {\n            week: '4',\n            starttime: '00:00:00',\n            endtime: '00:00:00'\n          },\n          {\n            week: '5',\n            starttime: '00:00:00',\n            endtime: '00:00:00'\n          },\n          {\n            week: '6',\n            starttime: '00:00:00',\n            endtime: '00:00:00'\n          },\n          {\n            week: '7',\n            starttime: '00:00:00',\n            endtime: '00:00:00'\n          }\n        ];\n      });\n    }\n")])])]),n("h3",{attrs:{id:"兄弟组件间异步数据传递"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#兄弟组件间异步数据传递"}},[e._v("#")]),e._v(" 兄弟组件间异步数据传递")]),e._v(" "),n("p",[n("img",{attrs:{src:"/tech/front/tick20200625/tick03.jpeg",alt:"图片"}})]),e._v(" "),n("p",[e._v("[bug描述] 页面修改弹窗中的输入框字段需要复写进对应字段，利用Props传递数据进去后并不会直接修改数据")]),e._v(" "),n("p",[e._v("[bug分析] 此场景下数据是通过子组件emit给父组件，父组件获取数据后通过props传递给弹窗，在v-model中获取数据是异步的")]),e._v(" "),n("p",[e._v("[解决方案]")]),e._v(" "),n("p",[e._v("这是比较不常见的一种使用$nextTick去处理v-model异步数据传递的方法(ps: 关于emit/on的发布订阅相关的介绍，有兴趣的同学可以看一下这篇文章 "),n("a",{attrs:{href:"https://blog.csdn.net/qq_42778001/article/details/96692000",target:"_blank",rel:"noopener noreferrer"}},[e._v("vue发布订阅者模式$emit、$on"),n("OutboundLink")],1),e._v(")，利用的是父组件的数据延迟到下一个tick去给子组件传递，子组件在对应页面上及时渲染的方法，除了这种方法还有其他方法，具体可参考这篇文章 "),n("a",{attrs:{href:"https://www.cnblogs.com/goloving/p/9114389.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("详解vue父组件传递props异步数据到子组件的问题"),n("OutboundLink")],1)]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("    edit(data) {\n      this.isManu = true;\n      let [content,pos] = data;\n      this.manuPos = pos;\n      this.form = content;\n      this.$nextTick(function(){\n        this.$refs.deviceEdit.form.deviceid = content.deviceId;\n        this.$refs.deviceEdit.form.devicename = content.deviceName;\n        this.$refs.deviceEdit.form.devicebrand = content.deviceBrand;\n        this.$refs.deviceEdit.form.devicegroup = content.deviceGroup;\n        this.$refs.deviceEdit.form.mediatrans = content.mediaTrans;\n        this.$refs.deviceEdit.form.cloudstorage = content.cloudStorage;\n        this.$refs.deviceEdit.form.longitude = content.longitude;\n        this.$refs.deviceEdit.form.latitude = content.latitude;\n        this.$refs.deviceEdit.form.altitude = content.altitude;\n      })\n    },\n")])])]),n("h3",{attrs:{id:"nexttick源码实现解析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#nexttick源码实现解析"}},[e._v("#")]),e._v(" $nextTick源码实现解析")]),e._v(" "),n("p",[n("img",{attrs:{src:"/tech/front/tick20200625/tick04.png",alt:"图片"}})]),e._v(" "),n("p",[e._v("2.5之前的版本：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("/**\n * Defer a task to execute it asynchronously.\n */\nexport const nextTick = (function () {\n  const callbacks = []\n  let pending = false\n  let timerFunc\n\n  function nextTickHandler () {\n    pending = false\n    const copies = callbacks.slice(0)\n    callbacks.length = 0\n    for (let i = 0; i < copies.length; i++) {\n      copies[i]()\n    }\n  }\n\n  // the nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore if */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve()\n    var logError = err => { console.error(err) }\n    timerFunc = () => {\n      p.then(nextTickHandler).catch(logError)\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) setTimeout(noop)\n    }\n  } else if (!isIE && typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS, iOS7, Android 4.4\n    var counter = 1\n    var observer = new MutationObserver(nextTickHandler)\n    var textNode = document.createTextNode(String(counter))\n    observer.observe(textNode, {\n      characterData: true\n    })\n    timerFunc = () => {\n      counter = (counter + 1) % 2\n      textNode.data = String(counter)\n    }\n  } else {\n    // fallback to setTimeout\n    /* istanbul ignore next */\n    timerFunc = () => {\n      setTimeout(nextTickHandler, 0)\n    }\n  }\n\n  return function queueNextTick (cb?: Function, ctx?: Object) {\n    let _resolve\n    callbacks.push(() => {\n      if (cb) {\n        try {\n          cb.call(ctx)\n        } catch (e) {\n          handleError(e, ctx, 'nextTick')\n        }\n      } else if (_resolve) {\n        _resolve(ctx)\n      }\n    })\n    if (!pending) {\n      pending = true\n      timerFunc()\n    }\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise((resolve, reject) => {\n        _resolve = resolve\n      })\n    }\n  }\n})()\n")])])]),n("p",[n("img",{attrs:{src:"/tech/front/tick20200625/tick05.png",alt:"图片"}})]),e._v(" "),n("p",[e._v("2.5之后的版本")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("/* @flow */\n/* globals MutationObserver */\n\nimport { noop } from 'shared/util'\nimport { handleError } from './error'\nimport { isIE, isIOS, isNative } from './env'\n\nexport let isUsingMicroTask = false\n\nconst callbacks = []\nlet pending = false\n\nfunction flushCallbacks () {\n  pending = false\n  const copies = callbacks.slice(0)\n  callbacks.length = 0\n  for (let i = 0; i < copies.length; i++) {\n    copies[i]()\n  }\n}\n\n// Here we have async deferring wrappers using microtasks.\n// In 2.5 we used (macro) tasks (in combination with microtasks).\n// However, it has subtle problems when state is changed right before repaint\n// (e.g. #6813, out-in transitions).\n// Also, using (macro) tasks in event handler would cause some weird behaviors\n// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\n// So we now use microtasks everywhere, again.\n// A major drawback of this tradeoff is that there are some scenarios\n// where microtasks have too high a priority and fire in between supposedly\n// sequential events (e.g. #4521, #6690, which have workarounds)\n// or even between bubbling of the same event (#6566).\nlet timerFunc\n\n// The nextTick behavior leverages the microtask queue, which can be accessed\n// via either native Promise.then or MutationObserver.\n// MutationObserver has wider support, however it is seriously bugged in\n// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n// completely stops working after triggering a few times... so, if native\n// Promise is available, we will use it:\n/* istanbul ignore next, $flow-disable-line */\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  const p = Promise.resolve()\n  timerFunc = () => {\n    p.then(flushCallbacks)\n    // In problematic UIWebViews, Promise.then doesn't completely break, but\n    // it can get stuck in a weird state where callbacks are pushed into the\n    // microtask queue but the queue isn't being flushed, until the browser\n    // needs to do some other work, e.g. handle a timer. Therefore we can\n    // \"force\" the microtask queue to be flushed by adding an empty timer.\n    if (isIOS) setTimeout(noop)\n  }\n  isUsingMicroTask = true\n} else if (!isIE && typeof MutationObserver !== 'undefined' && (\n  isNative(MutationObserver) ||\n  // PhantomJS and iOS 7.x\n  MutationObserver.toString() === '[object MutationObserverConstructor]'\n)) {\n  // Use MutationObserver where native Promise is not available,\n  // e.g. PhantomJS, iOS7, Android 4.4\n  // (#6466 MutationObserver is unreliable in IE11)\n  let counter = 1\n  const observer = new MutationObserver(flushCallbacks)\n  const textNode = document.createTextNode(String(counter))\n  observer.observe(textNode, {\n    characterData: true\n  })\n  timerFunc = () => {\n    counter = (counter + 1) % 2\n    textNode.data = String(counter)\n  }\n  isUsingMicroTask = true\n} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  // Fallback to setImmediate.\n  // Technically it leverages the (macro) task queue,\n  // but it is still a better choice than setTimeout.\n  timerFunc = () => {\n    setImmediate(flushCallbacks)\n  }\n} else {\n  // Fallback to setTimeout.\n  timerFunc = () => {\n    setTimeout(flushCallbacks, 0)\n  }\n}\n\nexport function nextTick (cb?: Function, ctx?: Object) {\n  let _resolve\n  callbacks.push(() => {\n    if (cb) {\n      try {\n        cb.call(ctx)\n      } catch (e) {\n        handleError(e, ctx, 'nextTick')\n      }\n    } else if (_resolve) {\n      _resolve(ctx)\n    }\n  })\n  if (!pending) {\n    pending = true\n    timerFunc()\n  }\n  // $flow-disable-line\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(resolve => {\n      _resolve = resolve\n    })\n  }\n}\n")])])]),n("p",[e._v("不同版本主要在于timeFunc的异步函数使用优先顺序不同，2.5之后也有些许不同，但主要在于要不要暴露微任务函数和宏任务函数的问题(ps:上边的2.5之后的版本是2.6.11)")]),e._v(" "),n("blockquote",[n("p",[e._v("2.5之前版本： Promise => MutationObserver => setTimeout")])]),e._v(" "),n("blockquote",[n("p",[e._v("2.5之后版本： setImmediate => MessageChannel => Promise => setTimeout")])]),e._v(" "),n("h2",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),n("p",[n("img",{attrs:{src:"/tech/front/tick20200625/tick06.png",alt:"图片"}})]),e._v(" "),n("p",[e._v("js的异步执行机制是前端同学必须掌握的知识，其中nextTick就是其中一个很典型的代表，node中也有nextTick相关的方法，面试中也常常问到相关方法的实现，深刻理解js的基础方法和特性，对前端开发中避坑还是很有用处的，每每出现问题几乎在所有的面试题中都有相关知识的展现，打好基础永远是一个工程师上升的坚实的基础！")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let callbacks = []\nlet pending = false\n\nfunction nextTick (cb) {\n    callbacks.push(cb)\n\n    if (!pending) {\n        pending = true\n        setTimeout(flushCallback, 0)\n    }\n}\n\nfunction flushCallback () {\n    pending = false\n    let copies = callbacks.slice()\n    callbacks.length = 0\n    copies.forEach(copy => {\n        copy()\n    })\n}\n")])])]),n("h2",{attrs:{id:"参考"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"https://segmentfault.com/a/1190000012861862",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue.nextTick 的原理和用途"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://www.jianshu.com/p/a7550c0e164f",target:"_blank",rel:"noopener noreferrer"}},[e._v("简单理解Vue中的nextTick"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/83218117",target:"_blank",rel:"noopener noreferrer"}},[e._v("nextTick源码解析"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://juejin.im/post/5ae3f0956fb9a07ac90cf43e",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue nextTick 机制"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://juejin.im/post/5c03500e6fb9a049d37ed754?utm_source=gold_browser_extension",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue源码解析之nextTick"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://www.jianshu.com/p/8057f7c9950b",target:"_blank",rel:"noopener noreferrer"}},[e._v("浅析Node的nextTick"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://www.jianshu.com/p/ca7ddc76d24d",target:"_blank",rel:"noopener noreferrer"}},[e._v("Nodejs的nextTick和setTimeout"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://www.cnblogs.com/jin-zhe/p/9985436.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue.js中this.$nextTick()的使用"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://blog.csdn.net/qq_42778001/article/details/96692000",target:"_blank",rel:"noopener noreferrer"}},[e._v("vue发布订阅者模式$emit、$on"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://www.cnblogs.com/goloving/p/9114389.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("详解vue父组件传递props异步数据到子组件的问题"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://juejin.im/post/5c3d8956e51d4511dc72c200?utm_source=wechat&from=timeline",target:"_blank",rel:"noopener noreferrer"}},[e._v("一次弄懂Event Loop（彻底解决此类面试问题）"),n("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=i.exports}}]);
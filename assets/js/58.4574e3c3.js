(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{265:function(t,n,e){"use strict";e.r(n);var s=e(0),r=Object(s.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"可视化图布局算法浅析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#可视化图布局算法浅析"}},[t._v("#")]),t._v(" 可视化图布局算法浅析")]),t._v(" "),e("h2",{attrs:{id:"前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),e("p",[t._v("图算法在前端领域考察的较少，一般除非是要写框架或者打包工具对依赖关系处理（DAG）会用到，前端对图算法的考察一般是比较少的，而对于可视化领域而言，图又是必不可少的一种展示方式，其中对于边和节点的展示布局方案结合美学效果会有不同的算法实现，本文旨在介绍一些常见的通用布局算法，其中的每个小的布局方案也会有不同的分支实现")]),t._v(" "),e("h2",{attrs:{id:"分类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分类"}},[t._v("#")]),t._v(" 分类")]),t._v(" "),e("p",[e("img",{attrs:{src:"/tech/front/graph20210419/graph.png",alt:"图片"}})]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"left"}},[t._v("简写")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("算法名称")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("分类")]),t._v(" "),e("th",{staticStyle:{"text-align":"right"}},[t._v("备注")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("grid")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("网格布局算法")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("几何布局")]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[e("img",{attrs:{src:"/tech/front/graph20210419/grid.png",alt:"图片"}})])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("circle")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("环形布局算法")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("几何布局")]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[e("img",{attrs:{src:"/tech/front/graph20210419/circle.png",alt:"图片"}})])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("concentric")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("同心圆布局算法")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("几何布局")]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[e("img",{attrs:{src:"/tech/front/graph20210419/concentric.png",alt:"图片"}})])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("radial")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("辐射状布局算法")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("几何布局")]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[e("img",{attrs:{src:"/tech/front/graph20210419/radial.png",alt:"图片"}})])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("avsdf")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("邻接点最小度优先算法（Adjacent Vertex with Smallest Degree First）")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("几何布局")]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[e("img",{attrs:{src:"/tech/front/graph20210419/avsdf.png",alt:"图片"}})])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("dagre")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("有向无环图树布局算法（Directed Acyclic Graph and Trees）")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("层级布局")]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[e("img",{attrs:{src:"/tech/front/graph20210419/dagre.png",alt:"图片"}})])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("breadthfirst")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("广度优先布局算法")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("层级布局")]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[e("img",{attrs:{src:"/tech/front/graph20210419/breadthfirst.png",alt:"图片"}})])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("elk")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("Eclipse布局算法（Eclipse Layout Kernel）")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("层级布局")]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[e("img",{attrs:{src:"/tech/front/graph20210419/elk.png",alt:"图片"}})])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("klay")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("K层布局算法（K Lay）")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("层级布局")]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[e("img",{attrs:{src:"/tech/front/graph20210419/klay.png",alt:"图片"}})])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("fcose")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("最快复合弹簧内置布局算法（Fast Compound Spring Embedder）")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("力导布局")]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[e("img",{attrs:{src:"/tech/front/graph20210419/fcose.png",alt:"图片"}})])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("cola")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("约束布局（Constraint-based Layout）")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("力导布局")]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[e("img",{attrs:{src:"/tech/front/graph20210419/cola.png",alt:"图片"}})])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("cise")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("环形弹簧内置布局算法（Circular Spring Embedder）")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("力导布局")]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[e("img",{attrs:{src:"/tech/front/graph20210419/cise.png",alt:"图片"}})])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("elk2")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("Eclipse布局算法（Eclipse Layout Kernel）")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("力导布局")]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[e("img",{attrs:{src:"/tech/front/graph20210419/elk2.png",alt:"图片"}})])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("euler")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("欧拉布局算法")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("力导布局")]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[e("img",{attrs:{src:"/tech/front/graph20210419/euler.png",alt:"图片"}})])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("spread")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("扩展布局算法")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("力导布局")]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[e("img",{attrs:{src:"/tech/front/graph20210419/spread.png",alt:"图片"}})])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("fruchterman")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("Fruchterman-Reingold布局算法")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("力导布局")]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[e("img",{attrs:{src:"/tech/front/graph20210419/fruchterman.png",alt:"图片"}})])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("combo")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("混合布局算法")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("力导布局")]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[e("img",{attrs:{src:"/tech/front/graph20210419/combo.png",alt:"图片"}})])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("mds")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("高维数据降维布局算法（Multi Dimensional Scaling）")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("其他布局算法")]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[e("img",{attrs:{src:"/tech/front/graph20210419/mds.png",alt:"图片"}})])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("random")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("随机布局算法")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("其他布局")]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[e("img",{attrs:{src:"/tech/front/graph20210419/random.png",alt:"图片"}})])])])]),t._v(" "),e("h2",{attrs:{id:"常见算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常见算法"}},[t._v("#")]),t._v(" 常见算法")]),t._v(" "),e("h3",{attrs:{id:"fruchterman-reingold布局算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fruchterman-reingold布局算法"}},[t._v("#")]),t._v(" Fruchterman-Reingold布局算法")]),t._v(" "),e("p",[e("img",{attrs:{src:"/tech/front/graph20210419/energy.png",alt:"图片"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/tech/front/graph20210419/sa.png",alt:"图片"}})]),t._v(" "),e("p",[t._v("Fruchterman-Reingold算法属于力导布局的一种，其本质是将之前Eades的布点算法中的基于胡克定律模型进行了改进，使用了库伦斥力并且聚焦在最近相邻节点之间的能量模型，利用模拟退火等优化策略，结合美学标准对整体进行减少线交叉及整体均匀布局，其伪码描述如下图：")]),t._v(" "),e("p",[e("img",{attrs:{src:"/tech/front/graph20210419/pseudo.png",alt:"图片"}})]),t._v(" "),e("p",[t._v("对于更加细节的关于FR算法的推到，可以参看这篇论文"),e("a",{attrs:{href:"http://www.mathe2.uni-bayreuth.de/axel/papers/reingold:graph_drawing_by_force_directed_placement.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("Graph Drawing by Force-directed Placement"),e("OutboundLink")],1),t._v("；接下来，我们来看一下前端可视化领域的一些具体实现，我们结合Antv G6中的源码看一下实现思路：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('/**\n* Antv的layout是专门发布了一个npm包 源码地址：https://github.com/antvis/layout\n* FR算法目录位置 https://github.com/antvis/layout/blob/master/src/layout/fruchterman.ts\n*/\n\n\nimport {\n  OutNode,\n  Edge,\n  PointTuple,\n  IndexMap,\n  Point,\n  FruchtermanLayoutOptions\n} from "./types";\nimport { Base } from "./base";\nimport { isNumber } from "../util";\n\ntype NodeMap = {\n  [key: string]: INode;\n};\n\ntype INode = OutNode & {\n  cluster: string;\n};\n\nconst SPEED_DIVISOR = 800;\n\n/**\n * fruchterman 布局\n */\nexport class FruchtermanLayout extends Base {\n  /** 布局中心 */\n  public center: PointTuple;\n\n  /** 停止迭代的最大迭代数 */\n  public maxIteration: number = 1000;\n\n  /** 重力大小，影响图的紧凑程度 */\n  public gravity: number = 10;\n\n  /** 速度 */\n  public speed: number = 1;\n\n  /** 是否产生聚类力 */\n  public clustering: boolean = false;\n\n  /** 聚类力大小 */\n  public clusterGravity: number = 10;\n\n  public nodes: INode[] = [];\n\n  public edges: Edge[] = [];\n\n  public width: number = 300;\n\n  public height: number = 300;\n\n  public nodeMap: NodeMap = {};\n\n  public nodeIdxMap: IndexMap = {};\n\n  /** 迭代结束的回调函数 */\n  public onLayoutEnd: () => void = () => {};\n\n  constructor(options?: FruchtermanLayoutOptions) {\n    super();\n    this.updateCfg(options);\n  }\n\n  public getDefaultCfg() {\n    return {\n      maxIteration: 1000,\n      gravity: 10,\n      speed: 1,\n      clustering: false,\n      clusterGravity: 10\n    };\n  }\n\n  /**\n   * 执行布局\n   */\n  public execute() {\n    const self = this;\n    const nodes = self.nodes;\n\n    if (!nodes || nodes.length === 0) {\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n\n    if (!self.width && typeof window !== "undefined") {\n      self.width = window.innerWidth;\n    }\n    if (!self.height && typeof window !== "undefined") {\n      self.height = window.innerHeight;\n    }\n    if (!self.center) {\n      self.center = [self.width / 2, self.height / 2];\n    }\n    const center = self.center;\n\n    if (nodes.length === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n    const nodeMap: NodeMap = {};\n    const nodeIdxMap: IndexMap = {};\n    nodes.forEach((node, i) => {\n      if (!isNumber(node.x)) node.x = Math.random() * this.width;\n      if (!isNumber(node.y)) node.y = Math.random() * this.height;\n      nodeMap[node.id] = node;\n      nodeIdxMap[node.id] = i;\n    });\n    self.nodeMap = nodeMap;\n    self.nodeIdxMap = nodeIdxMap;\n    // layout\n    return self.run();\n  }\n\n  public run() {\n    const self = this;\n    const nodes = self.nodes;\n    const edges = self.edges;\n    const maxIteration = self.maxIteration;\n    const center = self.center;\n    const area = self.height * self.width;\n    const maxDisplace = Math.sqrt(area) / 10;\n    const k2 = area / (nodes.length + 1);\n    const k = Math.sqrt(k2);\n    const gravity = self.gravity;\n    const speed = self.speed;\n    const clustering = self.clustering;\n    const clusterMap: {\n      [key: string]: {\n        name: string | number;\n        cx: number;\n        cy: number;\n        count: number;\n      };\n    } = {};\n    if (clustering) {\n      nodes.forEach(n => {\n        if (clusterMap[n.cluster] === undefined) {\n          const cluster = {\n            name: n.cluster,\n            cx: 0,\n            cy: 0,\n            count: 0\n          };\n          clusterMap[n.cluster] = cluster;\n        }\n        const c = clusterMap[n.cluster];\n        if (isNumber(n.x)) {\n          c.cx += n.x;\n        }\n        if (isNumber(n.y)) {\n          c.cy += n.y;\n        }\n        c.count++;\n      });\n      for (const key in clusterMap) {\n        clusterMap[key].cx /= clusterMap[key].count;\n        clusterMap[key].cy /= clusterMap[key].count;\n      }\n    }\n    for (let i = 0; i < maxIteration; i++) {\n      const displacements: Point[] = [];\n      nodes.forEach((_, j) => {\n        displacements[j] = { x: 0, y: 0 };\n      });\n      self.applyCalculate(nodes, edges, displacements, k, k2);\n\n      // gravity for clusters\n      if (clustering) {\n        const clusterGravity = self.clusterGravity || gravity;\n        nodes.forEach((n, j) => {\n          if (!isNumber(n.x) || !isNumber(n.y)) return;\n          const c = clusterMap[n.cluster];\n          const distLength = Math.sqrt(\n            (n.x - c.cx) * (n.x - c.cx) + (n.y - c.cy) * (n.y - c.cy)\n          );\n          const gravityForce = k * clusterGravity;\n          displacements[j].x -= (gravityForce * (n.x - c.cx)) / distLength;\n          displacements[j].y -= (gravityForce * (n.y - c.cy)) / distLength;\n        });\n\n        for (const key in clusterMap) {\n          clusterMap[key].cx = 0;\n          clusterMap[key].cy = 0;\n          clusterMap[key].count = 0;\n        }\n\n        nodes.forEach(n => {\n          const c = clusterMap[n.cluster];\n          if (isNumber(n.x)) {\n            c.cx += n.x;\n          }\n          if (isNumber(n.y)) {\n            c.cy += n.y;\n          }\n          c.count++;\n        });\n        for (const key in clusterMap) {\n          clusterMap[key].cx /= clusterMap[key].count;\n          clusterMap[key].cy /= clusterMap[key].count;\n        }\n      }\n\n      // gravity\n      nodes.forEach((n, j) => {\n        if (!isNumber(n.x) || !isNumber(n.y)) return;\n        const gravityForce = 0.01 * k * gravity;\n        displacements[j].x -= gravityForce * (n.x - center[0]);\n        displacements[j].y -= gravityForce * (n.y - center[1]);\n      });\n\n      // move\n      nodes.forEach((n, j) => {\n        if (!isNumber(n.x) || !isNumber(n.y)) return;\n        const distLength = Math.sqrt(\n          displacements[j].x * displacements[j].x +\n            displacements[j].y * displacements[j].y\n        );\n        if (distLength > 0) {\n          // && !n.isFixed()\n          const limitedDist = Math.min(\n            maxDisplace * (speed / SPEED_DIVISOR),\n            distLength\n          );\n          n.x += (displacements[j].x / distLength) * limitedDist;\n          n.y += (displacements[j].y / distLength) * limitedDist;\n        }\n      });\n    }\n\n    if (self.onLayoutEnd) self.onLayoutEnd();\n\n    return {\n      nodes,\n      edges\n    };\n  }\n\n  private applyCalculate(\n    nodes: INode[],\n    edges: Edge[],\n    displacements: Point[],\n    k: number,\n    k2: number\n  ) {\n    const self = this;\n    self.calRepulsive(nodes, displacements, k2);\n    self.calAttractive(edges, displacements, k);\n  }\n\n  // 计算斥力\n  private calRepulsive(nodes: INode[], displacements: Point[], k2: number) {\n    nodes.forEach((v, i) => {\n      displacements[i] = { x: 0, y: 0 };\n      nodes.forEach((u, j) => {\n        if (i === j) {\n          return;\n        }\n        if (\n          !isNumber(v.x) ||\n          !isNumber(u.x) ||\n          !isNumber(v.y) ||\n          !isNumber(u.y)\n        )\n          return;\n        let vecX = v.x - u.x;\n        let vecY = v.y - u.y;\n        let vecLengthSqr = vecX * vecX + vecY * vecY;\n        if (vecLengthSqr === 0) {\n          vecLengthSqr = 1;\n          const sign = i > j ? 1 : -1;\n          vecX = 0.01 * sign;\n          vecY = 0.01 * sign;\n        }\n        // 核心计算项 C常数值\n        const common = k2 / vecLengthSqr;\n        displacements[i].x += vecX * common;\n        displacements[i].y += vecY * common;\n      });\n    });\n  }\n\n  // 计算引力\n  private calAttractive(edges: Edge[], displacements: Point[], k: number) {\n    edges.forEach(e => {\n      if (!e.source || !e.target) return;\n      const uIndex = this.nodeIdxMap[e.source];\n      const vIndex = this.nodeIdxMap[e.target];\n      if (uIndex === vIndex) {\n        return;\n      }\n      const u = this.nodeMap[e.source];\n      const v = this.nodeMap[e.target];\n      if (!isNumber(v.x) || !isNumber(u.x) || !isNumber(v.y) || !isNumber(u.y))\n        return;\n      const vecX = v.x - u.x;\n      const vecY = v.y - u.y;\n      const vecLength = Math.sqrt(vecX * vecX + vecY * vecY);\n      const common = (vecLength * vecLength) / k;\n      displacements[vIndex].x -= (vecX / vecLength) * common;\n      displacements[vIndex].y -= (vecY / vecLength) * common;\n      displacements[uIndex].x += (vecX / vecLength) * common;\n      displacements[uIndex].y += (vecY / vecLength) * common;\n    });\n  }\n\n  public getType() {\n    return "fruchterman";\n  }\n}\n')])])]),e("h3",{attrs:{id:"grid布局算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#grid布局算法"}},[t._v("#")]),t._v(" Grid布局算法")]),t._v(" "),e("p",[t._v("在dom中布局，我们最常想到的就是网格布局，在最早的没有div的时代，都是通过table进行布局的，这里图的布局也是最容易想到的一种布局方式，虽然简单，但我们也可以看一下对应的实现思路，我们看一下在Cytoscape中的实现方案：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// grid布局目录位置 https://github.com/cytoscape/cytoscape.js/blob/unstable/src/extensions/layout/grid.js\n\nfunction GridLayout( options ){\n  this.options = util.extend( {}, defaults, options );\n}\n\nGridLayout.prototype.run = function(){\n  let params = this.options;\n  let options = params;\n\n  let cy = params.cy;\n  let eles = options.eles;\n  let nodes = eles.nodes().not( ':parent' );\n\n  if( options.sort ){\n    nodes = nodes.sort( options.sort );\n  }\n\n  let bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n    x1: 0, y1: 0, w: cy.width(), h: cy.height()\n  } );\n\n  if( bb.h === 0 || bb.w === 0 ){\n    eles.nodes().layoutPositions( this, options, function( ele ){\n      return { x: bb.x1, y: bb.y1 };\n    } );\n\n  } else {\n\n    // width/height * splits^2 = cells where splits is number of times to split width\n    let cells = nodes.size();\n    let splits = Math.sqrt( cells * bb.h / bb.w );\n    let rows = Math.round( splits );\n    let cols = Math.round( bb.w / bb.h * splits );\n\n    let small = function( val ){\n      if( val == null ){\n        return Math.min( rows, cols );\n      } else {\n        let min = Math.min( rows, cols );\n        if( min == rows ){\n          rows = val;\n        } else {\n          cols = val;\n        }\n      }\n    };\n\n    let large = function( val ){\n      if( val == null ){\n        return Math.max( rows, cols );\n      } else {\n        let max = Math.max( rows, cols );\n        if( max == rows ){\n          rows = val;\n        } else {\n          cols = val;\n        }\n      }\n    };\n\n    let oRows = options.rows;\n    let oCols = options.cols != null ? options.cols : options.columns;\n\n    // if rows or columns were set in options, use those values\n    if( oRows != null && oCols != null ){\n      rows = oRows;\n      cols = oCols;\n    } else if( oRows != null && oCols == null ){\n      rows = oRows;\n      cols = Math.ceil( cells / rows );\n    } else if( oRows == null && oCols != null ){\n      cols = oCols;\n      rows = Math.ceil( cells / cols );\n    }\n\n    // otherwise use the automatic values and adjust accordingly\n\n    // if rounding was up, see if we can reduce rows or columns\n    else if( cols * rows > cells ){\n      let sm = small();\n      let lg = large();\n\n      // reducing the small side takes away the most cells, so try it first\n      if( (sm - 1) * lg >= cells ){\n        small( sm - 1 );\n      } else if( (lg - 1) * sm >= cells ){\n        large( lg - 1 );\n      }\n    } else {\n\n      // if rounding was too low, add rows or columns\n      while( cols * rows < cells ){\n        let sm = small();\n        let lg = large();\n\n        // try to add to larger side first (adds less in multiplication)\n        if( (lg + 1) * sm >= cells ){\n          large( lg + 1 );\n        } else {\n          small( sm + 1 );\n        }\n      }\n    }\n\n    let cellWidth = bb.w / cols;\n    let cellHeight = bb.h / rows;\n\n    if( options.condense ){\n      cellWidth = 0;\n      cellHeight = 0;\n    }\n\n    if( options.avoidOverlap ){\n      for( let i = 0; i < nodes.length; i++ ){\n        let node = nodes[ i ];\n        let pos = node._private.position;\n\n        if( pos.x == null || pos.y == null ){ // for bb\n          pos.x = 0;\n          pos.y = 0;\n        }\n\n        let nbb = node.layoutDimensions( options );\n        let p = options.avoidOverlapPadding;\n\n        let w = nbb.w + p;\n        let h = nbb.h + p;\n\n        cellWidth = Math.max( cellWidth, w );\n        cellHeight = Math.max( cellHeight, h );\n      }\n    }\n\n    let cellUsed = {}; // e.g. 'c-0-2' => true\n\n    let used = function( row, col ){\n      return cellUsed[ 'c-' + row + '-' + col ] ? true : false;\n    };\n\n    let use = function( row, col ){\n      cellUsed[ 'c-' + row + '-' + col ] = true;\n    };\n\n    // to keep track of current cell position\n    let row = 0;\n    let col = 0;\n    let moveToNextCell = function(){\n      col++;\n      if( col >= cols ){\n        col = 0;\n        row++;\n      }\n    };\n\n    // get a cache of all the manual positions\n    let id2manPos = {};\n    for( let i = 0; i < nodes.length; i++ ){\n      let node = nodes[ i ];\n      let rcPos = options.position( node );\n\n      if( rcPos && (rcPos.row !== undefined || rcPos.col !== undefined) ){ // must have at least row or col def'd\n        let pos = {\n          row: rcPos.row,\n          col: rcPos.col\n        };\n\n        if( pos.col === undefined ){ // find unused col\n          pos.col = 0;\n\n          while( used( pos.row, pos.col ) ){\n            pos.col++;\n          }\n        } else if( pos.row === undefined ){ // find unused row\n          pos.row = 0;\n\n          while( used( pos.row, pos.col ) ){\n            pos.row++;\n          }\n        }\n\n        id2manPos[ node.id() ] = pos;\n        use( pos.row, pos.col );\n      }\n    }\n\n    let getPos = function( element, i ){\n      let x, y;\n\n      if( element.locked() || element.isParent() ){\n        return false;\n      }\n\n      // see if we have a manual position set\n      let rcPos = id2manPos[ element.id() ];\n      if( rcPos ){\n        x = rcPos.col * cellWidth + cellWidth / 2 + bb.x1;\n        y = rcPos.row * cellHeight + cellHeight / 2 + bb.y1;\n\n      } else { // otherwise set automatically\n\n        while( used( row, col ) ){\n          moveToNextCell();\n        }\n\n        x = col * cellWidth + cellWidth / 2 + bb.x1;\n        y = row * cellHeight + cellHeight / 2 + bb.y1;\n        use( row, col );\n\n        moveToNextCell();\n      }\n\n      return { x: x, y: y };\n\n    };\n\n    nodes.layoutPositions( this, options, getPos );\n  }\n\n  return this; // chaining\n\n};\n\nexport default GridLayout;\n")])])]),e("h3",{attrs:{id:"mds算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mds算法"}},[t._v("#")]),t._v(" MDS算法")]),t._v(" "),e("p",[e("img",{attrs:{src:"/tech/front/graph20210419/stress.png",alt:"图片"}})]),t._v(" "),e("p",[t._v("MDS是Multidimensional Scaling的简称，即为高维数据降维算法，其是一种力导算法高维数据下的稳定下布局的优化，避免数据超载而导致的整体的布局不稳定，上图中方程式经过数学推导化简后（ps：对于具体推导感兴趣的同学可以看这篇文章"),e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/317840611",target:"_blank",rel:"noopener noreferrer"}},[t._v("图布局算法之Stress Majorization"),e("OutboundLink")],1),t._v("），其伪码描述如下：")]),t._v(" "),e("p",[e("img",{attrs:{src:"/tech/front/graph20210419/conjugate.png",alt:"图片"}})]),t._v(" "),e("p",[t._v("接下来，我们来看一下前端的具体实现，来看一下Antv G6中的实现方案：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('/**\n* Antv的layout是专门发布了一个npm包 源码地址：https://github.com/antvis/layout\n* MDS算法目录位置 https://github.com/antvis/layout/blob/master/src/layout/mds.ts\n*/\n\n// ml-matrix是机器学习相关的一些矩阵操作\nimport { Matrix as MLMatrix, SingularValueDecomposition } from "ml-matrix";\nimport { PointTuple, OutNode, Edge, Matrix, MDSLayoutOptions } from "./types";\nimport { floydWarshall, getAdjMatrix, scaleMatrix } from "../util";\nimport { Base } from "./base";\n\n/**\n * mds 布局\n */\nexport class MDSLayout extends Base {\n  /** 布局中心 */\n  public center: PointTuple = [0, 0];\n\n  /** 边长度 */\n  public linkDistance: number = 50;\n\n  private scaledDistances: Matrix[];\n\n  public nodes: OutNode[] = [];\n\n  public edges: Edge[] = [];\n\n  /** 迭代结束的回调函数 */\n  public onLayoutEnd: () => void = () => {};\n\n  constructor(options?: MDSLayoutOptions) {\n    super();\n    this.updateCfg(options);\n  }\n\n  public getDefaultCfg() {\n    return {\n      center: [0, 0],\n      linkDistance: 50\n    };\n  }\n\n  /**\n   * 执行布局\n   */\n  public execute() {\n    const self = this;\n    const { nodes, edges = [] } = self;\n    const center = self.center;\n    if (!nodes || nodes.length === 0) {\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n    if (nodes.length === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n    const linkDistance = self.linkDistance;\n    // the graph-theoretic distance (shortest path distance) matrix\n    const adjMatrix = getAdjMatrix({ nodes, edges }, false);\n    const distances = floydWarshall(adjMatrix);\n    self.handleInfinity(distances);\n\n    // scale the ideal edge length acoording to linkDistance\n    const scaledD = scaleMatrix(distances, linkDistance);\n    self.scaledDistances = scaledD;\n\n    // get positions by MDS\n    const positions = self.runMDS();\n    self.positions = positions;\n    positions.forEach((p: number[], i: number) => {\n      nodes[i].x = p[0] + center[0];\n      nodes[i].y = p[1] + center[1];\n    });\n\n    if (self.onLayoutEnd) self.onLayoutEnd();\n\n    return {\n      nodes,\n      edges\n    };\n  }\n\n  /**\n   * mds 算法\n   * @return {array} positions 计算后的节点位置数组\n   */\n  public runMDS(): PointTuple[] {\n    const self = this;\n    const dimension = 2;\n    const distances = self.scaledDistances;\n\n    // square distances\n    const M = MLMatrix.mul(MLMatrix.pow(distances, 2), -0.5);\n\n    // double centre the rows/columns\n    const rowMeans = M.mean("row");\n    const colMeans = M.mean("column");\n    const totalMean = M.mean();\n    M.add(totalMean)\n      .subRowVector(rowMeans)\n      .subColumnVector(colMeans);\n\n    // take the SVD of the double centred matrix, and return the\n    // points from it\n    const ret = new SingularValueDecomposition(M);\n    const eigenValues = MLMatrix.sqrt(ret.diagonalMatrix).diagonal();\n    return ret.leftSingularVectors.toJSON().map((row: number[]) => {\n      return MLMatrix.mul([row], [eigenValues])\n        .toJSON()[0]\n        .splice(0, dimension) as PointTuple;\n    });\n  }\n\n  public handleInfinity(distances: Matrix[]) {\n    let maxDistance = -999999;\n    distances.forEach(row => {\n      row.forEach(value => {\n        if (value === Infinity) {\n          return;\n        }\n        if (maxDistance < value) {\n          maxDistance = value;\n        }\n      });\n    });\n    distances.forEach((row, i) => {\n      row.forEach((value, j) => {\n        if (value === Infinity) {\n          distances[i][j] = maxDistance;\n        }\n      });\n    });\n  }\n\n  public getType() {\n    return "mds";\n  }\n}\n')])])]),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("p",[t._v("可视化图布局是可视化领域一个比较精深的方向，其设计了美学理念、机器学习、数据分析等相关知识，对于智能布局预测，可以结合机器学习等人工智能方法进行处理，业界常见的比如对于OpenOrd的一些大规模图布局的边切优化等，具体感兴趣的同学可以参看这篇文章"),e("a",{attrs:{href:"https://cloud.tencent.com/developer/article/1483027",target:"_blank",rel:"noopener noreferrer"}},[t._v("OpenOrd-面向大规模图布局的开源算法-研读"),e("OutboundLink")],1),t._v("；对于前端智能化与可视化结合的方面，可以将tensorflow与可视化图布局进行拓展，具体可以看一下G6的图布局预测方案"),e("a",{attrs:{href:"https://antv-g6.gitee.io/zh/docs/manual/middle/layout/ai-layout",target:"_blank",rel:"noopener noreferrer"}},[t._v("G6 智能布局预测"),e("OutboundLink")],1),t._v("，其大概实现思路是借助tensorflow，对于卷积层和池化层的处理以及相关操作。综上，可视化图布局领域的拓展结合了前端智能化与前端数据可视化两大前端方向，由此可见，前端的七大发展方向并非是割裂开来的，他们之间相互影响、相互借鉴，对于交叉领域深入研究或许能有不同的启发！")]),t._v(" "),e("h2",{attrs:{id:"参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://blog.js.cytoscape.org/2020/05/11/layouts/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Using layouts"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://antv-g6.gitee.io/zh/docs/manual/middle/layout/graph-layout",target:"_blank",rel:"noopener noreferrer"}},[t._v("G6-图布局"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://antv-g6.gitee.io/zh/docs/manual/middle/layout/ai-layout",target:"_blank",rel:"noopener noreferrer"}},[t._v("G6 智能布局预测"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://github.com/antvis/vis-predict-engine",target:"_blank",rel:"noopener noreferrer"}},[t._v("antv/vis-predict-engine源码"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://www.yuque.com/antv/g6-blog/vfnf7n",target:"_blank",rel:"noopener noreferrer"}},[t._v("图可视化之图布局"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://cloud.tencent.com/developer/article/1483027",target:"_blank",rel:"noopener noreferrer"}},[t._v("OpenOrd-面向大规模图布局的开源算法-研读"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/341530616",target:"_blank",rel:"noopener noreferrer"}},[t._v("全栈之计算机基础系列 - 图布局算法与可视化"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/346059370",target:"_blank",rel:"noopener noreferrer"}},[t._v("图可视化之图布局"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://blog.csdn.net/u014044032/article/details/91513982",target:"_blank",rel:"noopener noreferrer"}},[t._v("P问题、NP问题、NP完全问题和NP难问题"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/317840611",target:"_blank",rel:"noopener noreferrer"}},[t._v("图布局算法之Stress Majorization"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/279859898",target:"_blank",rel:"noopener noreferrer"}},[t._v("关系网络图(分析&可视化)的13个JavaScript库"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"http://www.mathe2.uni-bayreuth.de/axel/papers/reingold:graph_drawing_by_force_directed_placement.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("Graph Drawing by Force-directed Placement"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://blog.csdn.net/weixin_42398658/article/details/84031235/",target:"_blank",rel:"noopener noreferrer"}},[t._v("深度学习 --- 模拟退火算法详解（Simulated Annealing， SA）"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://blog.csdn.net/xierhacker/article/details/82747919",target:"_blank",rel:"noopener noreferrer"}},[t._v("TensorFlow学习（十七）：高级API之tf.layers"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);n.default=r.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{281:function(t,e,n){"use strict";n.r(e);var r=n(0),a=Object(r.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"数据结构算法在专网项目中的实践"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数据结构算法在专网项目中的实践"}},[t._v("#")]),t._v(" 数据结构算法在专网项目中的实践")]),t._v(" "),n("h2",{attrs:{id:"前言"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),n("p",[t._v("数据结构与算法作为计算机学科中至关重要的一门课程，在日常业务代码中常常很难用到或者说很难进行相关的实践，我们常常在leetcode中练习的习题感到没有用武之地。实际上，我们可以通过优化页面中的一些代码及在需求实现过程中对之前阅读过的源码或者之前练习过的习题进行相关的举一反三和触类旁通。本文列举了一些作者在日常业务代码书写过程中进行的一些相关数据结构算法的实践以及对于算法与数据结构练习的思考。")]),t._v(" "),n("h2",{attrs:{id:"业务需求"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#业务需求"}},[t._v("#")]),t._v(" 业务需求")]),t._v(" "),n("ul",[n("li",[t._v("自定义优先级规则展示")]),t._v(" "),n("li",[t._v("切换时间粒度字段映射")])]),t._v(" "),n("h2",{attrs:{id:"探索方案"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#探索方案"}},[t._v("#")]),t._v(" 探索方案")]),t._v(" "),n("h3",{attrs:{id:"自定义优先级规则展示"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#自定义优先级规则展示"}},[t._v("#")]),t._v(" 自定义优先级规则展示")]),t._v(" "),n("p",[t._v("在前端页面中，我们经常会遇到需要一排展示数量或者不同维度属性的需求，通常来说我们会将后端所有返回的字段都进行相关的展示，但是在一些轻交互重展示的场景中，比如可视化大屏，就需要我们对展示的内容进行取舍，而这个取舍就需要我们能够根据需求或者说产品数据的反馈进行优先级的选择排布，这里就会涉及到优先级的动态调整过程，也就是能够根据数据或者需求来自定义展示优先级。")]),t._v(" "),n("h4",{attrs:{id:"方案一：函数式编程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#方案一：函数式编程"}},[t._v("#")]),t._v(" 方案一：函数式编程")]),t._v(" "),n("p",[n("img",{attrs:{src:"/tech/front/structure20210523/structure01.jpeg",alt:"图片"}})]),t._v(" "),n("p",[t._v("第一个比较简单的想法就是根据产品需求进行数组的分流，然后合并数组进行截取展示")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("fn(arr) {\n  let r = [], _r = [];\n  for(let i=0; i < arr.length; i++) {\n    // 数量展示优化\n    if( 达到某个数量 ) return r;\n    if(// 根据产品需求对数组进行分流) {\n      r.push(arr[i])\n    } else {\n      _r.push(arr[i])\n    }\n  }\n\n  return r.length > 5 ? r.slice(0,5) : r.concat(_r).slice(0,5);\n};\n\ngn() {\n  this.resourceConfig.map(// 业务逻辑).sort((a,b) => a.structure - b.structure));\n}\n\n最后 fn(gn())\n\n")])])]),n("h4",{attrs:{id:"方案二：链表"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#方案二：链表"}},[t._v("#")]),t._v(" 方案二：链表")]),t._v(" "),n("p",[n("img",{attrs:{src:"/tech/front/structure20210523/structure02.jpeg",alt:"图片"}})]),t._v(" "),n("p",[t._v("方案二来源于链表的删除更新方便的特点，通过一个链表将所有的优先级进行串联起来，通过使用update操作进行相关的业务更新操作")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 构造一个节点\nclass Node {\n  constructor(v, next){\n    this.value = v;\n    this.next = next;\n  }\n}\n \nclass LinkList {\n  constructor(){\n    // 链表的属性，长度和头部\n    this.size = 0\n    this.head = new Node(null, null)\n  }\n    \n  // 是否为空\n  isEmpty() {\n    return this.size === 0\n  }\n  \n  // 更新链表，进行相关业务的操作\n  update() {\n\n  }\n}\n")])])]),n("h4",{attrs:{id:"方案三：优先队列"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#方案三：优先队列"}},[t._v("#")]),t._v(" 方案三：优先队列")]),t._v(" "),n("p",[n("img",{attrs:{src:"/tech/front/structure20210523/structure03.jpeg",alt:"图片"}})]),t._v(" "),n("p",[t._v("本方案来源于react的fiber的优先级调度，通过优先队列进行相关的操作")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class PriorityQueue{\n    // 取父节点索引 ~~((index - 1) / 2)\n    constructor(arr){\n        if (arr.length){\n            this.tree = []\n            this._build_tree(arr);\n            return;\n        }\n        this.tree = [];\n    }\n\n    // 入队\n    enqueue(val){\n        this.tree.push(val);\n        // 上浮\n        this._up(this.tree.length - 1);\n    }\n\n    // 出队\n    dequeue(){\n        // 取树根元素\n        this.tree.shift();\n        // 最后一个元素放树根，进行下沉\n        let last = this.tree.pop();\n        this.tree.unshift(last);\n        // log(n)下沉\n        this._down(0);\n    }\n\n    // 取队首的值\n    getFirst(){\n        return this.tree[0];\n    }\n\n    _build_tree(arr){\n        let tree = this.tree;\n        tree.push(arr[0]);\n        for (let i = 1; i < arr.length; i++){\n            tree.unshift(arr[i]);\n            this._down(0);\n        }\n    }\n\n    // 对index号元素执行下沉操作. 也叫heapify\n    _down(index){\n        let tree = this.tree;\n        // 本身就是叶子节点，无需下沉\n        let last_no_leaf = ~~((tree.length - 2) / 2);\n        if (index > last_no_leaf) return;\n        while(index <= last_no_leaf){\n            let l = tree[index * 2 + 1];\n            let r = tree[index * 2 + 2] || tree[index * 2 + 1]; // 有可能没有右儿子\n            let max = l >= r ? l : r;\n            let maxIndex = l >= r ? index * 2 + 1: index * 2 + 2\n            if (tree[index] < max){\n                [tree[index], tree[maxIndex]] = [tree[maxIndex], tree[index]]\n                index = index * 2 + 1\n            }else{\n                return;\n            }\n        }\n    }\n\n    // 对index号元素执行上浮操作\n    _up(index){\n        let tree = this.tree;\n        while(index !== 0){\n            let p = ~~((index - 1) / 2);\n            if (tree[index] > tree[p]){\n                [tree[index], tree[p]] = [tree[p], tree[index]];\n                // let tmp = index;\n                // this._down(tmp);\n                index = p;\n            } else {\n                return;\n            }\n        }\n    }\n}\n")])])]),n("h3",{attrs:{id:"切换时间粒度字段映射"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#切换时间粒度字段映射"}},[t._v("#")]),t._v(" 切换时间粒度字段映射")]),t._v(" "),n("p",[t._v("在前端页面中，对于动态下拉选择框选项，我们通常通过接口进行获取，但是对于多级联动的下拉选择选项，对于不同的时间粒度选择通常返回的数据名称相同但是id确实不同的，这时通常需要对数据进行映射处理")]),t._v(" "),n("h4",{attrs:{id:"方案：栈"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#方案：栈"}},[t._v("#")]),t._v(" 方案：栈")]),t._v(" "),n("p",[n("img",{attrs:{src:"/tech/front/structure20210523/structure04.jpeg",alt:"图片"}})]),t._v(" "),n("p",[t._v("在时间粒度进行切换时，需要记录前后最终前后两个时间粒度的值，通过接口进行时间粒度的数据映射，这里可以通过栈进行时间粒度的记录，获取最初和最后的时间粒度，最后进行数据映射")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const timeSizeList = [];\n\n// 进行入栈操作\ntimeSizeList.push(...)\n")])])]),n("h2",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),n("p",[t._v("日常进行数据结构习题练习或者阅读源码过程中，除了为了应付面试之外，最重要的还是要学习源码或者习题中解决问题的思路以及想法，在日常的业务代码中，虽然很难写出框架代码那种优雅简洁的实现方案，但是也应该在日常工作中多思考如何利用数据结构与算法来优化代码的时空复杂度，更好的优化代码的执行，从而提升用户体验，这才是一个高级工程师应该关注的细节点，不能只是为了完成业务代码而完成业务代码，这样虽然写了很多代码，但其实其对个人代码能力及计算机素养的提升都是很有限的，事倍却工半，希望在重复的业务代码书写过程中，也能做到优雅与高效并存，共勉！！！")]),t._v(" "),n("h2",{attrs:{id:"参考"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/348313033",target:"_blank",rel:"noopener noreferrer"}},[t._v("React中的高优先级任务插队机制"),n("OutboundLink")],1)]),t._v(" "),n("li",[n("a",{attrs:{href:"https://blog.csdn.net/qq_41907806/article/details/109590285",target:"_blank",rel:"noopener noreferrer"}},[t._v("JS手动实现一个链表"),n("OutboundLink")],1)]),t._v(" "),n("li",[n("a",{attrs:{href:"https://www.zoo.team/article/react-and-priority-queue",target:"_blank",rel:"noopener noreferrer"}},[t._v("结合React源码，五分钟带你掌握优先队列"),n("OutboundLink")],1)]),t._v(" "),n("li",[n("a",{attrs:{href:"https://segmentfault.com/a/1190000022131550",target:"_blank",rel:"noopener noreferrer"}},[t._v("JS实现优先队列的三种方式"),n("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=a.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{268:function(n,e,t){"use strict";t.r(e);var a=t(0),r=Object(a.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"几种微前端方案探究"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#几种微前端方案探究"}},[n._v("#")]),n._v(" 几种微前端方案探究")]),n._v(" "),t("h2",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[n._v("#")]),n._v(" 前言")]),n._v(" "),t("p",[n._v("随着技术的发展，前端应用承载的内容也日益复杂，基于此而产生的各种问题也应运而生，从MPA（Multi-Page Application，多页应用）到SPA（Single-Page Application，单页应用），虽然解决了切换体验的延迟问题，但也带来了首次加载时间长，以及工程爆炸增长后带来的巨石应用（Monolithic）问题；对于MPA来说，其部署简单，各应用之间天然硬隔离，并且具备技术栈无关、独立开发、独立部署等特点。要是能够将这两方的特点结合起来，会不会给用户和开发带来更好的用户体验？至此，在借鉴了微服务理念下，微前端便应运而生。")]),n._v(" "),t("blockquote",[t("p",[n._v("An architectural style where independently deliverable frontend applications are composed into a greater whole. [Micro Frontends from martinfowler.com]\n(https://martinfowler.com/articles/micro-frontends.html)")])]),n._v(" "),t("p",[n._v("根据martinfowler对微前端的定义可以看出：微前端是一种由独立交付的多个前端应用组成整体的架构风格，即微前端和微服务一样是一种架构风格，因而其并不是一种框架或者库，而是一种风格或者说是一种思想，所以为了实现微前端的方案就有很多种，最常见的方案有以下几种：")]),n._v(" "),t("ol",[t("li",[n._v("路由分发")])]),n._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/micro20210125/micro01.png",alt:"图片"}})]),n._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[t("p",[n._v("iframe")])]),n._v(" "),t("li",[t("p",[n._v("应用微服务")])])]),n._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/micro20210125/micro02.png",alt:"图片"}})]),n._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[n._v("微件化")])]),n._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/micro20210125/micro03.png",alt:"图片"}})]),n._v(" "),t("ol",{attrs:{start:"5"}},[t("li",[n._v("微应用化")])]),n._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/micro20210125/micro04.png",alt:"图片"}})]),n._v(" "),t("ol",{attrs:{start:"6"}},[t("li",[n._v("Web Components")])]),n._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/micro20210125/micro05.png",alt:"图片"}})]),n._v(" "),t("p",[n._v("相关对比：")]),n._v(" "),t("table",[t("thead",[t("tr",[t("th",{staticStyle:{"text-align":"left"}},[n._v("方案")]),n._v(" "),t("th",{staticStyle:{"text-align":"center"}},[n._v("开发成本")]),n._v(" "),t("th",{staticStyle:{"text-align":"center"}},[n._v("维护成本")]),n._v(" "),t("th",{staticStyle:{"text-align":"center"}},[n._v("可行性")]),n._v(" "),t("th",{staticStyle:{"text-align":"center"}},[n._v("同一框架要求")]),n._v(" "),t("th",{staticStyle:{"text-align":"center"}},[n._v("实现难度")]),n._v(" "),t("th",{staticStyle:{"text-align":"center"}},[n._v("潜在风险")]),n._v(" "),t("th",{staticStyle:{"text-align":"right"}},[n._v("落地实践")])])]),n._v(" "),t("tbody",[t("tr",[t("td",{staticStyle:{"text-align":"left"}},[n._v("路由分发")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("低")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("低")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("高")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("否")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("easy")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("无")]),n._v(" "),t("td",{staticStyle:{"text-align":"right"}},[n._v("http服务器反向代理，如nginx配置location")])]),n._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[n._v("iframe")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("低")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("低")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("高")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("否")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("easy")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("seo不友好、cookie管理、通信机制、弹窗问题、刷新后退、安全问题")]),n._v(" "),t("td",{staticStyle:{"text-align":"right"}},[n._v("前后端不分离项目常用")])]),n._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[n._v("应用微服务")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("高")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("低")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("中")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("否")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("hard")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("共享及隔离粒度不统一")]),n._v(" "),t("td",{staticStyle:{"text-align":"right"}},[n._v("qiankun、icestark、mooa及类single-spa应用")])]),n._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[n._v("微件化")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("高")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("中")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("低")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("是")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("hard")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("实现微件管理机制")]),n._v(" "),t("td",{staticStyle:{"text-align":"right"}},[n._v("无")])]),n._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[n._v("微应用化")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("中")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("中")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("高")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("是")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("normal")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("多个项目组合，需要考虑各个部署升级情况")]),n._v(" "),t("td",{staticStyle:{"text-align":"right"}},[n._v("emp")])]),n._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[n._v("Web Components")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("高")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("低")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("高")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("否")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("normal")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("新api，浏览器兼容性")]),n._v(" "),t("td",{staticStyle:{"text-align":"right"}},[n._v("无")])])])]),n._v(" "),t("p",[n._v("对于微前端方案的选择应该从现有资源及历史积淀中去选择上述一种或几种方案的组合，从不同维度（比如：共享能力、隔离机制、数据方案、路由鉴权等）去考虑，实现工程的平滑迁移，从而实现架构的迭代升级逐步重构，切忌为了架构而架构，不要无谓的炫技，任何技术都是合适的才是最好的，大巧不工，重剑无锋！")]),n._v(" "),t("h2",{attrs:{id:"方案对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方案对比"}},[n._v("#")]),n._v(" 方案对比")]),n._v(" "),t("p",[n._v("这里重点分析以应用微服务及微应用化的几种落地方案，对其实现思路做一个简单的探究")]),n._v(" "),t("ul",[t("li",[n._v("single-spa")]),n._v(" "),t("li",[n._v("qiankun")]),n._v(" "),t("li",[n._v("icestark")]),n._v(" "),t("li",[n._v("emp")]),n._v(" "),t("li",[n._v("piral")])]),n._v(" "),t("h2",{attrs:{id:"源码解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#源码解析"}},[n._v("#")]),n._v(" 源码解析")]),n._v(" "),t("h3",{attrs:{id:"single-spa源码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#single-spa源码"}},[n._v("#")]),n._v(" single-spa源码")]),n._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/micro20210125/micro06.png",alt:"图片"}})]),n._v(" "),t("p",[n._v("single-spa的整体思路是通过生命周期的钩子函数来对劫持的路由进行应用的加载，核心在于apps及reroute这两个文件")]),n._v(" "),t("h4",{attrs:{id:"apps-js"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#apps-js"}},[n._v("#")]),n._v(" apps.js")]),n._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/micro20210125/micro07.png",alt:"图片"}})]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("export function getAppChanges() {\n  const appsToUnload = [],\n    appsToUnmount = [],\n    appsToLoad = [],\n    appsToMount = [];\n\n  const currentTime = new Date().getTime();\n\n  apps.forEach((app) => {\n    const appShouldBeActive =\n      app.status !== SKIP_BECAUSE_BROKEN && shouldBeActive(app);\n\n    switch (app.status) {\n      case LOAD_ERROR:\n        if (appShouldBeActive && currentTime - app.loadErrorTime >= 200) {\n          appsToLoad.push(app);\n        }\n        break;\n      case NOT_LOADED:\n      case LOADING_SOURCE_CODE:\n        if (appShouldBeActive) {\n          appsToLoad.push(app);\n        }\n        break;\n      case NOT_BOOTSTRAPPED:\n      case NOT_MOUNTED:\n        if (!appShouldBeActive && getAppUnloadInfo(toName(app))) {\n          appsToUnload.push(app);\n        } else if (appShouldBeActive) {\n          appsToMount.push(app);\n        }\n        break;\n      case MOUNTED:\n        if (!appShouldBeActive) {\n          appsToUnmount.push(app);\n        }\n        break;\n    }\n  });\n\n  return { appsToUnload, appsToUnmount, appsToLoad, appsToMount };\n}\n\nexport function getMountedApps() {\n  return apps.filter(isActive).map(toName);\n}\n\nexport function registerApplication(\n  appNameOrConfig,\n  appOrLoadApp,\n  activeWhen,\n  customProps\n) {\n  const registration = sanitizeArguments(\n    appNameOrConfig,\n    appOrLoadApp,\n    activeWhen,\n    customProps\n  );\n\n  if (getAppNames().indexOf(registration.name) !== -1)\n    throw Error(\n      formatErrorMessage(\n        21,\n        __DEV__ &&\n          `There is already an app registered with name ${registration.name}`,\n        registration.name\n      )\n    );\n\n  apps.push(\n    assign(\n      {\n        loadErrorTime: null,\n        status: NOT_LOADED,\n        parcels: {},\n        devtools: {\n          overlays: {\n            options: {},\n            selectors: [],\n          },\n        },\n      },\n      registration\n    )\n  );\n\n  if (isInBrowser) {\n    ensureJQuerySupport();\n    reroute();\n  }\n}\n\nexport function unregisterApplication(appName) {\n  if (apps.filter((app) => toName(app) === appName).length === 0) {\n    throw Error(\n      formatErrorMessage(\n        25,\n        __DEV__ &&\n          `Cannot unregister application '${appName}' because no such application has been registered`,\n        appName\n      )\n    );\n  }\n\n  return unloadApplication(appName).then(() => {\n    const appIndex = apps.map(toName).indexOf(appName);\n    apps.splice(appIndex, 1);\n  });\n}\n\nexport function unloadApplication(appName, opts = { waitForUnmount: false }) {\n  if (typeof appName !== \"string\") {\n    throw Error(\n      formatErrorMessage(\n        26,\n        __DEV__ && `unloadApplication requires a string 'appName'`\n      )\n    );\n  }\n  const app = find(apps, (App) => toName(App) === appName);\n  if (!app) {\n    throw Error(\n      formatErrorMessage(\n        27,\n        __DEV__ &&\n          `Could not unload application '${appName}' because no such application has been registered`,\n        appName\n      )\n    );\n  }\n\n  const appUnloadInfo = getAppUnloadInfo(toName(app));\n  if (opts && opts.waitForUnmount) {\n\n    if (appUnloadInfo) {\n      return appUnloadInfo.promise;\n    } else {\n      const promise = new Promise((resolve, reject) => {\n        addAppToUnload(app, () => promise, resolve, reject);\n      });\n      return promise;\n    }\n  } else {\n    let resultPromise;\n    if (appUnloadInfo) {\n      resultPromise = appUnloadInfo.promise;\n      immediatelyUnloadApp(app, appUnloadInfo.resolve, appUnloadInfo.reject);\n    } else {\n      resultPromise = new Promise((resolve, reject) => {\n        addAppToUnload(app, () => resultPromise, resolve, reject);\n        immediatelyUnloadApp(app, resolve, reject);\n      });\n    }\n\n    return resultPromise;\n  }\n}\n")])])]),t("h4",{attrs:{id:"reroute-js"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reroute-js"}},[n._v("#")]),n._v(" reroute.js")]),n._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/micro20210125/micro08.png",alt:"图片"}})]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('export function reroute(pendingPromises = [], eventArguments) {\n  if (appChangeUnderway) {\n    return new Promise((resolve, reject) => {\n      peopleWaitingOnAppChange.push({\n        resolve,\n        reject,\n        eventArguments,\n      });\n    });\n  }\n\n  const {\n    appsToUnload,\n    appsToUnmount,\n    appsToLoad,\n    appsToMount,\n  } = getAppChanges();\n  let appsThatChanged,\n    navigationIsCanceled = false,\n    oldUrl = currentUrl,\n    newUrl = (currentUrl = window.location.href);\n\n  if (isStarted()) {\n    appChangeUnderway = true;\n    appsThatChanged = appsToUnload.concat(\n      appsToLoad,\n      appsToUnmount,\n      appsToMount\n    );\n    return performAppChanges();\n  } else {\n    appsThatChanged = appsToLoad;\n    return loadApps();\n  }\n\n  function cancelNavigation() {\n    navigationIsCanceled = true;\n  }\n\n  function loadApps() {\n    return Promise.resolve().then(() => {\n      const loadPromises = appsToLoad.map(toLoadPromise);\n\n      return (\n        Promise.all(loadPromises)\n          .then(callAllEventListeners)\n          .then(() => [])\n          .catch((err) => {\n            callAllEventListeners();\n            throw err;\n          })\n      );\n    });\n  }\n\n  function performAppChanges() {\n    return Promise.resolve().then(() => {\n      window.dispatchEvent(\n        new CustomEvent(\n          appsThatChanged.length === 0\n            ? "single-spa:before-no-app-change"\n            : "single-spa:before-app-change",\n          getCustomEventDetail(true)\n        )\n      );\n\n      window.dispatchEvent(\n        new CustomEvent(\n          "single-spa:before-routing-event",\n          getCustomEventDetail(true, { cancelNavigation })\n        )\n      );\n\n      if (navigationIsCanceled) {\n        window.dispatchEvent(\n          new CustomEvent(\n            "single-spa:before-mount-routing-event",\n            getCustomEventDetail(true)\n          )\n        );\n        finishUpAndReturn();\n        navigateToUrl(oldUrl);\n        return;\n      }\n\n      const unloadPromises = appsToUnload.map(toUnloadPromise);\n\n      const unmountUnloadPromises = appsToUnmount\n        .map(toUnmountPromise)\n        .map((unmountPromise) => unmountPromise.then(toUnloadPromise));\n\n      const allUnmountPromises = unmountUnloadPromises.concat(unloadPromises);\n\n      const unmountAllPromise = Promise.all(allUnmountPromises);\n\n      unmountAllPromise.then(() => {\n        window.dispatchEvent(\n          new CustomEvent(\n            "single-spa:before-mount-routing-event",\n            getCustomEventDetail(true)\n          )\n        );\n      });\n\n      const loadThenMountPromises = appsToLoad.map((app) => {\n        return toLoadPromise(app).then((app) =>\n          tryToBootstrapAndMount(app, unmountAllPromise)\n        );\n      });\n\n      const mountPromises = appsToMount\n        .filter((appToMount) => appsToLoad.indexOf(appToMount) < 0)\n        .map((appToMount) => {\n          return tryToBootstrapAndMount(appToMount, unmountAllPromise);\n        });\n      return unmountAllPromise\n        .catch((err) => {\n          callAllEventListeners();\n          throw err;\n        })\n        .then(() => {\n          callAllEventListeners();\n\n          return Promise.all(loadThenMountPromises.concat(mountPromises))\n            .catch((err) => {\n              pendingPromises.forEach((promise) => promise.reject(err));\n              throw err;\n            })\n            .then(finishUpAndReturn);\n        });\n    });\n  }\n\n  function finishUpAndReturn() {\n    const returnValue = getMountedApps();\n    pendingPromises.forEach((promise) => promise.resolve(returnValue));\n\n    try {\n      const appChangeEventName =\n        appsThatChanged.length === 0\n          ? "single-spa:no-app-change"\n          : "single-spa:app-change";\n      window.dispatchEvent(\n        new CustomEvent(appChangeEventName, getCustomEventDetail())\n      );\n      window.dispatchEvent(\n        new CustomEvent("single-spa:routing-event", getCustomEventDetail())\n      );\n    } catch (err) {\n      setTimeout(() => {\n        throw err;\n      });\n    }\n\n    appChangeUnderway = false;\n\n    if (peopleWaitingOnAppChange.length > 0) {\n      const nextPendingPromises = peopleWaitingOnAppChange;\n      peopleWaitingOnAppChange = [];\n      reroute(nextPendingPromises);\n    }\n\n    return returnValue;\n  }\n\n  function callAllEventListeners() {\n    pendingPromises.forEach((pendingPromise) => {\n      callCapturedEventListeners(pendingPromise.eventArguments);\n    });\n\n    callCapturedEventListeners(eventArguments);\n  }\n\n  function getCustomEventDetail(isBeforeChanges = false, extraProperties) {\n    const newAppStatuses = {};\n    const appsByNewStatus = {\n      [MOUNTED]: [],\n      [NOT_MOUNTED]: [],\n      [NOT_LOADED]: [],\n      [SKIP_BECAUSE_BROKEN]: [],\n    };\n\n    if (isBeforeChanges) {\n      appsToLoad.concat(appsToMount).forEach((app, index) => {\n        addApp(app, MOUNTED);\n      });\n      appsToUnload.forEach((app) => {\n        addApp(app, NOT_LOADED);\n      });\n      appsToUnmount.forEach((app) => {\n        addApp(app, NOT_MOUNTED);\n      });\n    } else {\n      appsThatChanged.forEach((app) => {\n        addApp(app);\n      });\n    }\n\n    const result = {\n      detail: {\n        newAppStatuses,\n        appsByNewStatus,\n        totalAppChanges: appsThatChanged.length,\n        originalEvent: eventArguments?.[0],\n        oldUrl,\n        newUrl,\n        navigationIsCanceled,\n      },\n    };\n\n    if (extraProperties) {\n      assign(result.detail, extraProperties);\n    }\n\n    return result;\n\n    function addApp(app, status) {\n      const appName = toName(app);\n      status = status || getAppStatus(appName);\n      newAppStatuses[appName] = status;\n      const statusArr = (appsByNewStatus[status] =\n        appsByNewStatus[status] || []);\n      statusArr.push(appName);\n    }\n  }\n}\n')])])]),t("h3",{attrs:{id:"qiankun源码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#qiankun源码"}},[n._v("#")]),n._v(" qiankun源码")]),n._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/micro20210125/micro09.png",alt:"图片"}})]),n._v(" "),t("p",[n._v("qiankun是基于single-spa而封装了隔离及共享机制的框架，其简化了single-spa的相关生命周期，并且提供了沙箱隔离机制及共享机制")]),n._v(" "),t("h4",{attrs:{id:"sandbox"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sandbox"}},[n._v("#")]),n._v(" sandbox")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("export type SandBox = {\n  /** 沙箱的名字 */\n  name: string;\n  /** 沙箱的类型 */\n  type: SandBoxType;\n  /** 沙箱导出的代理实体 */\n  proxy: WindowProxy;\n  /** 沙箱是否在运行中 */\n  sandboxRunning: boolean;\n  /** latest set property */\n  latestSetProp?: PropertyKey | null;\n  /** 启动沙箱 */\n  active: () => void;\n  /** 关闭沙箱 */\n  inactive: () => void;\n};\n\n// Proxy沙箱\nexport default class ProxySandbox implements SandBox {\n  /** window 值变更记录 */\n  private updatedValueSet = new Set<PropertyKey>();\n\n  name: string;\n\n  type: SandBoxType;\n\n  proxy: WindowProxy;\n\n  sandboxRunning = true;\n\n  latestSetProp: PropertyKey | null = null;\n\n  active() {\n    if (!this.sandboxRunning) activeSandboxCount++;\n    this.sandboxRunning = true;\n  }\n\n  inactive() {\n    if (process.env.NODE_ENV === 'development') {\n      console.info(`[qiankun:sandbox] ${this.name} modified global properties restore...`, [\n        ...this.updatedValueSet.keys(),\n      ]);\n    }\n\n    if (--activeSandboxCount === 0) {\n      variableWhiteList.forEach((p) => {\n        if (this.proxy.hasOwnProperty(p)) {\n          // @ts-ignore\n          delete window[p];\n        }\n      });\n    }\n\n    this.sandboxRunning = false;\n  }\n\n  constructor(name: string) {\n    this.name = name;\n    this.type = SandBoxType.Proxy;\n    const { updatedValueSet } = this;\n\n    const rawWindow = window;\n    const { fakeWindow, propertiesWithGetter } = createFakeWindow(rawWindow);\n\n    const descriptorTargetMap = new Map<PropertyKey, SymbolTarget>();\n    const hasOwnProperty = (key: PropertyKey) => fakeWindow.hasOwnProperty(key) || rawWindow.hasOwnProperty(key);\n\n    const proxy = new Proxy(fakeWindow, {\n      set: (target: FakeWindow, p: PropertyKey, value: any): boolean => {\n        if (this.sandboxRunning) {\n          // We must kept its description while the property existed in rawWindow before\n          if (!target.hasOwnProperty(p) && rawWindow.hasOwnProperty(p)) {\n            const descriptor = Object.getOwnPropertyDescriptor(rawWindow, p);\n            const { writable, configurable, enumerable } = descriptor!;\n            if (writable) {\n              Object.defineProperty(target, p, {\n                configurable,\n                enumerable,\n                writable,\n                value,\n              });\n            }\n          } else {\n            // @ts-ignore\n            target[p] = value;\n          }\n\n          if (variableWhiteList.indexOf(p) !== -1) {\n            // @ts-ignore\n            rawWindow[p] = value;\n          }\n\n          updatedValueSet.add(p);\n\n          this.latestSetProp = p;\n\n          return true;\n        }\n\n        if (process.env.NODE_ENV === 'development') {\n          console.warn(`[qiankun] Set window.${p.toString()} while sandbox destroyed or inactive in ${name}!`);\n        }\n\n        // 在 strict-mode 下，Proxy 的 handler.set 返回 false 会抛出 TypeError，在沙箱卸载的情况下应该忽略错误\n        return true;\n      },\n\n      get(target: FakeWindow, p: PropertyKey): any {\n        if (p === Symbol.unscopables) return unscopables;\n\n        // avoid who using window.window or window.self to escape the sandbox environment to touch the really window\n        // see https://github.com/eligrey/FileSaver.js/blob/master/src/FileSaver.js#L13\n        if (p === 'window' || p === 'self') {\n          return proxy;\n        }\n\n        if (\n          p === 'top' ||\n          p === 'parent' ||\n          (process.env.NODE_ENV === 'test' && (p === 'mockTop' || p === 'mockSafariTop'))\n        ) {\n          // if your master app in an iframe context, allow these props escape the sandbox\n          if (rawWindow === rawWindow.parent) {\n            return proxy;\n          }\n          return (rawWindow as any)[p];\n        }\n\n        // proxy.hasOwnProperty would invoke getter firstly, then its value represented as rawWindow.hasOwnProperty\n        if (p === 'hasOwnProperty') {\n          return hasOwnProperty;\n        }\n\n        // mark the symbol to document while accessing as document.createElement could know is invoked by which sandbox for dynamic append patcher\n        if (p === 'document' || p === 'eval') {\n          setCurrentRunningSandboxProxy(proxy);\n          // FIXME if you have any other good ideas\n          // remove the mark in next tick, thus we can identify whether it in micro app or not\n          // this approach is just a workaround, it could not cover all complex cases, such as the micro app runs in the same task context with master in some case\n          nextTick(() => setCurrentRunningSandboxProxy(null));\n          switch (p) {\n            case 'document':\n              return document;\n            case 'eval':\n              // eslint-disable-next-line no-eval\n              return eval;\n            // no default\n          }\n        }\n\n        // eslint-disable-next-line no-nested-ternary\n        const value = propertiesWithGetter.has(p)\n          ? (rawWindow as any)[p]\n          : p in target\n          ? (target as any)[p]\n          : (rawWindow as any)[p];\n        return getTargetValue(rawWindow, value);\n      },\n\n      // trap in operator\n      // see https://github.com/styled-components/styled-components/blob/master/packages/styled-components/src/constants.js#L12\n      has(target: FakeWindow, p: string | number | symbol): boolean {\n        return p in unscopables || p in target || p in rawWindow;\n      },\n\n      getOwnPropertyDescriptor(target: FakeWindow, p: string | number | symbol): PropertyDescriptor | undefined {\n        /*\n         as the descriptor of top/self/window/mockTop in raw window are configurable but not in proxy target, we need to get it from target to avoid TypeError\n         see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor\n         > A property cannot be reported as non-configurable, if it does not exists as an own property of the target object or if it exists as a configurable own property of the target object.\n         */\n        if (target.hasOwnProperty(p)) {\n          const descriptor = Object.getOwnPropertyDescriptor(target, p);\n          descriptorTargetMap.set(p, 'target');\n          return descriptor;\n        }\n\n        if (rawWindow.hasOwnProperty(p)) {\n          const descriptor = Object.getOwnPropertyDescriptor(rawWindow, p);\n          descriptorTargetMap.set(p, 'rawWindow');\n          // A property cannot be reported as non-configurable, if it does not exists as an own property of the target object\n          if (descriptor && !descriptor.configurable) {\n            descriptor.configurable = true;\n          }\n          return descriptor;\n        }\n\n        return undefined;\n      },\n\n      // trap to support iterator with sandbox\n      ownKeys(target: FakeWindow): PropertyKey[] {\n        const keys = uniq(Reflect.ownKeys(rawWindow).concat(Reflect.ownKeys(target)));\n        return keys;\n      },\n\n      defineProperty(target: Window, p: PropertyKey, attributes: PropertyDescriptor): boolean {\n        const from = descriptorTargetMap.get(p);\n        /*\n         Descriptor must be defined to native window while it comes from native window via Object.getOwnPropertyDescriptor(window, p),\n         otherwise it would cause a TypeError with illegal invocation.\n         */\n        switch (from) {\n          case 'rawWindow':\n            return Reflect.defineProperty(rawWindow, p, attributes);\n          default:\n            return Reflect.defineProperty(target, p, attributes);\n        }\n      },\n\n      deleteProperty(target: FakeWindow, p: string | number | symbol): boolean {\n        if (target.hasOwnProperty(p)) {\n          // @ts-ignore\n          delete target[p];\n          updatedValueSet.delete(p);\n\n          return true;\n        }\n\n        return true;\n      },\n    });\n\n    this.proxy = proxy;\n\n    activeSandboxCount++;\n  }\n}\n\n// 快照snapshot沙箱\nexport default class SnapshotSandbox implements SandBox {\n  proxy: WindowProxy;\n\n  name: string;\n\n  type: SandBoxType;\n\n  sandboxRunning = true;\n\n  private windowSnapshot!: Window;\n\n  private modifyPropsMap: Record<any, any> = {};\n\n  constructor(name: string) {\n    this.name = name;\n    this.proxy = window;\n    this.type = SandBoxType.Snapshot;\n  }\n\n  active() {\n    // 记录当前快照\n    this.windowSnapshot = {} as Window;\n    iter(window, (prop) => {\n      this.windowSnapshot[prop] = window[prop];\n    });\n\n    // 恢复之前的变更\n    Object.keys(this.modifyPropsMap).forEach((p: any) => {\n      window[p] = this.modifyPropsMap[p];\n    });\n\n    this.sandboxRunning = true;\n  }\n\n  inactive() {\n    this.modifyPropsMap = {};\n\n    iter(window, (prop) => {\n      if (window[prop] !== this.windowSnapshot[prop]) {\n        // 记录变更，恢复环境\n        this.modifyPropsMap[prop] = window[prop];\n        window[prop] = this.windowSnapshot[prop];\n      }\n    });\n\n    if (process.env.NODE_ENV === 'development') {\n      console.info(`[qiankun:sandbox] ${this.name} origin window restore...`, Object.keys(this.modifyPropsMap));\n    }\n\n    this.sandboxRunning = false;\n  }\n}\n")])])]),t("h4",{attrs:{id:"globalstate-js"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#globalstate-js"}},[n._v("#")]),n._v(" globalState.js")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 触发全局监听\nfunction emitGlobal(state: Record<string, any>, prevState: Record<string, any>) {\n  Object.keys(deps).forEach((id: string) => {\n    if (deps[id] instanceof Function) {\n      deps[id](cloneDeep(state), cloneDeep(prevState));\n    }\n  });\n}\n\nexport function initGlobalState(state: Record<string, any> = {}) {\n  if (state === globalState) {\n    console.warn('[qiankun] state has not changed！');\n  } else {\n    const prevGlobalState = cloneDeep(globalState);\n    globalState = cloneDeep(state);\n    emitGlobal(globalState, prevGlobalState);\n  }\n  return getMicroAppStateActions(`global-${+new Date()}`, true);\n}\n\nexport function getMicroAppStateActions(id: string, isMaster?: boolean): MicroAppStateActions {\n  return {\n    /**\n     * onGlobalStateChange 全局依赖监听\n     *\n     * 收集 setState 时所需要触发的依赖\n     *\n     * 限制条件：每个子应用只有一个激活状态的全局监听，新监听覆盖旧监听，若只是监听部分属性，请使用 onGlobalStateChange\n     *\n     * 这么设计是为了减少全局监听滥用导致的内存爆炸\n     *\n     * 依赖数据结构为：\n     * {\n     *   {id}: callback\n     * }\n     *\n     * @param callback\n     * @param fireImmediately\n     */\n    onGlobalStateChange(callback: OnGlobalStateChangeCallback, fireImmediately?: boolean) {\n      if (!(callback instanceof Function)) {\n        console.error('[qiankun] callback must be function!');\n        return;\n      }\n      if (deps[id]) {\n        console.warn(`[qiankun] '${id}' global listener already exists before this, new listener will overwrite it.`);\n      }\n      deps[id] = callback;\n      const cloneState = cloneDeep(globalState);\n      if (fireImmediately) {\n        callback(cloneState, cloneState);\n      }\n    },\n\n    /**\n     * setGlobalState 更新 store 数据\n     *\n     * 1. 对输入 state 的第一层属性做校验，只有初始化时声明过的第一层（bucket）属性才会被更改\n     * 2. 修改 store 并触发全局监听\n     *\n     * @param state\n     */\n    setGlobalState(state: Record<string, any> = {}) {\n      if (state === globalState) {\n        console.warn('[qiankun] state has not changed！');\n        return false;\n      }\n\n      const changeKeys: string[] = [];\n      const prevGlobalState = cloneDeep(globalState);\n      globalState = cloneDeep(\n        Object.keys(state).reduce((_globalState, changeKey) => {\n          if (isMaster || _globalState.hasOwnProperty(changeKey)) {\n            changeKeys.push(changeKey);\n            return Object.assign(_globalState, { [changeKey]: state[changeKey] });\n          }\n          console.warn(`[qiankun] '${changeKey}' not declared when init state！`);\n          return _globalState;\n        }, globalState),\n      );\n      if (changeKeys.length === 0) {\n        console.warn('[qiankun] state has not changed！');\n        return false;\n      }\n      emitGlobal(globalState, prevGlobalState);\n      return true;\n    },\n\n    // 注销该应用下的依赖\n    offGlobalStateChange() {\n      delete deps[id];\n      return true;\n    },\n  };\n}\n")])])]),t("h3",{attrs:{id:"icestark源码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#icestark源码"}},[n._v("#")]),n._v(" icestark源码")]),n._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/micro20210125/micro10.png",alt:"图片"}})]),n._v(" "),t("p",[n._v("ice是淘系团队的一个全流程前端框架，其中包含了脚手架、组件库、vscode插件、lowcode生成等相关生态，其中icestark是其中包含的相关微前端的应用，这里不展开ice相关的架构了，简单来说其本质是以微内核形态配合各种插件市场来构成的强大生态系统，本文重点在微前端，因而只讨论微前端相关内容")]),n._v(" "),t("h4",{attrs:{id:"apps-ts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#apps-ts"}},[n._v("#")]),n._v(" apps.ts")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("export function registerMicroApp(appConfig: AppConfig, appLifecyle?: AppLifecylceOptions) {\n  // check appConfig.name\n  if (getAppNames().includes(appConfig.name)) {\n    throw Error(`name ${appConfig.name} already been regsitered`);\n  }\n  // set activeRules\n  const { activePath, hashType = false, exact = false, sensitive = false, strict = false } = appConfig;\n  const activeRules: (ActiveFn | string | MatchOptions)[] = Array.isArray(activePath) ? activePath : [activePath];\n  const checkActive = activePath\n    ? (url: string) => activeRules.map((activeRule: ActiveFn | string | MatchOptions) => {\n      if (typeof activeRule === 'function' ) {\n        return activeRule;\n      } else {\n        const pathOptions: MatchOptions = { hashType, exact, sensitive, strict };\n        const pathInfo = Object.prototype.toString.call(activeRule) === '[object Object]'\n          ? { ...pathOptions, ...(activeRule as MatchOptions) }\n          : { path: activeRule as string, ...pathOptions };\n        return (checkUrl: string) => matchActivePath(checkUrl, pathInfo);\n      }\n    }).some((activeRule: ActiveFn) => activeRule(url))\n    // active app when activePath is not specified\n    : () => true;\n  const microApp = {\n    status: NOT_LOADED,\n    ...appConfig,\n    appLifecycle: appLifecyle,\n    checkActive,\n  };\n  microApps.push(microApp);\n}\n\nexport function registerMicroApps(appConfigs: AppConfig[], appLifecyle?: AppLifecylceOptions) {\n  appConfigs.forEach(appConfig => {\n    registerMicroApp(appConfig, appLifecyle);\n  });\n}\n\n// 可以加载module粒度的应用\nexport async function loadAppModule(appConfig: AppConfig) {\n  const { onLoadingApp, onFinishLoading, fetch } = getAppConfig(appConfig.name)?.configuration || globalConfiguration;\n\n  let lifecycle: ModuleLifeCycle = {};\n  onLoadingApp(appConfig);\n  const appSandbox = createSandbox(appConfig.sandbox);\n  const { url, container, entry, entryContent, name } = appConfig;\n  const appAssets = url ? getUrlAssets(url) : await getEntryAssets({\n    root: container,\n    entry,\n    href: location.href,\n    entryContent,\n    assetsCacheKey: name,\n    fetch,\n  });\n  updateAppConfig(appConfig.name, { appAssets, appSandbox });\n\n  cacheLoadMode(appConfig);\n\n  if (appConfig.umd) {\n    await loadAndAppendCssAssets(appAssets);\n    lifecycle = await loadUmdModule(appAssets.jsList, appSandbox);\n  } else {\n    await appendAssets(appAssets, appSandbox, fetch);\n    lifecycle = {\n      mount: getCache(AppLifeCycleEnum.AppEnter),\n      unmount: getCache(AppLifeCycleEnum.AppLeave),\n    };\n    setCache(AppLifeCycleEnum.AppEnter, null);\n    setCache(AppLifeCycleEnum.AppLeave, null);\n  }\n  onFinishLoading(appConfig);\n  return combineLifecyle(lifecycle, appConfig);\n}\n\nfunction capitalize(str: string) {\n  if (typeof str !== 'string') return '';\n  return `${str.charAt(0).toUpperCase()}${str.slice(1)}`;\n}\n\nasync function callAppLifecycle(primaryKey: string, lifecycleKey: string, appConfig: AppConfig) {\n  if (appConfig.appLifecycle && appConfig.appLifecycle[`${primaryKey}${capitalize(lifecycleKey)}`]) {\n    await appConfig.appLifecycle[`${primaryKey}${capitalize(lifecycleKey)}`](appConfig);\n  }\n}\n\nfunction combineLifecyle(lifecycle: ModuleLifeCycle, appConfig: AppConfig) {\n  const combinedLifecyle = { ...lifecycle };\n  ['mount', 'unmount', 'update'].forEach((lifecycleKey) => {\n    if (lifecycle[lifecycleKey]) {\n      combinedLifecyle[lifecycleKey] = async (props) => {\n        await callAppLifecycle('before', lifecycleKey, appConfig);\n        await lifecycle[lifecycleKey](props);\n        await callAppLifecycle('after', lifecycleKey, appConfig);\n      };\n    }\n  });\n  return combinedLifecyle;\n}\n\nexport async function mountMicroApp(appName: string) {\n  const appConfig = getAppConfig(appName);\n  // check current url before mount\n  if (appConfig && appConfig.checkActive(window.location.href) && appConfig.status !== MOUNTED) {\n    updateAppConfig(appName, { status: MOUNTED });\n    if (appConfig.mount) {\n      await appConfig.mount({ container: appConfig.container, customProps: appConfig.props });\n    }\n  }\n}\n\nexport async function unmountMicroApp(appName: string) {\n  const appConfig = getAppConfig(appName);\n  if (appConfig && (appConfig.status === MOUNTED || appConfig.status === LOADING_ASSETS || appConfig.status === NOT_MOUNTED)) {\n    // remove assets if app is not cached\n    const { shouldAssetsRemove } = getAppConfig(appName)?.configuration  || globalConfiguration;\n    emptyAssets(shouldAssetsRemove, !appConfig.cached && appConfig.name);\n    updateAppConfig(appName, { status: UNMOUNTED });\n    if (!appConfig.cached && appConfig.appSandbox) {\n      appConfig.appSandbox.clear();\n      appConfig.appSandbox = null;\n    }\n    if (appConfig.unmount) {\n      await appConfig.unmount({ container: appConfig.container, customProps: appConfig.props });\n    }\n  }\n}\n\n// unload micro app, load app bundles when create micro app\nexport async function unloadMicroApp(appName: string) {\n  const appConfig = getAppConfig(appName);\n  if (appConfig) {\n    unmountMicroApp(appName);\n    delete appConfig.mount;\n    delete appConfig.unmount;\n    delete appConfig.appAssets;\n    updateAppConfig(appName, { status: NOT_LOADED });\n  } else {\n    console.log(`[icestark] can not find app ${appName} when call unloadMicroApp`);\n  }\n}\n\n// remove app config from cache\nexport function removeMicroApp(appName: string) {\n  const appIndex = getAppNames().indexOf(appName);\n  if (appIndex > -1) {\n    // unload micro app in case of app is mounted\n    unloadMicroApp(appName);\n    microApps.splice(appIndex, 1);\n  } else {\n    console.log(`[icestark] can not find app ${appName} when call removeMicroApp`);\n  }\n}\n\nexport function removeMicroApps(appNames: string[]) {\n  appNames.forEach((appName) => {\n    removeMicroApp(appName);\n  });\n}\n\n// clear all micro app configs\nexport function clearMicroApps () {\n  getAppNames().forEach(name => {\n    unloadMicroApp(name);\n  });\n  microApps = [];\n}\n")])])]),t("h4",{attrs:{id:"start-ts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#start-ts"}},[n._v("#")]),n._v(" start.ts")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("export function reroute (url: string, type: RouteType | 'init' | 'popstate'| 'hashchange' ) {\n  const { pathname, query, hash } = urlParse(url, true);\n  // trigger onRouteChange when url is changed\n  if (lastUrl !== url) {\n    globalConfiguration.onRouteChange(url, pathname, query, hash, type);\n  \n    const unmountApps = [];\n    const activeApps = [];\n    getMicroApps().forEach((microApp: AppConfig) => {\n      const shouldBeActive = microApp.checkActive(url);\n      if (shouldBeActive) {\n        activeApps.push(microApp);\n      } else {\n        unmountApps.push(microApp);\n      }\n    });\n    // trigger onActiveApps when url is changed\n    globalConfiguration.onActiveApps(activeApps);\n\n    // call captured event after app mounted\n    Promise.all(\n      // call unmount apps\n      unmountApps.map(async (unmountApp) => {\n        if (unmountApp.status === MOUNTED || unmountApp.status === LOADING_ASSETS) {\n          globalConfiguration.onAppLeave(unmountApp);\n        }\n        await unmountMicroApp(unmountApp.name);\n      }).concat(activeApps.map(async (activeApp) => {\n        if (activeApp.status !== MOUNTED) {\n          globalConfiguration.onAppEnter(activeApp);\n        }\n        await createMicroApp(activeApp);\n      }))\n    ).then(() => {\n      callCapturedEventListeners();\n    });\n  }\n  lastUrl = url;\n};\n\nfunction start(options?: StartConfiguration) {\n  if (started) {\n    console.log('icestark has been already started');\n    return;\n  }\n  started = true;\n  recordAssets();\n  // update globalConfiguration\n  Object.keys(options || {}).forEach((configKey) => {\n    globalConfiguration[configKey] = options[configKey];\n  });\n  hijackHistory();\n  hijackEventListener();\n\n  // trigger init router\n  globalConfiguration.reroute(location.href, 'init');\n}\n\nfunction unload() {\n  unHijackEventListener();\n  unHijackHistory();\n  started = false;\n  // remove all assets added by micro apps\n  emptyAssets(globalConfiguration.shouldAssetsRemove, true);\n  clearMicroApps();\n}\n")])])]),t("h3",{attrs:{id:"emp源码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#emp源码"}},[n._v("#")]),n._v(" emp源码")]),n._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/micro20210125/micro11.jpeg",alt:"图片"}})]),n._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/micro20210125/micro12.jpg",alt:"图片"}})]),n._v(" "),t("p",[n._v("emp实现方式完全不同于类single-spa的方案，其是利用的webpack5的模块联邦机制，实现模块与模块之间的共享调用，YY的大佬们基于ts的xxx.d.ts的共享传递，实现了类似微服务的service mesh的功能，emp提供了完整的脚手架功能")]),n._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/micro20210125/micro13.png",alt:"图片"}})]),n._v(" "),t("h4",{attrs:{id:"emp-cli"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#emp-cli"}},[n._v("#")]),n._v(" emp-cli")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');\n\nmodule.exports = (env, config, {analyze, empEnv, ts, progress, createName, createPath, hot}) => {\n  const isDev = env === 'development'\n  const conf = {\n    plugin: {\n      mf: {\n        plugin: ModuleFederationPlugin,\n        args: [{}],\n      },\n    },\n  }\n  if (ts) {\n    createName = createName || 'index.d.ts'\n    createPath = createPath ? resolveApp(createPath) : resolveApp('dist')\n    conf.plugin.tunedts = {\n      plugin: TuneDtsPlugin,\n      args: [\n        {\n          output: path.join(createPath, createName),\n          path: createPath,\n          name: createName,\n          isDefault: true,\n        },\n      ],\n    }\n  }\n  config.merge(conf)\n}\n")])])]),t("h4",{attrs:{id:"emp-tune-dts-plugin"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#emp-tune-dts-plugin"}},[n._v("#")]),n._v(" emp-tune-dts-plugin")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function tuneType(createPath, createName, isDefault, operation = emptyFunc) {\n  // 获取 d.ts 文件\n  const filePath = `${createPath}/${createName}`\n  const fileData = fs.readFileSync(filePath, {encoding: 'utf-8'})\n  let newFileData = ''\n  newFileData = fileData\n  isDefault && (newFileData = defaultRepalce(fileData))\n  // }\n  newFileData && (newFileData = operation(newFileData) ? operation(newFileData) : newFileData)\n  // 覆盖原有 index.d.ts\n  fs.writeFileSync(filePath, newFileData, {encoding: 'utf-8'})\n}\n\nclass TuneDtsPlugin {\n  constructor(options) {\n    this.options = options || {}\n  }\n\n  apply(compiler) {\n    const _options = this.options\n    console.log('------------TuneDtsPlugin Working----------')\n    if (compiler.options.output.path) {\n      _options.path = compiler.options.output.path\n      _options.output = `${compiler.options.output.path}/${_options.name}`\n    }\n    compiler.hooks.afterEmit.tap(plugin, function () {\n      setTimeout(function () {\n        generateType(_options)\n      })\n    })\n  }\n}\n")])])]),t("h3",{attrs:{id:"piral源码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#piral源码"}},[n._v("#")]),n._v(" piral源码")]),n._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/micro20210125/micro14.png",alt:"图片"}})]),n._v(" "),t("p",[t("a",{attrs:{href:"https://docs.piral.io",target:"_blank",rel:"noopener noreferrer"}},[n._v("piral"),t("OutboundLink")],1),n._v("是一个基于react的微前端框架，其定义了两个概念：一个是Piral，这是给一个应用的壳子（application shell），其承载着各种应用，当然也包括由pilets构建共享的组件，定义这些应用何时被加载以及何时被集成；另一个是Pilet，这是一个特殊的模块（feature modules），其承载着不同的一应用，包含着独立的资源，其决定了组件的加载时机。Piral通过对加了一层pilets而进行资源的隔离，对没有加这一层的则可进行数据的共享")]),n._v(" "),t("h4",{attrs:{id:"piral"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#piral"}},[n._v("#")]),n._v(" piral")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// render.tsx\nexport function renderInstance(options?: PiralRenderOptions) {\n  return runInstance((app, selector) => render(app, getContainer(selector)), options);\n}\n\n// run.tsx\nexport function runInstance(runner: PiralRunner, options: PiralRenderOptions = {}) {\n  const { selector = '#app', settings, layout, errors, middleware = noChange, ...config } = options;\n  const { app, instance } = getAppInstance(middleware(config), { settings, layout, errors });\n  runner(app, selector);\n  return instance;\n}\n")])])]),t("h4",{attrs:{id:"piral-base"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#piral-base"}},[n._v("#")]),n._v(" piral-base")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// dependency.ts\nexport function compileDependency(\n  name: string,\n  content: string,\n  link = '',\n  dependencies?: AvailableDependencies,\n): Promise<PiletApp> {\n  const app = evalDependency(name, content, link, dependencies);\n  return checkPiletAppAsync(name, app);\n}\n\n// fetch.ts\nexport function defaultFetchDependency(url: string) {\n  return fetch(url, {\n    method: 'GET',\n    cache: 'force-cache',\n  }).then((m) => m.text());\n}\n\n")])])]),t("h4",{attrs:{id:"piral-core"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#piral-core"}},[n._v("#")]),n._v(" piral-core")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// actions\nexport function initialize(ctx: GlobalStateContext, loading: boolean, error: Error | undefined, modules: Array<Pilet>) {\n  ctx.dispatch((state) => ({\n    ...state,\n    app: {\n      ...state.app,\n      error,\n      loading,\n    },\n    modules,\n  }));\n}\n\nexport function injectPilet(ctx: GlobalStateContext, pilet: Pilet) {\n  ctx.dispatch((state) => ({\n    ...state,\n    modules: replaceOrAddItem(state.modules, pilet, (m) => m.name === pilet.name),\n    registry: removeNested<RegistryState, BaseRegistration>(state.registry, (m) => m.pilet === pilet.name),\n  }));\n\n  ctx.emit('unload-pilet', {\n    name: pilet.name,\n  });\n}\n\nexport function setComponent<TKey extends keyof ComponentsState>(\n  ctx: GlobalStateContext,\n  name: TKey,\n  component: ComponentsState[TKey],\n) {\n  ctx.dispatch((state) => ({\n    ...state,\n    components: withKey(state.components, name, component),\n  }));\n}\n\nexport function setErrorComponent<TKey extends keyof ErrorComponentsState>(\n  ctx: GlobalStateContext,\n  type: TKey,\n  component: ErrorComponentsState[TKey],\n) {\n  ctx.dispatch((state) => ({\n    ...state,\n    errorComponents: withKey(state.errorComponents, type, component),\n  }));\n}\n\nexport function setRoute<T = {}>(\n  ctx: GlobalStateContext,\n  path: string,\n  component: ComponentType<RouteComponentProps<T>>,\n) {\n  ctx.dispatch((state) => ({\n    ...state,\n    routes: withKey(state.routes, path, component),\n  }));\n}\n\nexport function includeProvider(ctx: GlobalStateContext, provider: JSX.Element) {\n  const wrapper: React.FC = (props) => cloneElement(provider, props);\n\n  ctx.dispatch((state) => ({\n    ...state,\n    provider: !state.provider ? wrapper : (props) => createElement(state.provider, undefined, wrapper(props)),\n  }));\n}\n\n// createGlobalState.ts\nexport function createGlobalState(customState: NestedPartial<GlobalState> = {}) {\n  const defaultState: GlobalState = {\n    app: {\n      error: undefined,\n      loading: typeof window !== 'undefined',\n      layout: 'desktop',\n    },\n    components: {\n      ErrorInfo: DefaultErrorInfo,\n      LoadingIndicator: DefaultLoadingIndicator,\n      Router: BrowserRouter,\n      Layout: DefaultLayout,\n    },\n    errorComponents: {},\n    registry: {\n      extensions: {},\n      pages: {},\n      wrappers: {},\n    },\n    routes: {},\n    data: {},\n    portals: {},\n    modules: [],\n  };\n\n  return Atom.of(extend(defaultState, customState));\n}\n")])])]),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[n._v("#")]),n._v(" 总结")]),n._v(" "),t("p",[n._v("微前端落地实践方案很多，想了解更多框架的同学，可以看这篇文章"),t("a",{attrs:{href:"https://blog.csdn.net/devolperfront/article/details/109233785",target:"_blank",rel:"noopener noreferrer"}},[n._v("2020 非常火的 11 个微前端框架"),t("OutboundLink")],1),n._v("。微前端的本质在于资源的隔离与共享，这里的颗粒度既可以是应用，也可以是模块，或者是自己定义的抽象层，这些都是为了更好的“高内聚，低耦合”。正如“软件工程中没有银弹”所说的那样，不存在一种通式通解能够一下解决所有问题，只有结合具体业务，选择合适的技术方案，才能最大限度的发挥架构的作用，切勿为了微而微！")]),n._v(" "),t("h2",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[n._v("#")]),n._v(" 参考")]),n._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/5qwgZ9aNKFC3naWRUGajmA",target:"_blank",rel:"noopener noreferrer"}},[n._v("【第1917期】微前端在小米 CRM 系统的实践"),t("OutboundLink")],1)]),n._v(" "),t("li",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/GjAHSvWqy70s50cwlr9udw",target:"_blank",rel:"noopener noreferrer"}},[n._v("基于 qiankun 的微前端最佳实践（万字长文） - 从 0 到 1 篇"),t("OutboundLink")],1)]),n._v(" "),t("li",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/OEfRPKuPmBKvJdD_zMgFuQ",target:"_blank",rel:"noopener noreferrer"}},[n._v("【PPT】@张克军：微前端架构体系"),t("OutboundLink")],1)]),n._v(" "),t("li",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/Zq2l0df-YOdpc2zNzTMXng",target:"_blank",rel:"noopener noreferrer"}},[n._v("【第1728期】每日优鲜供应链前端团队微前端改造"),t("OutboundLink")],1)]),n._v(" "),t("li",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/YuPGW9dosB2zfADASuMeIQ",target:"_blank",rel:"noopener noreferrer"}},[n._v("实施前端微服务化的六七种方式"),t("OutboundLink")],1)]),n._v(" "),t("li",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/WCAJ49K4mi7tO6teRCs3fA",target:"_blank",rel:"noopener noreferrer"}},[n._v("微前端自检清单"),t("OutboundLink")],1)]),n._v(" "),t("li",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/l0-uCLFRcBBrs4yTiAvryg",target:"_blank",rel:"noopener noreferrer"}},[n._v("【第2154期】EMP微前端解决方案"),t("OutboundLink")],1)]),n._v(" "),t("li",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/G0zC5xhDZ-QDLb2t1qCECg",target:"_blank",rel:"noopener noreferrer"}},[n._v("基于 qiankun 的微前端最佳实践（图文并茂） - 应用间通信篇"),t("OutboundLink")],1)]),n._v(" "),t("li",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/ochbPM5f84u-1BcNRXVOLA",target:"_blank",rel:"noopener noreferrer"}},[n._v("【第1789期】使用 Angular 打造微前端架构的 ToB 企业级应用"),t("OutboundLink")],1)]),n._v(" "),t("li",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/qMd6k9xSSNjskN3wB5PGgA",target:"_blank",rel:"noopener noreferrer"}},[n._v("【第1709期】可能是你见过最完善的微前端解决方案"),t("OutboundLink")],1)]),n._v(" "),t("li",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/l17Uo6Q7up44uZI_VojFzw",target:"_blank",rel:"noopener noreferrer"}},[n._v("微前端在美团外卖的实践"),t("OutboundLink")],1)]),n._v(" "),t("li",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/GgVo5KyZPlEsEeICcPyuLA",target:"_blank",rel:"noopener noreferrer"}},[n._v("Bifrost微前端框架及其在美团闪购中的实践"),t("OutboundLink")],1)]),n._v(" "),t("li",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/MgZGuthSv49qXWr_YBhyeQ",target:"_blank",rel:"noopener noreferrer"}},[n._v("爱奇艺号微前端架构实践"),t("OutboundLink")],1)]),n._v(" "),t("li",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/iLdAH9p2-S8pFyZrNzYaNg",target:"_blank",rel:"noopener noreferrer"}},[n._v("前端微服务在字节跳动的打磨与应用"),t("OutboundLink")],1)]),n._v(" "),t("li",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/DpFXTrQ3_kBX4EB6or4Q8Q",target:"_blank",rel:"noopener noreferrer"}},[n._v("用微前端的方式搭建类单页应用"),t("OutboundLink")],1)]),n._v(" "),t("li",[t("a",{attrs:{href:"https://www.infoq.cn/article/YH5mO2bVjmwLNYmXJeEP",target:"_blank",rel:"noopener noreferrer"}},[n._v("基于 React 的微前端：Piral 简析"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=r.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{240:function(e,s,n){"use strict";n.r(s);var r=n(0),t=Object(r.a)({},(function(){var e=this,s=e.$createElement,n=e._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"flexiwan项目踩坑实践（后端篇）"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#flexiwan项目踩坑实践（后端篇）"}},[e._v("#")]),e._v(" flexiwan项目踩坑实践（后端篇）")]),e._v(" "),n("h2",{attrs:{id:"项目背景"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#项目背景"}},[e._v("#")]),e._v(" 项目背景")]),e._v(" "),n("p",[e._v("flexiManage是以色列一家初创公司flexiWAN开源的基于SD-WAN平台的应用层的框架，包括"),n("a",{attrs:{href:"https://gitlab.com/flexiwangroup/fleximanage",target:"_blank",rel:"noopener noreferrer"}},[e._v("flexiManage"),n("OutboundLink")],1),e._v("服务端框架，基于此服务端框架进行了一些借鉴和改进")]),e._v(" "),n("p",[n("img",{attrs:{src:"/tech/back/flexiwan20201219/flexiwan01.jpg",alt:"图片"}})]),e._v(" "),n("h2",{attrs:{id:"目录结构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#目录结构"}},[e._v("#")]),e._v(" 目录结构")]),e._v(" "),n("ul",[n("li",[e._v("api")]),e._v(" "),n("li",[e._v("billing")]),e._v(" "),n("li",[e._v("bin")]),e._v(" "),n("li",[e._v("broker")]),e._v(" "),n("li",[e._v("controllers")]),e._v(" "),n("li",[e._v("deviceLogic")]),e._v(" "),n("li",[e._v("logging")]),e._v(" "),n("li",[e._v("logs")]),e._v(" "),n("li",[e._v("migrations")]),e._v(" "),n("li",[e._v("models")]),e._v(" "),n("li",[e._v("notifications")]),e._v(" "),n("li",[e._v("periodic")]),e._v(" "),n("li",[e._v("public")]),e._v(" "),n("li",[e._v("routes")]),e._v(" "),n("li",[e._v("services")]),e._v(" "),n("li",[e._v("utils")]),e._v(" "),n("li",[e._v("websocket")]),e._v(" "),n("li",[e._v("authenticate.js")]),e._v(" "),n("li",[e._v("configs.js")]),e._v(" "),n("li",[e._v("expressserver.js")]),e._v(" "),n("li",[e._v("flexibilling.js")]),e._v(" "),n("li",[e._v("mongoConns.js")]),e._v(" "),n("li",[e._v("rateLimitStore.js")]),e._v(" "),n("li",[e._v("token.js")])]),e._v(" "),n("h2",{attrs:{id:"踩坑案例"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#踩坑案例"}},[e._v("#")]),e._v(" 踩坑案例")]),e._v(" "),n("h3",{attrs:{id:"bff抹掉https的node模块验证"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#bff抹掉https的node模块验证"}},[e._v("#")]),e._v(" BFF抹掉https的node模块验证")]),e._v(" "),n("p",[e._v("[bug描述] 做验证使用服务端及硬件侧未配置ssl，而node启动https模块会默认验证ssl，导致无法启动服务")]),e._v(" "),n("p",[e._v("[bug分析] node模块的ssl验证")]),e._v(" "),n("p",[e._v("[解决方案] 起一层bff用于透传接口，后续方便将后续服务层进行微服务化等处理")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';\nconst express = require('express');\nconst request = require('request');\nconst app = express();\nconst bodyParser = require('body-parser');\nconst router = express.Router();\n\nconst SUCC_REG = /^2[0-9]{2}$/\n\napp.use(bodyParser.urlencoded({ extended: false }));\napp.use(bodyParser.json());\n\nconst headers = {\n            'authorization': \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI1ZmEzYTY5OGZjNDI2ODEwODc3MDYzZDQiLCJ1c2VybmFtZSI6Im1jYWlkYW9Ac2luYS5jb20iLCJvcmciOiI1ZmFkZTkyZDljNGQ2MDQyOWRjN2RhNmMiLCJvcmdOYW1lIjoidHQiLCJhY2NvdW50IjoiNWZhM2E2OThmYzQyNjgxMDg3NzA2M2QzIiwiYWNjb3VudE5hbWUiOiJ0ZXN0IiwicGVybXMiOnsiam9icyI6MTUsImJpbGxpbmciOjMsImFjY291bnRzIjo3LCJvcmdhbml6YXRpb25zIjoxNSwiZGV2aWNlcyI6MTUsInRva2VucyI6MTUsImFwcGlkZW50aWZpY2F0aW9ucyI6MTUsIm1lbWJlcnMiOjE1LCJ0dW5uZWxzIjoxNSwiYWNjZXNzdG9rZW5zIjoxNSwibm90aWZpY2F0aW9ucyI6MTUsInBhdGhsYWJlbHMiOjE1LCJtbHBvbGljaWVzIjoxNX0sImlhdCI6MTYwODExMjcwMiwiZXhwIjoxNjA4NzE3NTAyfQ.LYFv1pBP1540gb-NRCCe4dvbQ0T9HSoZHMkD8xkMFLc\",\n            'Content-Type': 'application/json'\n        },\n        errMsg = {\n            msg:'unexpected response'\n        },\n        baseUrl = 'https://10.100.37.101:3443';\n\n\n// 获取所有设备接口\napp.get('/api/devices',(req,res)=> {\n    console.log(req.url)\n    request({\n        url: `${baseUrl}${req.url}`,\n        method: 'GET',\n        headers\n    }, (err, response, body) => {\n        console.log(response.statusCode)\n        if(SUCC_REG.test(response.statusCode)) {\n            res.send({code: 200,msg:JSON.parse(response.body)})\n        } else {\n            res.send(errMsg)\n        }\n    })\n});\n\n// 获取单个设备接口\napp.get('/api/devices/:id',(req,res)=> {\n    console.log(req.url)\n    request({\n        url: `${baseUrl}${req.url}`,\n        method: 'GET',\n        headers\n    }, (err, response, body) => {\n        console.log(response.statusCode)\n        if(SUCC_REG.test(response.statusCode)) {\n            res.send({code: 200,msg:JSON.parse(response.body)})\n        } else {\n            res.send(errMsg)\n        }\n    })\n});\n\n// 获取路由接口\napp.get('/api/devices/:id/routes',(req,res)=> {\n    console.log(req.url)\n    request({\n        url: `https://10.100.37.101:3443/api/devices/${req.params.id}/routes`,\n        method: 'GET',\n        headers\n    }, (err, response, body) => {\n        console.log(response.statusCode)\n        if(SUCC_REG.test(response.statusCode)) {\n            res.send({code: 200,msg:JSON.parse(response.body)})\n        } else {\n            res.send(errMsg)\n        }\n    })\n});\n\n// 启动单个设备\napp.post('/api/devices/:id/apply/start',(req,res)=> {\n    console.log(req.url);\n    request({\n        url: `${baseUrl}/api/devices/${req.params.id}/apply`,\n        method: 'POST',\n        headers,\n        body: JSON.stringify({\n            \"method\": \"start\"\n        })\n    }, (err, response, body) => {\n        let r = JSON.parse(body)\n        if(r.status == 'completed') {\n            res.send({code: 200,msg:'start success'})\n        } else {\n            res.send({msg: 'start error'})\n        }\n    })\n});\n\n// 停止单个设备\napp.post('/api/devices/:id/apply/stop',(req,res)=> {\n    console.log(req.url)\n    request({\n        url: `${baseUrl}/api/devices/${req.params.id}/apply`,\n        method: 'POST',\n        headers,\n        body: JSON.stringify({\n            \"method\": \"stop\"\n        })\n    }, (err, response, body) => {\n        let r = JSON.parse(body)\n        if(r.status == 'completed') {\n            res.send({code: 200,msg:'stop success'})\n        } else {\n            res.send({msg: 'stop error'})\n        }\n    })\n});\n\n// 同步单个设备\napp.post('/api/devices/:id/apply',(req,res)=> {\n    console.log(req.url)\n    request.post({\n        url: `${baseUrl}${req.url}`,\n        headers,\n        body: JSON.stringify({\n            \"method\": \"sync\"\n        })\n    }, (err, response, body) => {\n        let r = JSON.parse(body)\n        if(r.status == 'completed') {\n            res.send({code: 200,msg:'update success'})\n        } else {\n            res.send({msg: 'update error'})\n        }\n    })\n});\n\n// 删除单个设备\napp.delete('/api/devices/:id',(req,res)=> {\n    console.log(req.url)\n    request({\n        url: `${baseUrl}${req.url}`,\n        method: 'DELETE',\n        headers\n    }, (err, response, body) => {\n        console.log(response.statusCode)\n        if(SUCC_REG.test(response.statusCode)) {\n            res.send({code: 200,msg:JSON.parse(response.body)})\n        } else {\n            res.send(errMsg)\n        }\n    })\n});\n\n// 更新设备详情\napp.put('/api/devices/:id',(req,res)=> {\n    request({\n        url: `${baseUrl}${req.url}`,\n        method: 'PUT',\n        headers,\n        body: JSON.stringify(req.body)\n    }, (err, response, body) => {\n        console.log('put device', response.statusCode)\n        if(SUCC_REG.test(response.statusCode)) {\n            res.send({code: 200,msg:JSON.parse(response.body)})\n        } else {\n            res.send(errMsg)\n            console.log('error device', response.statusCode, response.body)\n        }\n    })\n});\n\n// 删除隧道接口\napp.post('/api/devices/apply/delTunnel',(req,res)=> {\n    console.log('req.body', req.body)\n    request.post({\n        url: `${baseUrl}/api/devices/apply`,\n        headers,\n        body: JSON.stringify(req.body)\n    }, (err, response, body) => {\n        let r = JSON.parse(body)\n        console.log(r)\n        if(r.status == 'completed') {\n            res.send({code: 200,msg:'删除隧道成功'})\n        } else {\n            res.send({msg: r.error})\n        }\n    })\n});\n\n// 建立隧道接口\napp.post('/api/devices/apply/createTunnel',(req,res)=> {\n    console.log(req.body)\n    request.post({\n        url: `${baseUrl}/api/devices/apply`,\n        headers,\n        body: JSON.stringify(req.body)\n    }, (err, response, body) => {\n        let r = JSON.parse(body)\n        console.log(r)\n        if(r.status == 'completed') {\n            res.send({code: 200,msg:r.message})\n        } else {\n            res.send({msg: r.error})\n        }\n    })\n});\n\n\n\n// 获取所有隧道接口\napp.get('/api/tunnels',(req,res)=> {\n    console.log(req.url)\n    request({\n        url: `${baseUrl}${req.url}`,\n        method: 'GET',\n        headers\n    }, (err, response, body) => {\n        console.log(response.statusCode)\n        if(SUCC_REG.test(response.statusCode)) {\n            res.send({code: 200,msg:JSON.parse(response.body)})\n        } else {\n            res.send(errMsg)\n        }\n    })\n});\n\napp.listen(6000, '127.0.0.1', ()=>{\n    console.log('app server');\n});\n")])])]),n("h3",{attrs:{id:"express请求接口请求体不同无法匹配"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#express请求接口请求体不同无法匹配"}},[e._v("#")]),e._v(" express请求接口请求体不同无法匹配")]),e._v(" "),n("p",[n("img",{attrs:{src:"/tech/back/flexiwan20201219/flexiwan02.jpg",alt:"图片"}})]),e._v(" "),n("p",[e._v("[bug描述] express实例中同样post请求，只是body体不同而导致无法区分，从而覆盖后续接口")]),e._v(" "),n("p",[e._v("[bug分析] express的中间件原理，在加载路由过程正则匹配后不会匹配body体")]),e._v(" "),n("p",[e._v("[解决方案] 区分路由接口，通过request转发或加上路由模块区分")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 启动单个设备\napp.post('/api/devices/:id/apply/start',(req,res)=> {\n    console.log(req.url);\n    request({\n        url: `${baseUrl}/api/devices/${req.params.id}/apply`,\n        method: 'POST',\n        headers,\n        body: JSON.stringify({\n            \"method\": \"start\"\n        })\n    }, (err, response, body) => {\n        let r = JSON.parse(body)\n        if(r.status == 'completed') {\n            res.send({code: 200,msg:'start success'})\n        } else {\n            res.send({msg: 'start error'})\n        }\n    })\n});\n\n// 停止单个设备\napp.post('/api/devices/:id/apply/stop',(req,res)=> {\n    console.log(req.url)\n    request({\n        url: `${baseUrl}/api/devices/${req.params.id}/apply`,\n        method: 'POST',\n        headers,\n        body: JSON.stringify({\n            \"method\": \"stop\"\n        })\n    }, (err, response, body) => {\n        let r = JSON.parse(body)\n        if(r.status == 'completed') {\n            res.send({code: 200,msg:'stop success'})\n        } else {\n            res.send({msg: 'stop error'})\n        }\n    })\n});\n")])])]),n("h2",{attrs:{id:"源码解析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#源码解析"}},[e._v("#")]),e._v(" 源码解析")]),e._v(" "),n("p",[n("img",{attrs:{src:"/tech/back/flexiwan20201219/flexiwan03.jpg",alt:"图片"}})]),e._v(" "),n("p",[e._v("主要是以express为核心的node应用，封装了express的基类进行实例，配合websocket进行实时数据的连接，redis的输出消费存储")]),e._v(" "),n("h3",{attrs:{id:"expressserver"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#expressserver"}},[e._v("#")]),e._v(" expressserver")]),e._v(" "),n("p",[n("img",{attrs:{src:"/tech/back/flexiwan20201219/flexiwan04.jpg",alt:"图片"}})]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class ExpressServer {\n  constructor (port, securePort, openApiYaml) {\n    this.port = port;\n    this.securePort = securePort;\n    this.app = express();\n    this.openApiPath = openApiYaml;\n    this.schema = yamljs.load(openApiYaml);\n    const restServerUrl = configs.get('restServerUrl');\n    const servers = this.schema.servers.filter(server => server.url.includes(restServerUrl));\n    if (servers.length === 0) {\n      this.schema.servers.unshift({\n        description: 'Local Server',\n        url: restServerUrl + '/api'\n      });\n    }\n\n    this.setupMiddleware = this.setupMiddleware.bind(this);\n    this.addErrorHandler = this.addErrorHandler.bind(this);\n    this.onError = this.onError.bind(this);\n    this.onListening = this.onListening.bind(this);\n    this.launch = this.launch.bind(this);\n    this.close = this.close.bind(this);\n\n    this.setupMiddleware();\n  }\n\n  setupMiddleware () {\n    // this.setupAllowedMedia();\n    this.app.use((req, res, next) => {\n      console.log(`${req.method}: ${req.url}`);\n      return next();\n    });\n\n    // Request logging middleware - must be defined before routers.\n    this.app.use(reqLogger);\n    this.app.set('trust proxy', true); // Needed to get the public IP if behind a proxy\n\n    // Don't expose system internals in response headers\n    this.app.disable('x-powered-by');\n\n    // Use morgan request logger in development mode\n    if (configs.get('environment') === 'development') this.app.use(morgan('dev'));\n\n    // Start periodic device tasks\n    deviceStatus.start();\n    deviceQueues.start();\n    deviceSwVersion.start();\n    deviceSwUpgrade.start();\n    notifyUsers.start();\n    appRules.start();\n\n    // Secure traffic only\n    this.app.all('*', (req, res, next) => {\n      // Allow Let's encrypt certbot to access its certificate dirctory\n      if (!configs.get('shouldRedirectHttps') ||\n          req.secure || req.url.startsWith('/.well-known/acme-challenge')) {\n        return next();\n      } else {\n        return res.redirect(\n          307, 'https://' + req.hostname + ':' + configs.get('redirectHttpsPort') + req.url\n        );\n      }\n    });\n\n    // Global rate limiter to protect against DoS attacks\n    // Windows size of 5 minutes\n    const inMemoryStore = new RateLimitStore(5 * 60 * 1000);\n    const rateLimiter = rateLimit({\n      store: inMemoryStore,\n      max: +configs.get('userIpReqRateLimit'), // Rate limit for requests in 5 min per IP address\n      message: 'Request rate limit exceeded',\n      onLimitReached: (req, res, options) => {\n        logger.error(\n          'Request rate limit exceeded. blocking request', {\n            params: { ip: req.ip },\n            req: req\n          });\n      }\n    });\n    this.app.use(rateLimiter);\n\n    // General settings here\n    this.app.use(cors.cors);\n    this.app.use(bodyParser.json());\n    this.app.use(express.json());\n    this.app.use(express.urlencoded({ extended: false }));\n    this.app.use(cookieParser());\n\n    // Routes allowed without authentication\n    this.app.use(express.static(path.join(__dirname, configs.get('clientStaticDir'))));\n\n    // Secure traffic only\n    this.app.all('*', (req, res, next) => {\n      // Allow Let's encrypt certbot to access its certificate dirctory\n      if (!configs.get('shouldRedirectHttps') ||\n          req.secure || req.url.startsWith('/.well-known/acme-challenge')) {\n        return next();\n      } else {\n        return res.redirect(\n          307, 'https://' + req.hostname + ':' + configs.get('redirectHttpsPort') + req.url\n        );\n      }\n    });\n\n    // no authentication\n    this.app.use('/api/connect', require('./routes/connect'));\n    this.app.use('/api/users', require('./routes/users'));\n\n    // add API documentation\n    this.app.use('/api-docs', swaggerUI.serve, swaggerUI.setup(this.schema));\n\n    // initialize passport and authentication\n    this.app.use(passport.initialize());\n\n    // Enable db admin only in development mode\n    if (configs.get('environment') === 'development') {\n      logger.warn('Warning: Enabling UI database access');\n      this.app.use('/admindb', mongoExpress(mongoExpressConfig));\n    }\n\n    // Enable routes for non-authorized links\n    this.app.use('/ok', express.static(path.join(__dirname, 'public', 'ok.html')));\n    this.app.use('/spec', express.static(path.join(__dirname, 'api', 'openapi.yaml')));\n    this.app.get('/hello', (req, res) => res.send('Hello World'));\n\n    this.app.get('/api/version', (req, res) => res.json({ version }));\n\n    this.app.use(cors.corsWithOptions);\n    this.app.use(auth.verifyUserJWT);\n    // this.app.use(auth.verifyPermission);\n\n    try {\n      // FIXME: temporary map the OLD routes\n      // this.app.use('/api/devices', require('./routes/devices'));\n      // this.app.use('/api/devicestats', require('./routes/deviceStats'));\n      // this.app.use('/api/jobs', require('./routes/deviceQueue'));\n      this.app.use('/api/portals', require('./routes/portals'));\n    } catch (error) {\n      logger.error('Error: Can\\'t connect OLD routes');\n    }\n\n    // Intialize routes\n    this.app.use('/api/admin', adminRouter);\n\n    const validator = new OpenApiValidator({\n      apiSpec: this.openApiPath,\n      validateRequests: true,\n      validateResponses: configs.get('validateOpenAPIResponse')\n    });\n\n    validator\n      .install(this.app)\n      .then(async () => {\n        await this.app.use(openapiRouter());\n        await this.launch();\n        logger.info('Express server running');\n      });\n  }\n\n  addErrorHandler () {\n    // \"catchall\" handler, for any request that doesn't match one above, send back index.html file.\n    this.app.get('*', (req, res, next) => {\n      logger.info('Route not found', { req: req });\n      res.sendFile(path.join(__dirname, configs.get('clientStaticDir'), 'index.html'));\n    });\n\n    // catch 404 and forward to error handler\n    this.app.use(function (req, res, next) {\n      next(createError(404));\n    });\n\n    // Request error logger - must be defined after all routers\n    // Set log severity on the request to log errors only for 5xx status codes.\n    this.app.use((err, req, res, next) => {\n      req.logSeverity = err.status || 500;\n      next(err);\n    });\n    this.app.use(errLogger);\n\n    /**\n     * suppressed eslint rule: The next variable is required here, even though it's not used.\n     *\n     ** */\n    // eslint-disable-next-line no-unused-vars\n    this.app.use((error, req, res, next) => {\n      const errorResponse = error.error || error.message || error.errors || 'Unknown error';\n      res.status(error.status || 500);\n      res.type('json');\n      res.json({ error: errorResponse });\n    });\n  }\n\n  /**\n   * Event listener for HTTP/HTTPS server \"error\" event.\n   */\n  onError (port) {\n    return function (error) {\n      if (error.syscall !== 'listen') {\n        throw error;\n      }\n\n      const bind = 'Port ' + port;\n\n      // handle specific listen errors with friendly messages\n      /* eslint-disable no-unreachable */\n      switch (error.code) {\n        case 'EACCES':\n          console.error(bind + ' requires elevated privileges');\n          process.exit(1);\n        case 'EADDRINUSE':\n          console.error(bind + ' is already in use');\n          process.exit(1);\n        default:\n          throw error;\n      }\n    };\n  }\n\n  /**\n  * Event listener for HTTP server \"listening\" event.\n  */\n  onListening (server) {\n    return function () {\n      const addr = server.address();\n      const bind = typeof addr === 'string' ? 'pipe ' + addr : 'port ' + addr.port;\n      console.debug('Listening on ' + bind);\n    };\n  }\n\n  async launch () {\n    this.addErrorHandler();\n\n    try {\n      this.server = http.createServer(this.app);\n\n      this.options = {\n        key: fs.readFileSync(path.join(__dirname, 'bin', configs.get('httpsCertKey'))),\n        cert: fs.readFileSync(path.join(__dirname, 'bin', configs.get('httpsCert')))\n      };\n      this.secureServer = https.createServer(this.options, this.app);\n\n      // setup wss here\n      this.wss = new WebSocket.Server({\n        server: configs.get('shouldRedirectHttps') ? this.secureServer : this.server,\n        verifyClient: connections.verifyDevice\n      });\n\n      connections.registerConnectCallback('broker', broker.deviceConnectionOpened);\n      connections.registerCloseCallback('broker', broker.deviceConnectionClosed);\n      connections.registerCloseCallback('deviceStatus', deviceStatus.deviceConnectionClosed);\n\n      this.wss.on('connection', connections.createConnection);\n      console.log('Websocket server running');\n\n      this.server.listen(this.port, () => {\n        console.log('HTTP server listening on port', { params: { port: this.port } });\n      });\n      this.server.on('error', this.onError(this.port));\n      this.server.on('listening', this.onListening(this.server));\n\n      this.secureServer.listen(this.securePort, () => {\n        console.log('HTTPS server listening on port', { params: { port: this.securePort } });\n      });\n      this.secureServer.on('error', this.onError(this.securePort));\n      this.secureServer.on('listening', this.onListening(this.secureServer));\n    } catch (error) {\n      console.log('Express server lunch error', { params: { message: error.message } });\n    }\n  }\n\n  async close () {\n    if (this.server !== undefined) {\n      await this.server.close();\n      console.log(`HTTP Server on port ${this.port} shut down`);\n    }\n    if (this.secureServer !== undefined) {\n      await this.secureServer.close();\n      console.log(`HTTPS Server on port ${this.securePort} shut down`);\n    }\n  }\n}\n")])])]),n("p",[e._v("封装了一个express的基类，主要包含中间件的处理、错误处理、监听server")]),e._v(" "),n("h2",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),n("p",[e._v("基于express封装的扩展应用，主要利用的是express的中间件原理，可以同类类比nest.js，其核心也是基于express封装的应用，但nest.js基于ng的模块思想做的隔离性更好，更像是服务端的一种node版的spring框架，而本应用确实还是像express的node应用，略显冗余")])])}),[],!1,null,null,null);s.default=t.exports}}]);
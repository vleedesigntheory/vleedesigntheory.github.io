(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{290:function(n,e,t){"use strict";t.r(e);var i=t(0),s=Object(i.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"umi3源码探究简析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#umi3源码探究简析"}},[n._v("#")]),n._v(" umi3源码探究简析")]),n._v(" "),t("h2",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[n._v("#")]),n._v(" 前言")]),n._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/umi20210222/umi01.png",alt:"图片"}})]),n._v(" "),t("p",[n._v("近期，团(ling)队(dao)准(yao)备(qiu)从Vue技术栈转向React技术栈，而且特别指定了使用Ant Design的设计组件库，出于相关生态考虑，我们决定采用蚂蚁金服团队相关react方案。选择理由如下：一来是React原装全家桶比较散，引包组装比较麻烦；二来是国内React生态相关方面阿里开源及社区做的比较突出，因而我们决定使用阿里React相关技术栈。基于组件库及相关可视化展示等因素，我们选择了蚂蚁金服团队的开源生态圈：umi + dva + antd + antv ( ps：最佳实践案例是"),t("a",{attrs:{href:"https://pro.ant.design",target:"_blank",rel:"noopener noreferrer"}},[n._v("Ant Desgin Pro"),t("OutboundLink")],1),n._v(")，当然淘系的飞冰相关React技术栈做的也很突出，但权衡之后，我们最终还是选择了蚂蚁金服团队的React技术栈。作为整个生态圈最为核心的部分，umi可谓是王冠上的红宝石，因而个人认为对于整个umi架构内核的学习及设计哲学的理解，可能比如何使用要来的更为重要；作为一个使用者，希望能从各位大佬的源码中汲取一些养分以及获得一些灵感，私以为：思想的拓展要远比不断地重复劳作要来的重要！")]),n._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/umi20210222/umi02.png",alt:"图片"}})]),n._v(" "),t("p",[n._v("umi基于的是一种微内核架构方式，其核心是只保留架构的核心功能，将其他需求服务以插件的形式载入进来，“即插即用，不用即走”，因而又称为“插件化架构”，对于想具体了解微内核的童鞋，可以看这篇文章"),t("a",{attrs:{href:"https://blog.csdn.net/lz710117239/article/details/86603811",target:"_blank",rel:"noopener noreferrer"}},[n._v("微内核架构"),t("OutboundLink")],1),n._v("，总结来讲就是“如无必要，勿增实体”，只保留最精简、最核心的部分。")]),n._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/umi20210222/umi03.png",alt:"图片"}})]),n._v(" "),t("p",[n._v("对于umi来说，其具体是通过“约定大于配置”的核心理念，将技术收敛，让开发者更集中精力于业务的开发，对于更具体的可以看看云谦(陈成)的大佬2019 SEE Conf的分享 "),t("a",{attrs:{href:"https://www.bilibili.com/video/av40319780/",target:"_blank",rel:"noopener noreferrer"}},[n._v("云谦 - 蚂蚁金服前端框架探索之路"),t("OutboundLink")],1)]),n._v(" "),t("h2",{attrs:{id:"目录结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#目录结构"}},[n._v("#")]),n._v(" 目录结构")]),n._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/umi20210222/umi04.png",alt:"图片"}})]),n._v(" "),t("p",[n._v("本质上umi最后会导出一个基于EventEmitter的Service的类，用户通过Config中的配置将插件与核心Service关联，umi将react-router和react-router-dom内嵌进了框架中，从而可以“约定式定义路由”，此处可以对比Next.js的方案")]),n._v(" "),t("ul",[t("li",[n._v("packages\n"),t("ul",[t("li",[n._v("ast")]),n._v(" "),t("li",[n._v("babel-plugin-auto-css-modules")]),n._v(" "),t("li",[n._v("babel-plugin-import-to-await-require")]),n._v(" "),t("li",[n._v("babel-plugin-lock-core-js-3")]),n._v(" "),t("li",[n._v("babel-preset-umi")]),n._v(" "),t("li",[n._v("bundler-utils")]),n._v(" "),t("li",[n._v("bundler-webpack")]),n._v(" "),t("li",[n._v("core\n"),t("ul",[t("li",[n._v("src\n"),t("ul",[t("li",[n._v("Config")]),n._v(" "),t("li",[n._v("Html")]),n._v(" "),t("li",[n._v("Logger")]),n._v(" "),t("li",[n._v("Route")]),n._v(" "),t("li",[n._v("Service")])])])])]),n._v(" "),t("li",[n._v("create-umi-app")]),n._v(" "),t("li",[n._v("preset-built-in")]),n._v(" "),t("li",[n._v("renderer-mpa")]),n._v(" "),t("li",[n._v("renderer-react")]),n._v(" "),t("li",[n._v("runtime")]),n._v(" "),t("li",[n._v("server")]),n._v(" "),t("li",[n._v("test")]),n._v(" "),t("li",[n._v("test-utils")]),n._v(" "),t("li",[n._v("types")]),n._v(" "),t("li",[n._v("umi")]),n._v(" "),t("li",[n._v("utils")])])])]),n._v(" "),t("h2",{attrs:{id:"源码解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#源码解析"}},[n._v("#")]),n._v(" 源码解析")]),n._v(" "),t("p",[n._v("核心源码在于core目录下的Config、Route及Service，微内核中最最最核心的就是这个Service类，其他都是基于其进行的相关的扩展与融合，重点分析Service、Route及Config这三个目录中的源码")]),n._v(" "),t("h3",{attrs:{id:"service"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#service"}},[n._v("#")]),n._v(" Service")]),n._v(" "),t("table",[t("thead",[t("tr",[t("th",{staticStyle:{"text-align":"left"}},[n._v("文件名")]),n._v(" "),t("th",{staticStyle:{"text-align":"center"}},[n._v("作用")]),n._v(" "),t("th",{staticStyle:{"text-align":"right"}},[n._v("备注")])])]),n._v(" "),t("tbody",[t("tr",[t("td",{staticStyle:{"text-align":"left"}},[n._v("Service.ts")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("提供整个核心服务类，用于导出服务")]),n._v(" "),t("td",{staticStyle:{"text-align":"right"}},[n._v("核心配置")])]),n._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[n._v("getPaths.ts")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("获取文件绝对路径的核心方法")]),n._v(" "),t("td",{staticStyle:{"text-align":"right"}},[n._v("文件路径")])]),n._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[n._v("PluginAPI.ts")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("插件的注册及接入核心类")]),n._v(" "),t("td",{staticStyle:{"text-align":"right"}},[n._v("插件注册")])]),n._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[n._v("types.ts")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("固定值")]),n._v(" "),t("td",{staticStyle:{"text-align":"right"}},[n._v("接口及类型")])]),n._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[n._v("enums.ts")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("固定值")]),n._v(" "),t("td",{staticStyle:{"text-align":"right"}},[n._v("枚举")])])])]),n._v(" "),t("h4",{attrs:{id:"service-ts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#service-ts"}},[n._v("#")]),n._v(" Service.ts")]),n._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/umi20210222/umi05.png",alt:"图片"}})]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("export default class Service extends EventEmitter {\n  // 项目根路径\n  cwd: string;\n  // package.json的绝对路径\n  pkg: IPackage;\n  // 跳过的插件\n  skipPluginIds: Set<string> = new Set<string>();\n  // 生命周期执行阶段\n  stage: ServiceStage = ServiceStage.uninitialized;\n  // 注册命令\n  commands: {\n    [name: string]: ICommand | string;\n  } = {};\n  // 解析完的插件\n  plugins: {\n    [id: string]: IPlugin;\n  } = {};\n  // 插件方法\n  pluginMethods: {\n    [name: string]: Function;\n  } = {};\n  // 初始化插件预设\n  initialPresets: IPreset[];\n  initialPlugins: IPlugin[];\n  // 额外的插件预设\n  _extraPresets: IPreset[] = [];\n  _extraPlugins: IPlugin[] = [];\n  // 用户配置\n  userConfig: IConfig;\n  configInstance: Config;\n  config: IConfig | null = null;\n  // babel处理\n  babelRegister: BabelRegister;\n  // 钩子函数处理\n  hooksByPluginId: {\n    [id: string]: IHook[];\n  } = {};\n  hooks: {\n    [key: string]: IHook[];\n  } = {};\n  // 用户配置生成的路径信息\n  paths: {\n\t// 项目根目录\n    cwd?: string;\n\t// node_modules文件目录\n    absNodeModulesPath?: string;\n\t// src目录\n    absSrcPath?: string;\n\t// pages目录\n    absPagesPath?: string;\n\t// dist导出目录\n    absOutputPath?: string;\n\t// 生成的.umi目录\n    absTmpPath?: string;\n  } = {};\n  env: string | undefined;\n  ApplyPluginsType = ApplyPluginsType;\n  EnableBy = EnableBy;\n  ConfigChangeType = ConfigChangeType;\n  ServiceStage = ServiceStage;\n  args: any;\n\n  constructor(opts: IServiceOpts) {\n    super();\n    this.cwd = opts.cwd || process.cwd();\n    // 仓库根目录，antd pro构建的时候需要一个新的空文件夹\n    this.pkg = opts.pkg || this.resolvePackage();\n    this.env = opts.env || process.env.NODE_ENV;\n\n    // babel处理\n    this.babelRegister = new BabelRegister();\n\n    // 加载环境变量\n    this.loadEnv();\n\n    // 获取用户配置\n    this.configInstance = new Config({\n      cwd: this.cwd,\n      service: this,\n      localConfig: this.env === 'development',\n    });\n\n\t// 从.umirc.ts中获取内容\n    this.userConfig = this.configInstance.getUserConfig();\n\n    // 获取导出的配置\n    this.paths = getPaths({\n      cwd: this.cwd,\n      config: this.userConfig!,\n      env: this.env,\n    });\n\n    // 初始化插件\n    const baseOpts = {\n      pkg: this.pkg,\n      cwd: this.cwd,\n    };\n\n\t// 初始化预设\n    this.initialPresets = resolvePresets({\n      ...baseOpts,\n      presets: opts.presets || [],\n      userConfigPresets: this.userConfig.presets || [],\n    });\n\n\t// 初始化插件\n    this.initialPlugins = resolvePlugins({\n      ...baseOpts,\n      plugins: opts.plugins || [],\n      userConfigPlugins: this.userConfig.plugins || [],\n    });\n\n\t// 初始化配置及插件放入babel注册中\n    this.babelRegister.setOnlyMap({\n      key: 'initialPlugins',\n      value: lodash.uniq([\n        ...this.initialPresets.map(({ path }) => path),\n        ...this.initialPlugins.map(({ path }) => path),\n      ]),\n    });\n  }\n  // 设置生命周期\n  setStage(stage: ServiceStage) {\n    this.stage = stage;\n  }\n  // 解析package.json的文件\n  resolvePackage() {\n    try {\n      return require(join(this.cwd, 'package.json'));\n    } catch (e) {\n      return {};\n    }\n  }\n  // 加载环境\n  loadEnv() {\n    const basePath = join(this.cwd, '.env');\n    const localPath = `${basePath}.local`;\n    loadDotEnv(basePath);\n    loadDotEnv(localPath);\n  }\n\n  // 真正的初始化\n  async init() {\n    this.setStage(ServiceStage.init);\n    await this.initPresetsAndPlugins();\n\n\t// 状态：初始\n    this.setStage(ServiceStage.initHooks);\n\n\t// 注册了plugin要执行的钩子方法\n    Object.keys(this.hooksByPluginId).forEach((id) => {\n      const hooks = this.hooksByPluginId[id];\n      hooks.forEach((hook) => {\n        const { key } = hook;\n        hook.pluginId = id;\n        this.hooks[key] = (this.hooks[key] || []).concat(hook);\n      });\n    });\n\n    // 状态：插件已注册\n    this.setStage(ServiceStage.pluginReady);\n\t// 执行插件\n    await this.applyPlugins({\n      key: 'onPluginReady',\n      type: ApplyPluginsType.event,\n    });\n\n    // 状态：获取配置信息\n    this.setStage(ServiceStage.getConfig);\n\n\t// 拿到对应插件的默认配置信息\n    const defaultConfig = await this.applyPlugins({\n      key: 'modifyDefaultConfig',\n      type: this.ApplyPluginsType.modify,\n      initialValue: await this.configInstance.getDefaultConfig(),\n    });\n\n\t// 将实例中的配置信息对应修改的配置信息\n    this.config = await this.applyPlugins({\n      key: 'modifyConfig',\n      type: this.ApplyPluginsType.modify,\n      initialValue: this.configInstance.getConfig({\n        defaultConfig,\n      }) as any,\n    });\n\n    // 状态：合并路径\n    this.setStage(ServiceStage.getPaths);\n    \n    if (this.config!.outputPath) {\n      this.paths.absOutputPath = join(this.cwd, this.config!.outputPath);\n    }\n\n\t// 修改路径对象\n    const paths = (await this.applyPlugins({\n      key: 'modifyPaths',\n      type: ApplyPluginsType.modify,\n      initialValue: this.paths,\n    })) as object;\n    Object.keys(paths).forEach((key) => {\n      this.paths[key] = paths[key];\n    });\n  }\n\n  \n  async initPresetsAndPlugins() {\n    this.setStage(ServiceStage.initPresets);\n    this._extraPlugins = [];\n    while (this.initialPresets.length) {\n      await this.initPreset(this.initialPresets.shift()!);\n    }\n\n    this.setStage(ServiceStage.initPlugins);\n    this._extraPlugins.push(...this.initialPlugins);\n    while (this._extraPlugins.length) {\n      await this.initPlugin(this._extraPlugins.shift()!);\n    }\n  }\n\n  getPluginAPI(opts: any) {\n    const pluginAPI = new PluginAPI(opts);\n\n    [\n      'onPluginReady',\n      'modifyPaths',\n      'onStart',\n      'modifyDefaultConfig',\n      'modifyConfig',\n    ].forEach((name) => {\n      pluginAPI.registerMethod({ name, exitsError: false });\n    });\n\n    return new Proxy(pluginAPI, {\n      get: (target, prop: string) => {\n        // 由于 pluginMethods 需要在 register 阶段可用\n        // 必须通过 proxy 的方式动态获取最新，以实现边注册边使用的效果\n        if (this.pluginMethods[prop]) return this.pluginMethods[prop];\n        if (\n          [\n            'applyPlugins',\n            'ApplyPluginsType',\n            'EnableBy',\n            'ConfigChangeType',\n            'babelRegister',\n            'stage',\n            'ServiceStage',\n            'paths',\n            'cwd',\n            'pkg',\n            'userConfig',\n            'config',\n            'env',\n            'args',\n            'hasPlugins',\n            'hasPresets',\n          ].includes(prop)\n        ) {\n          return typeof this[prop] === 'function'\n            ? this[prop].bind(this)\n            : this[prop];\n        }\n        return target[prop];\n      },\n    });\n  }\n\n  async applyAPI(opts: { apply: Function; api: PluginAPI }) {\n    let ret = opts.apply()(opts.api);\n    if (isPromise(ret)) {\n      ret = await ret;\n    }\n    return ret || {};\n  }\n\n  // 初始化配置\n  async initPreset(preset: IPreset) {\n    const { id, key, apply } = preset;\n    preset.isPreset = true;\n\n    const api = this.getPluginAPI({ id, key, service: this });\n\n    // register before apply\n    this.registerPlugin(preset);\n    // TODO: ...defaultConfigs 考虑要不要支持，可能这个需求可以通过其他渠道实现\n    const { presets, plugins, ...defaultConfigs } = await this.applyAPI({\n      api,\n      apply,\n    });\n\n    // register extra presets and plugins\n    if (presets) {\n      assert(\n        Array.isArray(presets),\n        `presets returned from preset ${id} must be Array.`,\n      );\n      // 插到最前面，下个 while 循环优先执行\n      this._extraPresets.splice(\n        0,\n        0,\n        ...presets.map((path: string) => {\n          return pathToObj({\n            type: PluginType.preset,\n            path,\n            cwd: this.cwd,\n          });\n        }),\n      );\n    }\n\n    // 深度优先\n    const extraPresets = lodash.clone(this._extraPresets);\n    this._extraPresets = [];\n    while (extraPresets.length) {\n      await this.initPreset(extraPresets.shift()!);\n    }\n\n    if (plugins) {\n      assert(\n        Array.isArray(plugins),\n        `plugins returned from preset ${id} must be Array.`,\n      );\n      this._extraPlugins.push(\n        ...plugins.map((path: string) => {\n          return pathToObj({\n            type: PluginType.plugin,\n            path,\n            cwd: this.cwd,\n          });\n        }),\n      );\n    }\n  }\n\n  // 初始化插件\n  async initPlugin(plugin: IPlugin) {\n    const { id, key, apply } = plugin;\n\n    const api = this.getPluginAPI({ id, key, service: this });\n\n    // register before apply\n    this.registerPlugin(plugin);\n    await this.applyAPI({ api, apply });\n  }\n\n  getPluginOptsWithKey(key: string) {\n    return getUserConfigWithKey({\n      key,\n      userConfig: this.userConfig,\n    });\n  }\n\n  // 注册插件\n  registerPlugin(plugin: IPlugin) {\n    // 考虑要不要去掉这里的校验逻辑\n    // 理论上不会走到这里，因为在 describe 的时候已经做了冲突校验\n    if (this.plugins[plugin.id]) {\n      const name = plugin.isPreset ? 'preset' : 'plugin';\n      throw new Error(`\\\n${name} ${plugin.id} is already registered by ${this.plugins[plugin.id].path}, \\\n${name} from ${plugin.path} register failed.`);\n    }\n    this.plugins[plugin.id] = plugin;\n  }\n\n  isPluginEnable(pluginId: string) {\n    // api.skipPlugins() 的插件\n    if (this.skipPluginIds.has(pluginId)) return false;\n\n    const { key, enableBy } = this.plugins[pluginId];\n\n    // 手动设置为 false\n    if (this.userConfig[key] === false) return false;\n\n    // 配置开启\n    if (enableBy === this.EnableBy.config && !(key in this.userConfig)) {\n      return false;\n    }\n\n    // 函数自定义开启\n    if (typeof enableBy === 'function') {\n      return enableBy();\n    }\n\n    // 注册开启\n    return true;\n  }\n\n  // 判断函数：是否有插件\n  hasPlugins(pluginIds: string[]) {\n    return pluginIds.every((pluginId) => {\n      const plugin = this.plugins[pluginId];\n      return plugin && !plugin.isPreset && this.isPluginEnable(pluginId);\n    });\n  }\n\n  // 判断函数：是否有预设\n  hasPresets(presetIds: string[]) {\n    return presetIds.every((presetId) => {\n      const preset = this.plugins[presetId];\n      return preset && preset.isPreset && this.isPluginEnable(presetId);\n    });\n  }\n\n  // 真正的插件执行函数，基于promise实现\n  async applyPlugins(opts: {\n    key: string;\n    type: ApplyPluginsType;\n    initialValue?: any;\n    args?: any;\n  }) {\n    const hooks = this.hooks[opts.key] || [];\n    switch (opts.type) {\n      case ApplyPluginsType.add:\n        if ('initialValue' in opts) {\n          assert(\n            Array.isArray(opts.initialValue),\n            `applyPlugins failed, opts.initialValue must be Array if opts.type is add.`,\n          );\n        }\n        const tAdd = new AsyncSeriesWaterfallHook(['memo']);\n        for (const hook of hooks) {\n          if (!this.isPluginEnable(hook.pluginId!)) {\n            continue;\n          }\n          tAdd.tapPromise(\n            {\n              name: hook.pluginId!,\n              stage: hook.stage || 0,\n              // @ts-ignore\n              before: hook.before,\n            },\n            async (memo: any[]) => {\n              const items = await hook.fn(opts.args);\n              return memo.concat(items);\n            },\n          );\n        }\n        return await tAdd.promise(opts.initialValue || []);\n      case ApplyPluginsType.modify:\n        const tModify = new AsyncSeriesWaterfallHook(['memo']);\n        for (const hook of hooks) {\n          if (!this.isPluginEnable(hook.pluginId!)) {\n            continue;\n          }\n          tModify.tapPromise(\n            {\n              name: hook.pluginId!,\n              stage: hook.stage || 0,\n              // @ts-ignore\n              before: hook.before,\n            },\n            async (memo: any) => {\n              return await hook.fn(memo, opts.args);\n            },\n          );\n        }\n        return await tModify.promise(opts.initialValue);\n      case ApplyPluginsType.event:\n        const tEvent = new AsyncSeriesWaterfallHook(['_']);\n        for (const hook of hooks) {\n          if (!this.isPluginEnable(hook.pluginId!)) {\n            continue;\n          }\n          tEvent.tapPromise(\n            {\n              name: hook.pluginId!,\n              stage: hook.stage || 0,\n              // @ts-ignore\n              before: hook.before,\n            },\n            async () => {\n              await hook.fn(opts.args);\n            },\n          );\n        }\n        return await tEvent.promise();\n      default:\n        throw new Error(\n          `applyPlugin failed, type is not defined or is not matched, got ${opts.type}.`,\n        );\n    }\n  }\n\n  // 运行方法\n  async run({ name, args = {} }: { name: string; args?: any }) {\n    args._ = args._ || [];\n    if (args._[0] === name) args._.shift();\n\n    this.args = args;\n    await this.init();\n\n    this.setStage(ServiceStage.run);\n    await this.applyPlugins({\n      key: 'onStart',\n      type: ApplyPluginsType.event,\n      args: {\n        args,\n      },\n    });\n    return this.runCommand({ name, args });\n  }\n  \n  // 运行命令\n  async runCommand({ name, args = {} }: { name: string; args?: any }) {\n    assert(this.stage >= ServiceStage.init, `service is not initialized.`);\n\n    args._ = args._ || [];\n    if (args._[0] === name) args._.shift();\n\n    const command =\n      typeof this.commands[name] === 'string'\n        ? this.commands[this.commands[name] as string]\n        : this.commands[name];\n    assert(command, `run command failed, command ${name} does not exists.`);\n\n    const { fn } = command as ICommand;\n    return fn({ args });\n  }\n}\n")])])]),t("h4",{attrs:{id:"getpaths-ts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#getpaths-ts"}},[n._v("#")]),n._v(" getPaths.ts")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("export default function getServicePaths({\n  cwd,\n  config,\n  env,\n}: {\n  cwd: string;\n  config: any;\n  env?: string;\n}): IServicePaths {\n  // 项目根目录\n  let absSrcPath = cwd;\n\n  // 如果存在src目录，将absSrcPath定位到src路径下\n  if (isDirectoryAndExist(join(cwd, 'src'))) {\n    absSrcPath = join(cwd, 'src');\n  }\n\n  // src下是page还是pages\n  const absPagesPath = config.singular\n    ? join(absSrcPath, 'page')\n    : join(absSrcPath, 'pages');\n\n  // 临时文件路径\n  const tmpDir = ['.umi', env !== 'development' && env]\n    .filter(Boolean)\n    .join('-');\n\n  // outputPath 指定输出路径\n  return normalizeWithWinPath({\n    cwd,\n    absNodeModulesPath: join(cwd, 'node_modules'),\n    absOutputPath: join(cwd, config.outputPath || './dist'),\n    absSrcPath,\n    absPagesPath,\n    absTmpPath: join(absSrcPath, tmpDir),\n  });\n}\n")])])]),t("h4",{attrs:{id:"pluginapi-ts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pluginapi-ts"}},[n._v("#")]),n._v(" PluginAPI.ts")]),n._v(" "),t("p",[n._v("描述插件核心方法的类，插件的编写需借助这个api，扩展方法需要在preset-built-in的presets集合中进行扩展")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("export default class PluginAPI {\n  // 插件的id，区别不同的插件\n  id: string;\n  // 插件内的不同内容，如方法及数据等\n  key: string;\n  service: Service;\n  Html: typeof Html;\n  utils: typeof utils;\n  logger: Logger;\n\n  constructor(opts: IOpts) {\n    this.id = opts.id;\n    this.key = opts.key;\n    this.service = opts.service;\n    this.utils = utils;\n    this.Html = Html;\n    this.logger = new Logger(`umi:plugin:${this.id || this.key}`);\n  }\n\n  // TODO: reversed keys\n  describe({\n    id,\n    key,\n    config,\n    enableBy,\n  }: {\n    id?: string;\n    key?: string;\n    config?: IPluginConfig;\n    enableBy?: EnableBy | (() => boolean);\n  } = {}) {\n    const { plugins } = this.service;\n    // this.id and this.key is generated automatically\n    // so we need to diff first\n    if (id && this.id !== id) {\n      if (plugins[id]) {\n        const name = plugins[id].isPreset ? 'preset' : 'plugin';\n        throw new Error(\n          `api.describe() failed, ${name} ${id} is already registered by ${plugins[id].path}.`,\n        );\n      }\n      plugins[id] = plugins[this.id];\n      plugins[id].id = id;\n      delete plugins[this.id];\n      this.id = id;\n    }\n    if (key && this.key !== key) {\n      this.key = key;\n      plugins[this.id].key = key;\n    }\n\n    if (config) {\n      plugins[this.id].config = config;\n    }\n\n    plugins[this.id].enableBy = enableBy || EnableBy.register;\n  }\n\n  // 注册插件\n  register(hook: IHook) {\n    assert(\n      hook.key && typeof hook.key === 'string',\n      `api.register() failed, hook.key must supplied and should be string, but got ${hook.key}.`,\n    );\n    assert(\n      hook.fn && typeof hook.fn === 'function',\n      `api.register() failed, hook.fn must supplied and should be function, but got ${hook.fn}.`,\n    );\n    this.service.hooksByPluginId[this.id] = (\n      this.service.hooksByPluginId[this.id] || []\n    ).concat(hook);\n  }\n\n  // 注册插件命令\n  registerCommand(command: ICommand) {\n    const { name, alias } = command;\n    assert(\n      !this.service.commands[name],\n      `api.registerCommand() failed, the command ${name} is exists.`,\n    );\n    this.service.commands[name] = command;\n    if (alias) {\n      this.service.commands[alias] = name;\n    }\n  }\n\n  // 注册预设\n  registerPresets(presets: (IPreset | string)[]) {\n    assert(\n      this.service.stage === ServiceStage.initPresets,\n      `api.registerPresets() failed, it should only used in presets.`,\n    );\n    assert(\n      Array.isArray(presets),\n      `api.registerPresets() failed, presets must be Array.`,\n    );\n    const extraPresets = presets.map((preset) => {\n      return isValidPlugin(preset as any)\n        ? (preset as IPreset)\n        : pathToObj({\n            type: PluginType.preset,\n            path: preset as string,\n            cwd: this.service.cwd,\n          });\n    });\n    // 插到最前面，下个 while 循环优先执行\n    this.service._extraPresets.splice(0, 0, ...extraPresets);\n  }\n\n  // 在 preset 初始化阶段放后面，在插件注册阶段放前面\n  registerPlugins(plugins: (IPlugin | string)[]) {\n    assert(\n      this.service.stage === ServiceStage.initPresets ||\n        this.service.stage === ServiceStage.initPlugins,\n      `api.registerPlugins() failed, it should only be used in registering stage.`,\n    );\n    assert(\n      Array.isArray(plugins),\n      `api.registerPlugins() failed, plugins must be Array.`,\n    );\n    const extraPlugins = plugins.map((plugin) => {\n      return isValidPlugin(plugin as any)\n        ? (plugin as IPreset)\n        : pathToObj({\n            type: PluginType.plugin,\n            path: plugin as string,\n            cwd: this.service.cwd,\n          });\n    });\n    if (this.service.stage === ServiceStage.initPresets) {\n      this.service._extraPlugins.push(...extraPlugins);\n    } else {\n      this.service._extraPlugins.splice(0, 0, ...extraPlugins);\n    }\n  }\n\n  // 注册方法\n  registerMethod({\n    name,\n    fn,\n    exitsError = true,\n  }: {\n    name: string;\n    fn?: Function;\n    exitsError?: boolean;\n  }) {\n    if (this.service.pluginMethods[name]) {\n      if (exitsError) {\n        throw new Error(\n          `api.registerMethod() failed, method ${name} is already exist.`,\n        );\n      } else {\n        return;\n      }\n    }\n    this.service.pluginMethods[name] =\n      fn ||\n      // 这里不能用 arrow function，this 需指向执行此方法的 PluginAPI\n      // 否则 pluginId 会不会，导致不能正确 skip plugin\n      function (fn: Function) {\n        const hook = {\n          key: name,\n          ...(utils.lodash.isPlainObject(fn) ? fn : { fn }),\n        };\n        // @ts-ignore\n        this.register(hook);\n      };\n  }\n\n  // 跳过插件，不执行的插件\n  skipPlugins(pluginIds: string[]) {\n    pluginIds.forEach((pluginId) => {\n      this.service.skipPluginIds.add(pluginId);\n    });\n  }\n}\n")])])]),t("h3",{attrs:{id:"route"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#route"}},[n._v("#")]),n._v(" Route")]),n._v(" "),t("table",[t("thead",[t("tr",[t("th",{staticStyle:{"text-align":"left"}},[n._v("文件名")]),n._v(" "),t("th",{staticStyle:{"text-align":"center"}},[n._v("作用")]),n._v(" "),t("th",{staticStyle:{"text-align":"right"}},[n._v("备注")])])]),n._v(" "),t("tbody",[t("tr",[t("td",{staticStyle:{"text-align":"left"}},[n._v("Route.ts")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("路由的核心类")]),n._v(" "),t("td",{staticStyle:{"text-align":"right"}},[n._v("封装了路由匹配等方法")])]),n._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[n._v("routesToJSON.ts")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("路由转化为json的方法")]),n._v(" "),t("td",{staticStyle:{"text-align":"right"}},[n._v("用于前后端传递")])]),n._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[n._v("getConventionalRoutes.ts")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("获取默认路由")]),n._v(" "),t("td",{staticStyle:{"text-align":"right"}},[n._v("前端开发时常用写的路由表")])])])]),n._v(" "),t("h4",{attrs:{id:"route-ts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#route-ts"}},[n._v("#")]),n._v(" Route.ts")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("class Route {\n  opts: IOpts;\n  constructor(opts?: IOpts) {\n    this.opts = opts || {};\n  }\n\n  async getRoutes(opts: IGetRoutesOpts) {\n\t// config 用户 + 插件配置\n\t// root 是 absPagesPath\n\t// componentPrefix是路径的分割符号，默认是 \"/\"\n    const { config, root, componentPrefix } = opts;\n\n    // 避免修改配置里的 routes，导致重复 patch\n    let routes = lodash.cloneDeep(config.routes);\n    let isConventional = false;\n\n\t// 如果用户没有自定义，则使用约定式路由；如果配置了则约定式路由无效\n    if (!routes) {\n      assert(root, `opts.root must be supplied for conventional routes.`);\n\n\t  // 默认路由的拼接方式\n      routes = this.getConventionRoutes({\n        root: root!,\n        config,\n        componentPrefix,\n      });\n      isConventional = true;\n    }\n\n\t// 生成的路由可以被插件新增，修改，删除\n    await this.patchRoutes(routes, {\n      ...opts,\n      isConventional,\n    });\n    return routes;\n  }\n\n  // TODO:\n  // 1. 移动 /404 到最后，并处理 component 和 redirect\n  async patchRoutes(routes: IRoute[], opts: IGetRoutesOpts) {\n\t// 执行插件的 onPatchRoutesBefore 钩子函数对路由修改\n    if (this.opts.onPatchRoutesBefore) {\n      await this.opts.onPatchRoutesBefore({\n        routes,\n        parentRoute: opts.parentRoute,\n      });\n    }\n\n\t// routes中的route执行patrchRoute方法\n    for (const route of routes) {\n      await this.patchRoute(route, opts);\n    }\n\n\t// onPatchRoutes进行最终的路由修改\n    if (this.opts.onPatchRoutes) {\n      await this.opts.onPatchRoutes({\n        routes,\n        parentRoute: opts.parentRoute,\n      });\n    }\n  }\n\n  async patchRoute(route: IRoute, opts: IGetRoutesOpts) {\n    if (this.opts.onPatchRouteBefore) {\n      await this.opts.onPatchRouteBefore({\n        route,\n        parentRoute: opts.parentRoute,\n      });\n    }\n\n    // route.path 的修改需要在子路由 patch 之前做\n    if (\n      route.path &&\n      route.path.charAt(0) !== '/' &&\n      !/^https?:\\/\\//.test(route.path)\n    ) {\n      route.path = winPath(join(opts.parentRoute?.path || '/', route.path));\n    }\n    if (route.redirect && route.redirect.charAt(0) !== '/') {\n      route.redirect = winPath(\n        join(opts.parentRoute?.path || '/', route.redirect),\n      );\n    }\n\n\t// 递归 patchRoutes\n    if (route.routes) {\n      await this.patchRoutes(route.routes, {\n        ...opts,\n        parentRoute: route,\n      });\n    } else {\n      if (!('exact' in route)) {\n        // exact by default\n        route.exact = true;\n      }\n    }\n\n    // resolve component path\n    if (\n      route.component &&\n      !opts.isConventional &&\n      typeof route.component === 'string' &&\n      !route.component.startsWith('@/') &&\n      !path.isAbsolute(route.component)\n    ) {\n      route.component = winPath(join(opts.root, route.component));\n    }\n\n    // resolve wrappers path\n    if (route.wrappers) {\n      route.wrappers = route.wrappers.map((wrapper) => {\n        if (wrapper.startsWith('@/') || path.isAbsolute(wrapper)) {\n          return wrapper;\n        } else {\n          return winPath(join(opts.root, wrapper));\n        }\n      });\n    }\n\n\t// onPatchRoute 钩子函数\n    if (this.opts.onPatchRoute) {\n      await this.opts.onPatchRoute({\n        route,\n        parentRoute: opts.parentRoute,\n      });\n    }\n  }\n\n  // 约定式路由\n  getConventionRoutes(opts: any): IRoute[] {\n    return getConventionalRoutes(opts);\n  }\n\n  getJSON(opts: { routes: IRoute[]; config: IConfig; cwd: string }) {\n    return routesToJSON(opts);\n  }\n\n  getPaths({ routes }: { routes: IRoute[] }): string[] {\n    return lodash.uniq(\n      routes.reduce((memo: string[], route) => {\n        if (route.path) memo.push(route.path);\n        if (route.routes)\n          memo = memo.concat(this.getPaths({ routes: route.routes }));\n        return memo;\n      }, []),\n    );\n  }\n}\n")])])]),t("h4",{attrs:{id:"routestojson-ts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#routestojson-ts"}},[n._v("#")]),n._v(" routesToJSON.ts")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 正则匹配，然后JSON.stringify()\nexport default function ({ routes, config, cwd }: IOpts) {\n  // 因为要往 routes 里加无用的信息，所以必须 deep clone 一下，避免污染\n  const clonedRoutes = lodash.cloneDeep(routes);\n\n  if (config.dynamicImport) {\n    patchRoutes(clonedRoutes);\n  }\n\n  function patchRoutes(routes: IRoute[]) {\n    routes.forEach(patchRoute);\n  }\n\n  function patchRoute(route: IRoute) {\n    if (route.component && !isFunctionComponent(route.component)) {\n      const webpackChunkName = routeToChunkName({\n        route,\n        cwd,\n      });\n      // 解决 SSR 开启动态加载后，页面闪烁问题\n      if (config?.ssr && config?.dynamicImport) {\n        route._chunkName = webpackChunkName;\n      }\n      route.component = [\n        route.component,\n        webpackChunkName,\n        route.path || EMPTY_PATH,\n      ].join(SEPARATOR);\n    }\n    if (route.routes) {\n      patchRoutes(route.routes);\n    }\n  }\n\n  function isFunctionComponent(component: string) {\n    return (\n      /^\\((.+)?\\)(\\s+)?=>/.test(component) ||\n      /^function([^\\(]+)?\\(([^\\)]+)?\\)([^{]+)?{/.test(component)\n    );\n  }\n\n  function replacer(key: string, value: any) {\n    switch (key) {\n      case 'component':\n        if (isFunctionComponent(value)) return value;\n        if (config.dynamicImport) {\n          const [component, webpackChunkName] = value.split(SEPARATOR);\n          let loading = '';\n          if (config.dynamicImport.loading) {\n            loading = `, loading: LoadingComponent`;\n          }\n          return `dynamic({ loader: () => import(/* webpackChunkName: '${webpackChunkName}' */'${component}')${loading}})`;\n        } else {\n          return `require('${value}').default`;\n        }\n      case 'wrappers':\n        const wrappers = value.map((wrapper: string) => {\n          if (config.dynamicImport) {\n            let loading = '';\n            if (config.dynamicImport.loading) {\n              loading = `, loading: LoadingComponent`;\n            }\n            return `dynamic({ loader: () => import(/* webpackChunkName: 'wrappers' */'${wrapper}')${loading}})`;\n          } else {\n            return `require('${wrapper}').default`;\n          }\n        });\n        return `[${wrappers.join(', ')}]`;\n      default:\n        return value;\n    }\n  }\n\n  return JSON.stringify(clonedRoutes, replacer, 2)\n    .replace(/\\\"component\\\": (\\\"(.+?)\\\")/g, (global, m1, m2) => {\n      return `\"component\": ${m2.replace(/\\^/g, '\"')}`;\n    })\n    .replace(/\\\"wrappers\\\": (\\\"(.+?)\\\")/g, (global, m1, m2) => {\n      return `\"wrappers\": ${m2.replace(/\\^/g, '\"')}`;\n    })\n    .replace(/\\\\r\\\\n/g, '\\r\\n')\n    .replace(/\\\\n/g, '\\r\\n');\n}\n")])])]),t("h4",{attrs:{id:"getconventionalroutes-ts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#getconventionalroutes-ts"}},[n._v("#")]),n._v(" getConventionalRoutes.ts")]),n._v(" "),t("p",[n._v("需要考虑多种情况，如：目录、文件、动态路由等")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 考虑多种情况：\n// 可能是目录，没有后缀，比如 [post]/add.tsx\n// 可能是文件，有后缀，比如 [id].tsx\n// [id$] 是可选动态路由\nconst RE_DYNAMIC_ROUTE = /^\\[(.+?)\\]/;\n\n// 获取文件，主要就是fs模块的读写问价等方法\nfunction getFiles(root: string) {\n  if (!existsSync(root)) return [];\n  return readdirSync(root).filter((file) => {\n    const absFile = join(root, file);\n    const fileStat = statSync(absFile);\n    const isDirectory = fileStat.isDirectory();\n    const isFile = fileStat.isFile();\n    if (\n      isDirectory &&\n      ['components', 'component', 'utils', 'util'].includes(file)\n    ) {\n      return false;\n    }\n    if (file.charAt(0) === '.') return false;\n    if (file.charAt(0) === '_') return false;\n    // exclude test file\n    if (/\\.(test|spec|e2e)\\.(j|t)sx?$/.test(file)) return false;\n    // d.ts\n    if (/\\.d\\.ts$/.test(file)) return false;\n    if (isFile) {\n      if (!/\\.(j|t)sx?$/.test(file)) return false;\n      const content = readFileSync(absFile, 'utf-8');\n      try {\n        if (!isReactComponent(content)) return false;\n      } catch (e) {\n        throw new Error(\n          `Parse conventional route component ${absFile} failed, ${e.message}`,\n        );\n      }\n    }\n    return true;\n  });\n}\n\n// 文件路由的reducer方法\nfunction fileToRouteReducer(opts: IOpts, memo: IRoute[], file: string) {\n  const { root, relDir = '' } = opts;\n  const absFile = join(root, relDir, file);\n  const stats = statSync(absFile);\n  const __isDynamic = RE_DYNAMIC_ROUTE.test(file);\n\n  if (stats.isDirectory()) {\n    const relFile = join(relDir, file);\n    const layoutFile = getFile({\n      base: join(root, relFile),\n      fileNameWithoutExt: '_layout',\n      type: 'javascript',\n    });\n    const route = {\n      path: normalizePath(relFile, opts),\n      routes: getRoutes({\n        ...opts,\n        relDir: join(relFile),\n      }),\n      __isDynamic,\n      ...(layoutFile\n        ? {\n            component: layoutFile.path,\n          }\n        : {\n            exact: true,\n            __toMerge: true,\n          }),\n    };\n    memo.push(normalizeRoute(route, opts));\n  } else {\n    const bName = basename(file, extname(file));\n    memo.push(\n      normalizeRoute(\n        {\n          path: normalizePath(join(relDir, bName), opts),\n          exact: true,\n          component: absFile,\n          __isDynamic,\n        },\n        opts,\n      ),\n    );\n  }\n  return memo;\n}\n\n// 格式化路由\nfunction normalizeRoute(route: IRoute, opts: IOpts) {\n  let props: unknown = undefined;\n  if (route.component) {\n    try {\n      props = getExportProps(readFileSync(route.component, 'utf-8'));\n    } catch (e) {\n      throw new Error(\n        `Parse conventional route component ${route.component} failed, ${e.message}`,\n      );\n    }\n    route.component = winPath(relative(join(opts.root, '..'), route.component));\n    route.component = `${opts.componentPrefix || '@/'}${route.component}`;\n  }\n  return {\n    ...route,\n    ...(typeof props === 'object' ? props : {}),\n  };\n}\n\n// 格式化路径\nfunction normalizePath(path: string, opts: IOpts) {\n  path = winPath(path)\n    .split('/')\n    .map((p) => {\n      // dynamic route\n      p = p.replace(RE_DYNAMIC_ROUTE, ':$1');\n\n      // :post$ => :post?\n      if (p.endsWith('$')) {\n        p = p.slice(0, -1) + '?';\n      }\n      return p;\n    })\n    .join('/');\n\n  path = `/${path}`;\n\n  // /index/index -> /\n  if (path === '/index/index') {\n    path = '/';\n  }\n\n  // /xxxx/index -> /xxxx/\n  path = path.replace(/\\/index$/, '/');\n\n  // remove the last slash\n  // e.g. /abc/ -> /abc\n  if (path !== '/' && path.slice(-1) === '/') {\n    path = path.slice(0, -1);\n  }\n\n  return path;\n}\n\n// 格式化路由表\nfunction normalizeRoutes(routes: IRoute[]): IRoute[] {\n  const paramsRoutes: IRoute[] = [];\n  const exactRoutes: IRoute[] = [];\n  const layoutRoutes: IRoute[] = [];\n\n  routes.forEach((route) => {\n    const { __isDynamic, exact } = route;\n    delete route.__isDynamic;\n    if (__isDynamic) {\n      paramsRoutes.push(route);\n    } else if (exact) {\n      exactRoutes.push(route);\n    } else {\n      layoutRoutes.push(route);\n    }\n  });\n\n  assert(\n    paramsRoutes.length <= 1,\n    `We should not have multiple dynamic routes under a directory.`,\n  );\n\n  return [...exactRoutes, ...layoutRoutes, ...paramsRoutes].reduce(\n    (memo, route) => {\n      if (route.__toMerge && route.routes) {\n        memo = memo.concat(route.routes);\n      } else {\n        memo.push(route);\n      }\n      return memo;\n    },\n    [] as IRoute[],\n  );\n}\n\n// 获取路由表\nexport default function getRoutes(opts: IOpts) {\n  const { root, relDir = '', config } = opts;\n  const files = getFiles(join(root, relDir));\n  const routes = normalizeRoutes(\n    files.reduce(fileToRouteReducer.bind(null, opts), []),\n  );\n\n  if (!relDir) {\n    const globalLayoutFile = getFile({\n      base: root,\n      fileNameWithoutExt: `../${config.singular ? 'layout' : 'layouts'}/index`,\n      type: 'javascript',\n    });\n    if (globalLayoutFile) {\n      return [\n        normalizeRoute(\n          {\n            path: '/',\n            component: globalLayoutFile.path,\n            routes,\n          },\n          opts,\n        ),\n      ];\n    }\n  }\n\n  return routes;\n}\n")])])]),t("h3",{attrs:{id:"config"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#config"}},[n._v("#")]),n._v(" Config")]),n._v(" "),t("table",[t("thead",[t("tr",[t("th",{staticStyle:{"text-align":"left"}},[n._v("文件名")]),n._v(" "),t("th",{staticStyle:{"text-align":"center"}},[n._v("作用")]),n._v(" "),t("th",{staticStyle:{"text-align":"right"}},[n._v("备注")])])]),n._v(" "),t("tbody",[t("tr",[t("td",{staticStyle:{"text-align":"left"}},[n._v("Config.ts")]),n._v(" "),t("td",{staticStyle:{"text-align":"center"}},[n._v("核心配置类")]),n._v(" "),t("td",{staticStyle:{"text-align":"right"}},[n._v("关联用户输入与脚手架输出的中介者")])])])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("export default class Config {\n  cwd: string;\n  service: Service;\n  config?: object;\n  localConfig?: boolean;\n  configFile?: string | null;\n\n  constructor(opts: IOpts) {\n    this.cwd = opts.cwd || process.cwd();\n    this.service = opts.service;\n    this.localConfig = opts.localConfig;\n  }\n\n  // 获取默认配置\n  async getDefaultConfig() {\n    const pluginIds = Object.keys(this.service.plugins);\n\n    // collect default config\n    let defaultConfig = pluginIds.reduce((memo, pluginId) => {\n      const { key, config = {} } = this.service.plugins[pluginId];\n      if ('default' in config) memo[key] = config.default;\n      return memo;\n    }, {});\n\n    return defaultConfig;\n  }\n\n  // 获取配置的方法\n  getConfig({ defaultConfig }: { defaultConfig: object }) {\n    assert(\n      this.service.stage >= ServiceStage.pluginReady,\n      `Config.getConfig() failed, it should not be executed before plugin is ready.`,\n    );\n\n    const userConfig = this.getUserConfig();\n    // 用于提示用户哪些 key 是未定义的\n    // TODO: 考虑不排除 false 的 key\n    const userConfigKeys = Object.keys(userConfig).filter((key) => {\n      return userConfig[key] !== false;\n    });\n\n    // get config\n    const pluginIds = Object.keys(this.service.plugins);\n    pluginIds.forEach((pluginId) => {\n      const { key, config = {} } = this.service.plugins[pluginId];\n      // recognize as key if have schema config\n      if (!config.schema) return;\n\n      const value = getUserConfigWithKey({ key, userConfig });\n      // 不校验 false 的值，此时已禁用插件\n      if (value === false) return;\n\n      // do validate\n      const schema = config.schema(joi);\n      assert(\n        joi.isSchema(schema),\n        `schema return from plugin ${pluginId} is not valid schema.`,\n      );\n      const { error } = schema.validate(value);\n      if (error) {\n        const e = new Error(\n          `Validate config \"${key}\" failed, ${error.message}`,\n        );\n        e.stack = error.stack;\n        throw e;\n      }\n\n      // remove key\n      const index = userConfigKeys.indexOf(key.split('.')[0]);\n      if (index !== -1) {\n        userConfigKeys.splice(index, 1);\n      }\n\n      // update userConfig with defaultConfig\n      if (key in defaultConfig) {\n        const newValue = mergeDefault({\n          defaultConfig: defaultConfig[key],\n          config: value,\n        });\n        updateUserConfigWithKey({\n          key,\n          value: newValue,\n          userConfig,\n        });\n      }\n    });\n\n    if (userConfigKeys.length) {\n      const keys = userConfigKeys.length > 1 ? 'keys' : 'key';\n      throw new Error(`Invalid config ${keys}: ${userConfigKeys.join(', ')}`);\n    }\n\n    return userConfig;\n  }\n\n  // 获取用户配置\n  getUserConfig() {\n    const configFile = this.getConfigFile();\n    this.configFile = configFile;\n    // 潜在问题：\n    // .local 和 .env 的配置必须有 configFile 才有效\n    if (configFile) {\n      let envConfigFile;\n      if (process.env.UMI_ENV) {\n        const envConfigFileName = this.addAffix(\n          configFile,\n          process.env.UMI_ENV,\n        );\n        const fileNameWithoutExt = envConfigFileName.replace(\n          extname(envConfigFileName),\n          '',\n        );\n        envConfigFile = getFile({\n          base: this.cwd,\n          fileNameWithoutExt,\n          type: 'javascript',\n        })?.filename;\n        if (!envConfigFile) {\n          throw new Error(\n            `get user config failed, ${envConfigFile} does not exist, but process.env.UMI_ENV is set to ${process.env.UMI_ENV}.`,\n          );\n        }\n      }\n      const files = [\n        configFile,\n        envConfigFile,\n        this.localConfig && this.addAffix(configFile, 'local'),\n      ]\n        .filter((f): f is string => !!f)\n        .map((f) => join(this.cwd, f))\n        .filter((f) => existsSync(f));\n\n      // clear require cache and set babel register\n      const requireDeps = files.reduce((memo: string[], file) => {\n        memo = memo.concat(parseRequireDeps(file));\n        return memo;\n      }, []);\n      requireDeps.forEach(cleanRequireCache);\n      this.service.babelRegister.setOnlyMap({\n        key: 'config',\n        value: requireDeps,\n      });\n\n      // require config and merge\n      return this.mergeConfig(...this.requireConfigs(files));\n    } else {\n      return {};\n    }\n  }\n\n  addAffix(file: string, affix: string) {\n    const ext = extname(file);\n    return file.replace(new RegExp(`${ext}$`), `.${affix}${ext}`);\n  }\n\n  requireConfigs(configFiles: string[]) {\n    return configFiles.map((f) => compatESModuleRequire(require(f)));\n  }\n\n  mergeConfig(...configs: object[]) {\n    let ret = {};\n    for (const config of configs) {\n      // TODO: 精细化处理，比如处理 dotted config key\n      ret = deepmerge(ret, config);\n    }\n    return ret;\n  }\n\n  getConfigFile(): string | null {\n    // TODO: support custom config file\n    const configFile = CONFIG_FILES.find((f) => existsSync(join(this.cwd, f)));\n    return configFile ? winPath(configFile) : null;\n  }\n\n  getWatchFilesAndDirectories() {\n    const umiEnv = process.env.UMI_ENV;\n    const configFiles = lodash.clone(CONFIG_FILES);\n    CONFIG_FILES.forEach((f) => {\n      if (this.localConfig) configFiles.push(this.addAffix(f, 'local'));\n      if (umiEnv) configFiles.push(this.addAffix(f, umiEnv));\n    });\n\n    const configDir = winPath(join(this.cwd, 'config'));\n\n    const files = configFiles\n      .reduce<string[]>((memo, f) => {\n        const file = winPath(join(this.cwd, f));\n        if (existsSync(file)) {\n          memo = memo.concat(parseRequireDeps(file));\n        } else {\n          memo.push(file);\n        }\n        return memo;\n      }, [])\n      .filter((f) => !f.startsWith(configDir));\n\n    return [configDir].concat(files);\n  }\n\n  // 发布订阅，监听用户配置的修改\n  watch(opts: {\n    userConfig: object;\n    onChange: (args: {\n      userConfig: any;\n      pluginChanged: IChanged[];\n      valueChanged: IChanged[];\n    }) => void;\n  }) {\n    let paths = this.getWatchFilesAndDirectories();\n    let userConfig = opts.userConfig;\n    const watcher = chokidar.watch(paths, {\n      ignoreInitial: true,\n      cwd: this.cwd,\n    });\n    watcher.on('all', (event, path) => {\n      console.log(chalk.green(`[${event}] ${path}`));\n      const newPaths = this.getWatchFilesAndDirectories();\n      const diffs = lodash.difference(newPaths, paths);\n      if (diffs.length) {\n        watcher.add(diffs);\n        paths = paths.concat(diffs);\n      }\n\n      const newUserConfig = this.getUserConfig();\n      const pluginChanged: IChanged[] = [];\n      const valueChanged: IChanged[] = [];\n      Object.keys(this.service.plugins).forEach((pluginId) => {\n        const { key, config = {} } = this.service.plugins[pluginId];\n        // recognize as key if have schema config\n        if (!config.schema) return;\n        if (!isEqual(newUserConfig[key], userConfig[key])) {\n          const changed = {\n            key,\n            pluginId: pluginId,\n          };\n          if (newUserConfig[key] === false || userConfig[key] === false) {\n            pluginChanged.push(changed);\n          } else {\n            valueChanged.push(changed);\n          }\n        }\n      });\n      debug(`newUserConfig: ${JSON.stringify(newUserConfig)}`);\n      debug(`oldUserConfig: ${JSON.stringify(userConfig)}`);\n      debug(`pluginChanged: ${JSON.stringify(pluginChanged)}`);\n      debug(`valueChanged: ${JSON.stringify(valueChanged)}`);\n\n      if (pluginChanged.length || valueChanged.length) {\n        opts.onChange({\n          userConfig: newUserConfig,\n          pluginChanged,\n          valueChanged,\n        });\n      }\n      userConfig = newUserConfig;\n    });\n\n    return () => {\n      watcher.close();\n    };\n  }\n}\n")])])]),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[n._v("#")]),n._v(" 总结")]),n._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/umi20210222/umi06.png",alt:"图片"}})]),n._v(" "),t("p",[t("img",{attrs:{src:"/tech/front/umi20210222/umi07.png",alt:"图片"}})]),n._v(" "),t("p",[n._v("umi是蚂蚁金服前端架构的基石，其他的各种扩展应用，诸如：antd组件库、dva数据流等，都是基于umi来构建的，而Ant Design Pro算是蚂蚁金服中后台应用的一个最佳实践。umi对于自研前端生态的核心基础库有着重要的参考价值，对整个生态的支撑也起着“牵一发而动全身”的作用，如果用一句话来概括umi的核心设计理念，那就是“约定大于配置”，其他各种设计都是围绕着这一设计哲学展开的，因而对于生态的建设要想好我想给外界传递一种什么样的价值与理念，反复造轮子是没有意义的，只有真正能解决问题，好用的轮子才能走的更长远！")]),n._v(" "),t("h2",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[n._v("#")]),n._v(" 参考")]),n._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://github.com/umijs/umi",target:"_blank",rel:"noopener noreferrer"}},[n._v("umi官方仓库"),t("OutboundLink")],1)]),n._v(" "),t("li",[t("a",{attrs:{href:"https://blog.csdn.net/lz710117239/article/details/86603811",target:"_blank",rel:"noopener noreferrer"}},[n._v("微内核架构"),t("OutboundLink")],1)]),n._v(" "),t("li",[t("a",{attrs:{href:"https://segmentfault.com/a/1190000019719722",target:"_blank",rel:"noopener noreferrer"}},[n._v("基于Umi的开发方案"),t("OutboundLink")],1)]),n._v(" "),t("li",[t("a",{attrs:{href:"https://www.zhihu.com/column/c_1269578954706702336",target:"_blank",rel:"noopener noreferrer"}},[n._v("神马翔：umi 源码专栏"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=s.exports}}]);
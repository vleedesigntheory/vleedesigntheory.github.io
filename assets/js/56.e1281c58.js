(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{261:function(n,t,e){"use strict";e.r(t);var r=e(0),a=Object(r.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"flexiwan项目踩坑实践（前端篇）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flexiwan项目踩坑实践（前端篇）"}},[n._v("#")]),n._v(" flexiwan项目踩坑实践（前端篇）")]),n._v(" "),e("h2",{attrs:{id:"项目背景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#项目背景"}},[n._v("#")]),n._v(" 项目背景")]),n._v(" "),e("p",[n._v("flexiManage是以色列一家初创公司flexiWAN开源的基于SD-WAN平台的应用层的框架，包括"),e("a",{attrs:{href:"https://gitlab.com/flexiwangroup/fleximanage",target:"_blank",rel:"noopener noreferrer"}},[n._v("flexiManage"),e("OutboundLink")],1),n._v("服务端框架以及硬件侧的"),e("a",{attrs:{href:"https://gitlab.com/flexiwangroup/flexiagent",target:"_blank",rel:"noopener noreferrer"}},[n._v("flexiAgent"),e("OutboundLink")],1),n._v("框架，然而其并没有开源前端框架，为了验证其SD-WAN方案的可行性，需要快速搭建一个前端应用")]),n._v(" "),e("h2",{attrs:{id:"项目选型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#项目选型"}},[n._v("#")]),n._v(" 项目选型")]),n._v(" "),e("p",[n._v("由于探索性质，项目要求能快速搭建，因而放弃了Ant Design Pro以及Vue Element Admin,而是选用了阿里飞冰（ice）的Fusion Design Lite来进行前端页面的搭建")]),n._v(" "),e("p",[e("img",{attrs:{src:"/tech/front/flexiwan20201218/flexiwan01.jpg",alt:"图片"}})]),n._v(" "),e("h2",{attrs:{id:"目录结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#目录结构"}},[n._v("#")]),n._v(" 目录结构")]),n._v(" "),e("p",[e("img",{attrs:{src:"/tech/front/flexiwan20201218/flexiwan02.jpg",alt:"图片"}})]),n._v(" "),e("ul",[e("li",[n._v("src\n"),e("ul",[e("li",[n._v("components\n"),e("ul",[e("li",[n._v("CustomIcon")]),n._v(" "),e("li",[n._v("WrapperPage")])])]),n._v(" "),e("li",[n._v("layouts\n"),e("ul",[e("li",[n._v("BasicLayout\n"),e("ul",[e("li",[n._v("components")]),n._v(" "),e("li",[n._v("index.jsx")]),n._v(" "),e("li",[n._v("menuConfig.js")])])])])]),n._v(" "),e("li",[n._v("pages\n"),e("ul",[e("li",[n._v("Home")]),n._v(" "),e("li",[n._v("Inventory\n"),e("ul",[e("li",[n._v("Devices\n"),e("ul",[e("li",[n._v("DeviceInfo")])])]),n._v(" "),e("li",[n._v("Tunnels")])])]),n._v(" "),e("li",[n._v("NotFound")])])]),n._v(" "),e("li",[n._v("utils")])])]),n._v(" "),e("li",[n._v("build.json (webpack相关工程配置在这里编写)")])]),n._v(" "),e("h2",{attrs:{id:"踩坑案例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#踩坑案例"}},[n._v("#")]),n._v(" 踩坑案例")]),n._v(" "),e("h3",{attrs:{id:"createcontext传递上下文"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#createcontext传递上下文"}},[n._v("#")]),n._v(" createContext传递上下文")]),n._v(" "),e("p",[e("img",{attrs:{src:"/tech/front/flexiwan20201218/flexiwan03.jpg",alt:"图片"}})]),n._v(" "),e("p",[e("img",{attrs:{src:"/tech/front/flexiwan20201218/flexiwan04.jpg",alt:"图片"}})]),n._v(" "),e("p",[n._v("[bug描述] 在DeviceInfo中设立了四个切换的tab，需要在切换时将子组件的数据传递给父组件，由于函数式编程this指向了undefined，其上下文信息需要通过自己创造的上下文进行传递，使用createContext创建唯一一个上下文device对象用于进行更新的接口发送")]),n._v(" "),e("p",[n._v("[bug分析] this上下文信息缺失，需要自定义Context")]),n._v(" "),e("p",[n._v("[解决方案] 利用useState处理父级数据，利用其中的类似setState的函数传递给子组件，使子组件向父组件传递数据")]),n._v(" "),e("h3",{attrs:{id:"jsx运行时和编译时问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jsx运行时和编译时问题"}},[n._v("#")]),n._v(" jsx运行时和编译时问题")]),n._v(" "),e("p",[e("img",{attrs:{src:"/tech/front/flexiwan20201218/flexiwan05.jpg",alt:"图片"}})]),n._v(" "),e("p",[e("img",{attrs:{src:"/tech/front/flexiwan20201218/flexiwan06.jpg",alt:"图片"}})]),n._v(" "),e("p",[n._v("[bug描述] 父组件异步请求获取数据后传递给子组件时，子组件数据获取后在config处编译时拿到数据，在react的dom渲染运行时无法监听到数据")]),n._v(" "),e("p",[n._v("[bug分析] jsx的编译时与运行时对应的react dom渲染的时点不同，在react dom之前是拿不到动态数据的")]),n._v(" "),e("p",[n._v("[解决方案] 在子组件中再请求一遍接口或通过效应器useEffect将渲染运行时切到一致，类似vue的$nextTick")]),n._v(" "),e("h2",{attrs:{id:"源码解析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#源码解析"}},[n._v("#")]),n._v(" 源码解析")]),n._v(" "),e("h3",{attrs:{id:"阿里飞冰源码解析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#阿里飞冰源码解析"}},[n._v("#")]),n._v(" 阿里飞冰源码解析")]),n._v(" "),e("p",[e("img",{attrs:{src:"/tech/front/flexiwan20201218/flexiwan07.jpg",alt:"图片"}})]),n._v(" "),e("p",[e("img",{attrs:{src:"/tech/front/flexiwan20201218/flexiwan11.jpg",alt:"图片"}})]),n._v(" "),e("p",[n._v("阿里飞冰是淘系的一套主面向后端或其他开发人员的前端全链路的一套全流程自动化构建前端页面框架，其包含了脚手架（不太好用）、low code界面化操作、vscode插件化操作、微前端全流程低配置化服务，可简化前端工程操作")]),n._v(" "),e("h4",{attrs:{id:"miniapp-render"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#miniapp-render"}},[n._v("#")]),n._v(" miniapp-render")]),n._v(" "),e("p",[e("img",{attrs:{src:"/tech/front/flexiwan20201218/flexiwan08.jpg",alt:"图片"}})]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function miniappRenderer(\n  { appConfig, createBaseApp, createHistory, staticConfig, pageProps, emitLifeCycles, ErrorBoundary },\n  { mount, unmount, createElement, Component }\n) {\n  const history = createHistory({ routes: staticConfig.routes });\n\n  const { runtime } = createBaseApp(appConfig);\n  const AppProvider = runtime?.composeAppProvider?.();\n\n  const { app = {} } = appConfig;\n  const { rootId, ErrorBoundaryFallback, onErrorBoundaryHander, errorBoundary } = app;\n\n  emitLifeCycles();\n  class App extends Component {\n    public render() {\n      const { Page, ...otherProps } = this.props;\n      const PageComponent = createElement(Page, {\n        ...otherProps\n      });\n\n      let appInstance = PageComponent;\n\n      if (AppProvider) {\n        appInstance = createElement(AppProvider, null, appInstance);\n      }\n      if (errorBoundary) {\n        appInstance = createElement(ErrorBoundary, {\n          Fallback: ErrorBoundaryFallback,\n          onError: onErrorBoundaryHander\n        }, appInstance);\n      }\n      return appInstance;\n    }\n  }\n\n  (window as any).__pagesRenderInfo = staticConfig.routes.map(({ source, component }: any) => {\n    return {\n      path: source,\n      render() {\n        const PageComponent = component()();\n        const rootEl = document.createElement('div');\n        rootEl.setAttribute('id', rootId);\n        document.body.appendChild(rootEl);\n        const appInstance = mount(createElement(App, {\n          history,\n          location: history.location,\n          ...pageProps,\n          source,\n          Page: PageComponent\n        }), rootEl);\n\n        (document as any).__unmount = unmount(appInstance, rootEl);\n      },\n      setDocument(value) {\n        // eslint-disable-next-line no-global-assign\n        document = value;\n      }\n    };\n  });\n};\n\nexport default miniappRenderer;\n")])])]),e("p",[n._v("本质是一个函数，在window上挂载了一个根APP应用，应用中引入了对应的运行时、路由、属性等信息")]),n._v(" "),e("h4",{attrs:{id:"react-app-renderer"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-app-renderer"}},[n._v("#")]),n._v(" react-app-renderer")]),n._v(" "),e("p",[e("img",{attrs:{src:"/tech/front/flexiwan20201218/flexiwan09.jpg",alt:"图片"}})]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport * as ReactDOMServer from 'react-dom/server';\nimport { createNavigation } from 'create-app-container';\nimport { createUseRouter } from 'create-use-router';\nimport * as queryString from 'query-string';\n\nconst { createElement, useEffect, useState, Fragment, useLayoutEffect } = React;\n\nconst useRouter = createUseRouter({ useState, useLayoutEffect });\nconst AppNavigation = createNavigation({ createElement, useEffect, useState, Fragment });\n\n// ssr方式\nexport function reactAppRendererWithSSR(context, options) {\n  ...\n}\n\nlet __initialData__;\n\n// 设置初始值\nexport function setInitialData(initialData) {\n  ...\n}\n\n// 获取初始值\nexport function getInitialData() {\n  ...\n}\n\n// react的渲染\n\n// 1. 返回的渲染函数\nfunction _renderApp(context, options) {\n  const { appConfig, staticConfig = {}, buildConfig = {}, createBaseApp, emitLifeCycles } = options;\n  const { runtime, history, appConfig: modifiedAppConfig } = createBaseApp(appConfig, buildConfig, context);\n\n  options.appConfig = modifiedAppConfig;\n\n  // Emit app launch cycle\n  emitLifeCycles();\n\n  const isMobile = Object.keys(staticConfig).length;\n  if (isMobile) {\n    return _renderMobile({ runtime, history }, options);\n  } else {\n    return _render({ runtime }, options);\n  }\n}\n\n// 调用react渲染\nexport async function reactAppRenderer(options) {\n  const { appConfig, setAppConfig, loadStaticModules } = options || {};\n\n  setAppConfig(appConfig);\n\n  loadStaticModules(appConfig);\n\n  if (process.env.__IS_SERVER__) return;\n\n  let initialData = {};\n  let pageInitialProps = {};\n\n  const { href, origin, pathname, search } = window.location;\n  const path = href.replace(origin, '');\n  const query = queryString.parse(search);\n  const ssrError = (window as any).__ICE_SSR_ERROR__;\n  const initialContext = {\n    pathname,\n    path,\n    query,\n    ssrError\n  };\n\n  // ssr enabled and the server has returned data\n  if ((window as any).__ICE_APP_DATA__) {\n    initialData = (window as any).__ICE_APP_DATA__;\n    pageInitialProps = (window as any).__ICE_PAGE_PROPS__;\n  } else {\n    // ssr not enabled, or SSR is enabled but the server does not return data\n    // eslint-disable-next-line\n    if (appConfig.app && appConfig.app.getInitialData) {\n      initialData = await appConfig.app.getInitialData(initialContext);\n    }\n  }\n\n  // set InitialData, can get the return value through getInitialData method\n  setInitialData(initialData);\n\n  const context = { initialData, pageInitialProps, initialContext };\n  _renderApp(context, options);\n}\n\n\n// 渲染函数\nfunction _render({ runtime }, options) {\n  const { ErrorBoundary, appConfig = {} } = options;\n  const { ErrorBoundaryFallback, onErrorBoundaryHander, errorBoundary } = appConfig.app;\n  const AppProvider = runtime?.composeAppProvider?.();\n  const AppRouter = runtime?.getAppRouter?.();\n  const { rootId, mountNode } = appConfig.app;\n\n  function App() {\n    const appRouter = <AppRouter />;\n    const rootApp = AppProvider ? <AppProvider>{appRouter}</AppProvider> : appRouter;\n    if (errorBoundary) {\n      return (\n        <ErrorBoundary Fallback={ErrorBoundaryFallback} onError={onErrorBoundaryHander}>\n          {rootApp}\n        </ErrorBoundary>\n      );\n    }\n    return rootApp;\n  }\n\n  if (process.env.__IS_SERVER__) {\n    return ReactDOMServer.renderToString(<App />);\n  }\n\n  const appMountNode = _getAppMountNode(mountNode, rootId);\n  if (runtime?.modifyDOMRender) {\n    return runtime?.modifyDOMRender?.({ App, appMountNode });\n  }\n\n  return ReactDOM[(window as any).__ICE_SSR_ENABLED__ ? 'hydrate' : 'render'](<App />, appMountNode);\n}\n\n// 渲染手机端\nfunction _renderMobile({ runtime, history }, options) {\n  ...\n}\n\n// 匹配初始组件\nfunction _matchInitialComponent(fullpath, routes) {\n  ...\n}\n\n// 挂载节点\nfunction _getAppMountNode(mountNode, rootId) {\n  ...\n}\n")])])]),e("p",[n._v("调用react的渲染机制，将ice嵌入react中")]),n._v(" "),e("h3",{attrs:{id:"create-use-router"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#create-use-router"}},[n._v("#")]),n._v(" create-use-router")]),n._v(" "),e("p",[e("img",{attrs:{src:"/tech/front/flexiwan20201218/flexiwan10.jpg",alt:"图片"}})]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("import * as pathToRegexpModule from 'path-to-regexp';\n\nconst cache = {};\n\nlet _initialized = false;\nlet _routerConfig = null;\nconst router = {\n  history: null,\n  handles: [],\n  errorHandler() { },\n  addHandle(handle) {\n    return router.handles.push(handle);\n  },\n  removeHandle(handleId) {\n    router.handles[handleId - 1] = null;\n  },\n  triggerHandles(component) {\n    router.handles.forEach((handle) => {\n      if (handle) {\n        handle(component);\n      }\n    });\n  },\n  match(fullpath) {\n    if (fullpath == null) return;\n\n    (router as any).fullpath = fullpath;\n    const parent = (router as any).root;\n    // @ts-ignore\n    const matched = matchRoute(\n      parent,\n      parent.path,\n      fullpath\n    );\n\n    // eslint-disable-next-line\n    function next(parent) {\n      const current = matched.next();\n\n      if (current.done) {\n        const error = new Error(`No match for ${fullpath}`);\n        // @ts-ignore\n        return router.errorHandler(error, router.history.location);\n      }\n\n      let component = current.$.route.component;\n      if (typeof component === 'function') {\n        component = component(current.$.params, router.history.location);\n      }\n\n      if (component instanceof Promise) {\n        // Lazy loading component by import('./Foo')\n        // eslint-disable-next-line\n        return component.then((component) => {\n          // Check current fullpath avoid router has changed before lazy loading complete\n          // @ts-ignore\n          if (fullpath === router.fullpath) {\n            router.triggerHandles(component);\n          }\n        });\n      } else if (component != null) {\n        router.triggerHandles(component);\n        return component;\n      } else {\n        return next(parent);\n      }\n    }\n\n    return next(parent);\n  }\n};\n\n// 参数解析\nfunction decodeParam(val) {\n  try {\n    return decodeURIComponent(val);\n  } catch (err) {\n    return val;\n  }\n}\n\n// 匹配地址\nfunction matchLocation({ pathname }) {\n  router.match(pathname);\n}\n\n// 匹配路径\nfunction matchPath(route, pathname, parentParams) {\n  ... 正则\n}\n\n// 匹配路由 generator函数\nfunction matchRoute(route, baseUrl, pathname, parentParams) {\n  let matched;\n  let childMatches;\n  let childIndex = 0;\n\n  return {\n    next() {\n      if (!matched) {\n        matched = matchPath(route, pathname, parentParams);\n\n        if (matched) {\n          return {\n            done: false,\n            $: {\n              route,\n              baseUrl,\n              path: matched.path,\n              params: matched.params,\n            },\n          };\n        }\n      }\n\n      if (matched && route.routes) {\n        while (childIndex < route.routes.length) {\n          if (!childMatches) {\n            const childRoute = route.routes[childIndex];\n            childRoute.parent = route;\n\n            childMatches = matchRoute(\n              childRoute,\n              baseUrl + matched.path,\n              pathname.substr(matched.path.length),\n              matched.params,\n            );\n          }\n\n          const childMatch = childMatches.next();\n          if (!childMatch.done) {\n            return {\n              done: false,\n              $: childMatch.$,\n            };\n          }\n\n          childMatches = null;\n          childIndex++;\n        }\n      }\n\n      return { done: true };\n    },\n  };\n}\n\n// 获取组件内容\nfunction getInitialComponent(routerConfig) {\n  ...\n}\n\n// 创建使用路由\nexport function createUseRouter(api) {\n  const { useState, useLayoutEffect } = api;\n\n  function useRouter(routerConfig) {\n    const [component, setComponent] = useState(getInitialComponent(routerConfig));\n\n    useLayoutEffect(() => {\n      if (_initialized) throw new Error('Error: useRouter can only be called once.');\n      _initialized = true;\n      const history = _routerConfig.history;\n      const routes = _routerConfig.routes;\n\n      // @ts-ignore\n      router.root = Array.isArray(routes) ? { routes } : routes;\n\n      // eslint-disable-next-line\n      const handleId = router.addHandle((component) => {\n        setComponent(component);\n      });\n\n      // Init path match\n      if (!_routerConfig.InitialComponent) {\n        matchLocation(history.location);\n      }\n\n      const unlisten = history.listen((location) => {\n        matchLocation(location);\n      });\n\n      return () => {\n        router.removeHandle(handleId);\n        unlisten();\n      };\n    }, []);\n\n    return { component };\n  }\n\n  return useRouter;\n}\n\n// 创建包裹路由\nexport function createWithRouter(api) {\n  const { createElement } = api;\n\n  function withRouter(Component) {\n    function Wrapper(props) {\n      const history = router.history;\n      return createElement(Component, { ...props, history, location: history.location });\n    };\n\n    Wrapper.displayName = `withRouter(${  Component.displayName || Component.name  })`;\n    Wrapper.WrappedComponent = Component;\n    return Wrapper;\n  }\n\n  return withRouter;\n}\n")])])]),e("p",[n._v("飞冰路由机制，可获取对应参数等，主要是generator函数实现，正则匹配")]),n._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[n._v("#")]),n._v(" 总结")]),n._v(" "),e("p",[n._v("飞冰脚手架的构建方式主要是通过一个核心的miniRender来返回调用react的渲染机制，配合广大的插件机制，只留下一个简单的核心，其他都以插件化的形式进行扩展，微内核广外延的架构还是很值得参考的。")])])}),[],!1,null,null,null);t.default=a.exports}}]);
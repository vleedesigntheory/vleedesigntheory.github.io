(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{254:function(t,n,e){"use strict";e.r(n);var r=e(0),i=Object(r.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"vee-cli脚手架实践-中"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vee-cli脚手架实践-中"}},[t._v("#")]),t._v(" vee-cli脚手架实践(中)")]),t._v(" "),e("h2",{attrs:{id:"前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),e("p",[t._v("书接上回 "),e("a",{attrs:{href:"https://vleedesigntheory.github.io/tech/front/cli20200701.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("vee-cli脚手架实践(上)"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("上回主要介绍了脚本命令的一些分发配置，本篇主要在于介绍创建文件的模板拉取、拷贝，主要是create.js下的具体逻辑")]),t._v(" "),e("h2",{attrs:{id:"模板拉取"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模板拉取"}},[t._v("#")]),t._v(" 模板拉取")]),t._v(" "),e("h3",{attrs:{id:"依赖包"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#依赖包"}},[t._v("#")]),t._v(" 依赖包")]),t._v(" "),e("p",[e("img",{attrs:{src:"/tech/front/cli20200702/cli01.jpeg",alt:"图片"}})]),t._v(" "),e("p",[t._v("[包目录结构]")]),t._v(" "),e("ul",[e("li",[t._v("axios (发送请求，promise封装)")]),t._v(" "),e("li",[t._v("ora (等待loading)")]),t._v(" "),e("li",[t._v("inquirer (询问选择命令)")]),t._v(" "),e("li",[t._v("download-git-repo (从github上拉取仓库)")]),t._v(" "),e("li",[t._v("ncp (拷贝文件到指定目录下)")])]),t._v(" "),e("p",[t._v("[目录描述] 通过axios发送请求，获取github上的仓库和版本号(ps: 见"),e("a",{attrs:{href:"https://developer.github.com/v3/repos",target:"_blank",rel:"noopener noreferrer"}},[t._v("github开发者文档-repo"),e("OutboundLink")],1),t._v(")，通过inquirer与开发者进行命令行交互，ora优化用户体验，download-git-repo将仓库下载到对应的目录下，通常为.template下，再通过ncp将下载的文件直接拷贝到指定的目录下")]),t._v(" "),e("h3",{attrs:{id:"逻辑代码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#逻辑代码"}},[t._v("#")]),t._v(" 逻辑代码")]),t._v(" "),e("p",[e("img",{attrs:{src:"/tech/front/cli20200702/cli02.jpeg",alt:"图片"}})]),t._v(" "),e("h4",{attrs:{id:"获取仓库和版本"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#获取仓库和版本"}},[t._v("#")]),t._v(" 获取仓库和版本")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const fetchRepoList = async () => {\n    const { data } = await axios.get(`${repoUrl}/repos`);\n    return data;\n}\n\nconst fetchTagList = async (repo) => {\n    const { data } = await axios.get(`${tagUrl}/${repo}/tags`);\n    return data;\n}\n")])])]),e("p",[t._v("其中固定参数可全部放入到constants.js中进行导出")]),t._v(" "),e("h4",{attrs:{id:"功能函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#功能函数"}},[t._v("#")]),t._v(" 功能函数")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const waitLoading = (fn, message) => async (...args) => {\n    const spinner = ora(message);\n    spinner.start();\n    const result = await fn(...args);\n    spinner.succeed();\n    return result;\n}\n\nconst download = async (repo, tag) => {\n    let api = `${baseUrl}/${repo}`;\n    if(tag) {\n        api += `#${tag}`;\n    }\n    const dest = `${downloadDirectory}/${repo}`;\n    await downloadGitRepoPro(api, dest);\n    return dest;\n}\n")])])]),e("p",[t._v("其中下载github仓库的函数是以回调函数的形式书写的，我们希望都通过promise的形式返回，这样可以使用async/await来编写代码，这里用到了promisify(ps: 关于这个函数面试中也经常被问题到，有需要的同学可参考这篇文章如何实现promisify"),e("a",{attrs:{href:"https://vleedesigntheory.github.io/interview/interview-program.html#%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86",target:"_blank",rel:"noopener noreferrer"}},[t._v("编程题-原理部分"),e("OutboundLink")],1),t._v(")，另外对于多个函数传参，使用了函数柯里化的高阶函数(ps: 函数柯里化和反柯里化也常考"),e("a",{attrs:{href:"https://vleedesigntheory.github.io/interview/interview-program.html#%E6%96%B9%E6%B3%95%E5%BA%93%E9%83%A8%E5%88%86",target:"_blank",rel:"noopener noreferrer"}},[t._v("编程题-方法库部分"),e("OutboundLink")],1),t._v(")")]),t._v(" "),e("h4",{attrs:{id:"导出模块"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#导出模块"}},[t._v("#")]),t._v(" 导出模块")]),t._v(" "),e("p",[e("img",{attrs:{src:"/tech/front/cli20200702/cli03.jpeg",alt:"图片"}})]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("module.exports = async ( projectName ) => {\n    // 获取仓库\n    const repos = await waitLoading(fetchRepoList, ' fetching template ...')();\n    const reposName = repos.map( item => item.name );\n    const { repo } = await Inquirer.prompt({\n        name: 'repo',\n        type: 'list',\n        message: 'please choice a template to create project',\n        choices: reposName\n    })\n    // 获取版本号\n    const tags = await waitLoading(fetchTagList, ' fetching tags ...')(repo);\n    const tagsName = tags.map( item => item.name );\n    const { tag } = await Inquirer.prompt({\n        name: 'tag',\n        type: 'list',\n        message: 'please choice a template to create project',\n        choices: tagsName\n    });\n\n    const result = await waitLoading(download, 'download template ...')(repo,tag);\n    console.log(result);\n\n    // 直接下载\n    await ncpPro(result, path.resolve(projectName));\n    // 模板渲染后再拷贝\n}\n")])])]),e("p",[t._v("这里将拉取的模板直接下载到了当前目录下，对于需要编译的部分将在下篇中介绍")]),t._v(" "),e("h3",{attrs:{id:"相关包源码分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#相关包源码分析"}},[t._v("#")]),t._v(" 相关包源码分析")]),t._v(" "),e("p",[t._v("本篇设计的包较多，由于篇幅有限，从中选取几个核心包的核心代码亮点进行分析")]),t._v(" "),e("h4",{attrs:{id:"ora"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ora"}},[t._v("#")]),t._v(" ora")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Ora {\n\tconstructor(options) {\n\t\tif (typeof options === 'string') {\n\t\t\toptions = {\n\t\t\t\ttext: options\n\t\t\t};\n\t\t}\n\n\t\tthis.options = {\n\t\t\ttext: '',\n\t\t\tcolor: 'cyan',\n\t\t\tstream: process.stderr,\n\t\t\tdiscardStdin: true,\n\t\t\t...options\n\t\t};\n\n\t\tthis.spinner = this.options.spinner;\n\n\t\tthis.color = this.options.color;\n\t\tthis.hideCursor = this.options.hideCursor !== false;\n\t\tthis.interval = this.options.interval || this.spinner.interval || 100;\n\t\tthis.stream = this.options.stream;\n\t\tthis.id = undefined;\n\t\tthis.isEnabled = typeof this.options.isEnabled === 'boolean' ? this.options.isEnabled : isInteractive({stream: this.stream});\n\n\t\t// Set *after* `this.stream`\n\t\tthis.text = this.options.text;\n\t\tthis.prefixText = this.options.prefixText;\n\t\tthis.linesToClear = 0;\n\t\tthis.indent = this.options.indent;\n\t\tthis.discardStdin = this.options.discardStdin;\n\t\tthis.isDiscardingStdin = false;\n\t}\n\n\tget indent() {\n\t\treturn this._indent;\n\t}\n\n\tset indent(indent = 0) {\n\t\tif (!(indent >= 0 && Number.isInteger(indent))) {\n\t\t\tthrow new Error('The `indent` option must be an integer from 0 and up');\n\t\t}\n\n\t\tthis._indent = indent;\n\t}\n\n\t_updateInterval(interval) {\n\t\tif (interval !== undefined) {\n\t\t\tthis.interval = interval;\n\t\t}\n\t}\n\n\tget spinner() {\n\t\treturn this._spinner;\n\t}\n\n\tset spinner(spinner) {\n\t\tthis.frameIndex = 0;\n\n\t\tif (typeof spinner === 'object') {\n\t\t\tif (spinner.frames === undefined) {\n\t\t\t\tthrow new Error('The given spinner must have a `frames` property');\n\t\t\t}\n\n\t\t\tthis._spinner = spinner;\n\t\t} else if (process.platform === 'win32') {\n\t\t\tthis._spinner = cliSpinners.line;\n\t\t} else if (spinner === undefined) {\n\t\t\t// Set default spinner\n\t\t\tthis._spinner = cliSpinners.dots;\n\t\t} else if (cliSpinners[spinner]) {\n\t\t\tthis._spinner = cliSpinners[spinner];\n\t\t} else {\n\t\t\tthrow new Error(`There is no built-in spinner named '${spinner}'. See https://github.com/sindresorhus/cli-spinners/blob/master/spinners.json for a full list.`);\n\t\t}\n\n\t\tthis._updateInterval(this._spinner.interval);\n\t}\n\n\tget text() {\n\t\treturn this[TEXT];\n\t}\n\n\tget prefixText() {\n\t\treturn this[PREFIX_TEXT];\n\t}\n\n\tget isSpinning() {\n\t\treturn this.id !== undefined;\n\t}\n\n\tupdateLineCount() {\n\t\tconst columns = this.stream.columns || 80;\n\t\tconst fullPrefixText = (typeof this[PREFIX_TEXT] === 'string') ? this[PREFIX_TEXT] + '-' : '';\n\t\tthis.lineCount = stripAnsi(fullPrefixText + '--' + this[TEXT]).split('\\n').reduce((count, line) => {\n\t\t\treturn count + Math.max(1, Math.ceil(wcwidth(line) / columns));\n\t\t}, 0);\n\t}\n\n\tset text(value) {\n\t\tthis[TEXT] = value;\n\t\tthis.updateLineCount();\n\t}\n\n\tset prefixText(value) {\n\t\tthis[PREFIX_TEXT] = value;\n\t\tthis.updateLineCount();\n\t}\n\n\tframe() {\n\t\tconst {frames} = this.spinner;\n\t\tlet frame = frames[this.frameIndex];\n\n\t\tif (this.color) {\n\t\t\tframe = chalk[this.color](frame);\n\t\t}\n\n\t\tthis.frameIndex = ++this.frameIndex % frames.length;\n\t\tconst fullPrefixText = (typeof this.prefixText === 'string' && this.prefixText !== '') ? this.prefixText + ' ' : '';\n\t\tconst fullText = typeof this.text === 'string' ? ' ' + this.text : '';\n\n\t\treturn fullPrefixText + frame + fullText;\n\t}\n\n\tclear() {\n\t\tif (!this.isEnabled || !this.stream.isTTY) {\n\t\t\treturn this;\n\t\t}\n\n\t\tfor (let i = 0; i < this.linesToClear; i++) {\n\t\t\tif (i > 0) {\n\t\t\t\tthis.stream.moveCursor(0, -1);\n\t\t\t}\n\n\t\t\tthis.stream.clearLine();\n\t\t\tthis.stream.cursorTo(this.indent);\n\t\t}\n\n\t\tthis.linesToClear = 0;\n\n\t\treturn this;\n\t}\n\n\trender() {\n\t\tthis.clear();\n\t\tthis.stream.write(this.frame());\n\t\tthis.linesToClear = this.lineCount;\n\n\t\treturn this;\n\t}\n\n\tstart(text) {\n\t\tif (text) {\n\t\t\tthis.text = text;\n\t\t}\n\n\t\tif (!this.isEnabled) {\n\t\t\tif (this.text) {\n\t\t\t\tthis.stream.write(`- ${this.text}\\n`);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tif (this.isSpinning) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif (this.hideCursor) {\n\t\t\tcliCursor.hide(this.stream);\n\t\t}\n\n\t\tif (this.discardStdin && process.stdin.isTTY) {\n\t\t\tthis.isDiscardingStdin = true;\n\t\t\tstdinDiscarder.start();\n\t\t}\n\n\t\tthis.render();\n\t\tthis.id = setInterval(this.render.bind(this), this.interval);\n\n\t\treturn this;\n\t}\n\n\tstop() {\n\t\tif (!this.isEnabled) {\n\t\t\treturn this;\n\t\t}\n\n\t\tclearInterval(this.id);\n\t\tthis.id = undefined;\n\t\tthis.frameIndex = 0;\n\t\tthis.clear();\n\t\tif (this.hideCursor) {\n\t\t\tcliCursor.show(this.stream);\n\t\t}\n\n\t\tif (this.discardStdin && process.stdin.isTTY && this.isDiscardingStdin) {\n\t\t\tstdinDiscarder.stop();\n\t\t\tthis.isDiscardingStdin = false;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tsucceed(text) {\n\t\treturn this.stopAndPersist({symbol: logSymbols.success, text});\n\t}\n\n\tfail(text) {\n\t\treturn this.stopAndPersist({symbol: logSymbols.error, text});\n\t}\n\n\twarn(text) {\n\t\treturn this.stopAndPersist({symbol: logSymbols.warning, text});\n\t}\n\n\tinfo(text) {\n\t\treturn this.stopAndPersist({symbol: logSymbols.info, text});\n\t}\n\n\tstopAndPersist(options = {}) {\n\t\tconst prefixText = options.prefixText || this.prefixText;\n\t\tconst fullPrefixText = (typeof prefixText === 'string' && prefixText !== '') ? prefixText + ' ' : '';\n\t\tconst text = options.text || this.text;\n\t\tconst fullText = (typeof text === 'string') ? ' ' + text : '';\n\n\t\tthis.stop();\n\t\tthis.stream.write(`${fullPrefixText}${options.symbol || ' '}${fullText}\\n`);\n\n\t\treturn this;\n\t}\n}\n")])])]),e("p",[t._v("核心的旋转是一个spinners的json文件，维护的一个ora大类")]),t._v(" "),e("h4",{attrs:{id:"inquirer"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#inquirer"}},[t._v("#")]),t._v(" inquirer")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class StateManager {\n  constructor(configFactory, initialState, render) {\n    this.initialState = initialState;\n    this.render = render;\n    this.currentState = {\n      loadingIncrement: 0,\n      value: '',\n      status: 'idle',\n    };\n\n    // Default `input` to stdin\n    const input = process.stdin;\n\n    // Add mute capabilities to the output\n    const output = new MuteStream();\n    output.pipe(process.stdout);\n\n    this.rl = readline.createInterface({\n      terminal: true,\n      input,\n      output,\n    });\n    this.screen = new ScreenManager(this.rl);\n\n    let config = configFactory;\n    if (_.isFunction(configFactory)) {\n      config = configFactory(this.rl);\n    }\n\n    this.config = config;\n\n    this.onKeypress = this.onKeypress.bind(this);\n    this.onSubmit = this.onSubmit.bind(this);\n    this.startLoading = this.startLoading.bind(this);\n    this.onLoaderTick = this.onLoaderTick.bind(this);\n    this.setState = this.setState.bind(this);\n    this.handleLineEvent = this.handleLineEvent.bind(this);\n  }\n\n  async execute(cb) {\n    let { message } = this.getState();\n    this.cb = cb;\n\n    // Load asynchronous properties\n    const showLoader = setTimeout(this.startLoading, 500);\n    if (_.isFunction(message)) {\n      message = await runAsync(message)();\n    }\n\n    this.setState({ message, status: 'idle' });\n\n    // Disable the loader if it didn't launch\n    clearTimeout(showLoader);\n\n    // Setup event listeners once we're done fetching the configs\n    this.rl.input.on('keypress', this.onKeypress);\n    this.rl.on('line', this.handleLineEvent);\n  }\n\n  onKeypress(value, key) {\n    const { onKeypress = _.noop } = this.config;\n    // Ignore enter keypress. The \"line\" event is handling those.\n    if (key.name === 'enter' || key.name === 'return') {\n      return;\n    }\n\n    this.setState({ value: this.rl.line, error: null });\n    onKeypress(this.rl.line, key, this.getState(), this.setState);\n  }\n\n  startLoading() {\n    this.setState({ loadingIncrement: 0, status: 'loading' });\n    setTimeout(this.onLoaderTick, spinner.interval);\n  }\n\n  onLoaderTick() {\n    const { status, loadingIncrement } = this.getState();\n    if (status === 'loading') {\n      this.setState({ loadingIncrement: loadingIncrement + 1 });\n      setTimeout(this.onLoaderTick, spinner.interval);\n    }\n  }\n\n  handleLineEvent() {\n    const { onLine = defaultOnLine } = this.config;\n    onLine(this.getState(), {\n      submit: this.onSubmit,\n      setState: this.setState,\n    });\n  }\n\n  async onSubmit() {\n    const state = this.getState();\n    const { validate, filter } = state;\n    const { validate: configValidate = () => true } = this.config;\n\n    const { mapStateToValue = defaultMapStateToValue } = this.config;\n    let value = mapStateToValue(state);\n\n    const showLoader = setTimeout(this.startLoading, 500);\n    this.rl.pause();\n    try {\n      const filteredValue = await runAsync(filter)(value);\n      let isValid = configValidate(value, state);\n      if (isValid === true) {\n        isValid = await runAsync(validate)(filteredValue);\n      }\n\n      if (isValid === true) {\n        this.onDone(filteredValue);\n        clearTimeout(showLoader);\n        return;\n      }\n\n      this.onError(isValid);\n    } catch (err) {\n      this.onError(err.message + '\\n' + err.stack);\n    }\n\n    clearTimeout(showLoader);\n    this.rl.resume();\n  }\n\n  onError(error) {\n    this.setState({\n      status: 'idle',\n      error: error || 'You must provide a valid value',\n    });\n  }\n\n  onDone(value) {\n    this.setState({ status: 'done' });\n    this.rl.input.removeListener('keypress', this.onKeypress);\n    this.rl.removeListener('line', this.handleLineEvent);\n    this.screen.done();\n    this.cb(value);\n  }\n\n  setState(partialState) {\n    this.currentState = Object.assign({}, this.currentState, partialState);\n    this.onChange(this.getState());\n  }\n\n  getState() {\n    return Object.assign({}, defaultState, this.initialState, this.currentState);\n  }\n\n  getPrefix() {\n    const { status, loadingIncrement } = this.getState();\n    let prefix = chalk.green('?');\n    if (status === 'loading') {\n      const frame = loadingIncrement % spinner.frames.length;\n      prefix = chalk.yellow(spinner.frames[frame]);\n    }\n\n    return prefix;\n  }\n\n  onChange(state) {\n    const { status, message, value, transformer } = this.getState();\n\n    let error;\n    if (state.error) {\n      error = `${chalk.red('>>')} ${state.error}`;\n    }\n\n    const renderState = Object.assign(\n      {\n        prefix: this.getPrefix(),\n      },\n      state,\n      {\n        // Only pass message down if it's a string. Otherwise we're still in init state\n        message: _.isFunction(message) ? 'Loading...' : message,\n        value: transformer(value, { isFinal: status === 'done' }),\n        validate: undefined,\n        filter: undefined,\n        transformer: undefined,\n      }\n    );\n    this.screen.render(this.render(renderState, this.config), error);\n  }\n}\n")])])]),e("p",[t._v("命令行的输入输出主要是process.stdin和process.stdout，然后通过readline进行获取，其核心主要就是维护一个StateManager类，对于选取的内容进行获取和映射")]),t._v(" "),e("h4",{attrs:{id:"download-git-repo"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#download-git-repo"}},[t._v("#")]),t._v(" download-git-repo")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function download (repo, dest, opts, fn) {\n  if (typeof opts === 'function') {\n    fn = opts\n    opts = null\n  }\n  opts = opts || {}\n  var clone = opts.clone || false\n  delete opts.clone\n\n  repo = normalize(repo)\n  var url = repo.url || getUrl(repo, clone)\n\n  if (clone) {\n    var cloneOptions = {\n      checkout: repo.checkout,\n      shallow: repo.checkout === 'master',\n      ...opts\n    }\n    gitclone(url, dest, cloneOptions, function (err) {\n      if (err === undefined) {\n        rm(dest + '/.git')\n        fn()\n      } else {\n        fn(err)\n      }\n    })\n  } else {\n    var downloadOptions = {\n      extract: true,\n      strip: 1,\n      mode: '666',\n      ...opts,\n      headers: {\n        accept: 'application/zip',\n        ...(opts.headers || {})\n      }\n    }\n    downloadUrl(url, dest, downloadOptions)\n      .then(function (data) {\n        fn()\n      })\n      .catch(function (err) {\n        fn(err)\n      })\n  }\n}\n")])])]),e("p",[t._v("其核心是download和git-clone的包，其中git-clone是git的js对应的api，通过git clone下来的仓库来进行流的读写操作")]),t._v(" "),e("h4",{attrs:{id:"ncp"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ncp"}},[t._v("#")]),t._v(" ncp")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function ncp (source, dest, options, callback) {\n  var cback = callback;\n\n  if (!callback) {\n    cback = options;\n    options = {};\n  }\n\n  var basePath = process.cwd(),\n      currentPath = path.resolve(basePath, source),\n      targetPath = path.resolve(basePath, dest),\n      filter = options.filter,\n      rename = options.rename,\n      transform = options.transform,\n      clobber = options.clobber !== false,\n      modified = options.modified,\n      dereference = options.dereference,\n      errs = null,\n      started = 0,\n      finished = 0,\n      running = 0,\n      limit = options.limit || ncp.limit || 16;\n\n  limit = (limit < 1) ? 1 : (limit > 512) ? 512 : limit;\n\n  startCopy(currentPath);\n  \n  function startCopy(source) {\n    started++;\n    if (filter) {\n      if (filter instanceof RegExp) {\n        if (!filter.test(source)) {\n          return cb(true);\n        }\n      }\n      else if (typeof filter === 'function') {\n        if (!filter(source)) {\n          return cb(true);\n        }\n      }\n    }\n    return getStats(source);\n  }\n\n  function getStats(source) {\n    var stat = dereference ? fs.stat : fs.lstat;\n    if (running >= limit) {\n      return setImmediate(function () {\n        getStats(source);\n      });\n    }\n    running++;\n    stat(source, function (err, stats) {\n      var item = {};\n      if (err) {\n        return onError(err);\n      }\n\n      // We need to get the mode from the stats object and preserve it.\n      item.name = source;\n      item.mode = stats.mode;\n      item.mtime = stats.mtime; //modified time\n      item.atime = stats.atime; //access time\n\n      if (stats.isDirectory()) {\n        return onDir(item);\n      }\n      else if (stats.isFile()) {\n        return onFile(item);\n      }\n      else if (stats.isSymbolicLink()) {\n        // Symlinks don't really need to know about the mode.\n        return onLink(source);\n      }\n    });\n  }\n\n  function onFile(file) {\n    var target = file.name.replace(currentPath, targetPath);\n    if(rename) {\n      target =  rename(target);\n    }\n    isWritable(target, function (writable) {\n      if (writable) {\n        return copyFile(file, target);\n      }\n      if(clobber) {\n        rmFile(target, function () {\n          copyFile(file, target);\n        });\n      }\n      if (modified) {\n        var stat = dereference ? fs.stat : fs.lstat;\n        stat(target, function(err, stats) {\n            //if souce modified time greater to target modified time copy file\n            if (file.mtime.getTime()>stats.mtime.getTime())\n                copyFile(file, target);\n            else return cb();\n        });\n      }\n      else {\n        return cb();\n      }\n    });\n  }\n\n  function copyFile(file, target) {\n    var readStream = fs.createReadStream(file.name),\n        writeStream = fs.createWriteStream(target, { mode: file.mode });\n    \n    readStream.on('error', onError);\n    writeStream.on('error', onError);\n    \n    if(transform) {\n      transform(readStream, writeStream, file);\n    } else {\n      writeStream.on('open', function() {\n        readStream.pipe(writeStream);\n      });\n    }\n    writeStream.once('finish', function() {\n        if (modified) {\n            //target file modified date sync.\n            fs.utimesSync(target, file.atime, file.mtime);\n            cb();\n        }\n        else cb();\n    });\n  }\n\n  function rmFile(file, done) {\n    fs.unlink(file, function (err) {\n      if (err) {\n        return onError(err);\n      }\n      return done();\n    });\n  }\n\n  function onDir(dir) {\n    var target = dir.name.replace(currentPath, targetPath);\n    isWritable(target, function (writable) {\n      if (writable) {\n        return mkDir(dir, target);\n      }\n      copyDir(dir.name);\n    });\n  }\n\n  function mkDir(dir, target) {\n    fs.mkdir(target, dir.mode, function (err) {\n      if (err) {\n        return onError(err);\n      }\n      copyDir(dir.name);\n    });\n  }\n\n  function copyDir(dir) {\n    fs.readdir(dir, function (err, items) {\n      if (err) {\n        return onError(err);\n      }\n      items.forEach(function (item) {\n        startCopy(path.join(dir, item));\n      });\n      return cb();\n    });\n  }\n\n  function onLink(link) {\n    var target = link.replace(currentPath, targetPath);\n    fs.readlink(link, function (err, resolvedPath) {\n      if (err) {\n        return onError(err);\n      }\n      checkLink(resolvedPath, target);\n    });\n  }\n\n  function checkLink(resolvedPath, target) {\n    if (dereference) {\n      resolvedPath = path.resolve(basePath, resolvedPath);\n    }\n    isWritable(target, function (writable) {\n      if (writable) {\n        return makeLink(resolvedPath, target);\n      }\n      fs.readlink(target, function (err, targetDest) {\n        if (err) {\n          return onError(err);\n        }\n        if (dereference) {\n          targetDest = path.resolve(basePath, targetDest);\n        }\n        if (targetDest === resolvedPath) {\n          return cb();\n        }\n        return rmFile(target, function () {\n          makeLink(resolvedPath, target);\n        });\n      });\n    });\n  }\n\n  function makeLink(linkPath, target) {\n    fs.symlink(linkPath, target, function (err) {\n      if (err) {\n        return onError(err);\n      }\n      return cb();\n    });\n  }\n\n  function isWritable(path, done) {\n    fs.lstat(path, function (err) {\n      if (err) {\n        if (err.code === 'ENOENT') return done(true);\n        return done(false);\n      }\n      return done(false);\n    });\n  }\n\n  function onError(err) {\n    if (options.stopOnError) {\n      return cback(err);\n    }\n    else if (!errs && options.errs) {\n      errs = fs.createWriteStream(options.errs);\n    }\n    else if (!errs) {\n      errs = [];\n    }\n    if (typeof errs.write === 'undefined') {\n      errs.push(err);\n    }\n    else { \n      errs.write(err.stack + '\\n\\n');\n    }\n    return cb();\n  }\n\n  function cb(skipped) {\n    if (!skipped) running--;\n    finished++;\n    if ((started === finished) && (running === 0)) {\n      if (cback !== undefined ) {\n        return errs ? cback(errs) : cback(null);\n      }\n    }\n  }\n}\n")])])]),e("p",[t._v("path和fs模块的核心应用，对于读写文件的应用的同学可以参考一下写法")]),t._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("p",[t._v("本篇主要描述的是模板拉取及拷贝，对于复杂的需要编译的模板如何编写，且听下回分解")]),t._v(" "),e("p",[t._v("未完待续...")]),t._v(" "),e("h2",{attrs:{id:"参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://github.com/sindresorhus/ora",target:"_blank",rel:"noopener noreferrer"}},[t._v("ora.js源码"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://github.com/SBoudrias/Inquirer.js",target:"_blank",rel:"noopener noreferrer"}},[t._v("inquirer.js源码"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://blog.csdn.net/qq_26733915/article/details/80461257",target:"_blank",rel:"noopener noreferrer"}},[t._v("inquirer.js —— 一个用户与命令行交互的工具"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://gitlab.com/flippidippi/download-git-repo",target:"_blank",rel:"noopener noreferrer"}},[t._v("download-git-repo.js源码"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://github.com/AvianFlu/ncp",target:"_blank",rel:"noopener noreferrer"}},[t._v("ncp.js源码"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);n.default=i.exports}}]);
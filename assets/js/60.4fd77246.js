(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{262:function(e,n,r){"use strict";r.r(n);var t=r(0),o=Object(t.a)({},(function(){var e=this,n=e.$createElement,r=e._self._c||n;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"react-hooks在sd-wan项目中实践"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react-hooks在sd-wan项目中实践"}},[e._v("#")]),e._v(" React Hooks在SD-WAN项目中实践")]),e._v(" "),r("h2",{attrs:{id:"前言"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),r("p",[e._v("React Hooks是React16新出的基于函数式组件的一组新的api，其不同于之前class组件的内层嵌套方式，利用hooks进行钩子方式的对数据进行了组件间的流向组织，sdwan项目中都是基于函数式组件的封装，本文为sdwan项目中的react hooks的应用实践")]),e._v(" "),r("h2",{attrs:{id:"目录"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[e._v("#")]),e._v(" 目录")]),e._v(" "),r("ul",[r("li",[e._v("添加警告规则弹窗组件实践")]),e._v(" "),r("li",[e._v("React Hooks源码解读")]),e._v(" "),r("li",[e._v("React Fiber数据结构分析")])]),e._v(" "),r("h2",{attrs:{id:"探索案例"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#探索案例"}},[e._v("#")]),e._v(" 探索案例")]),e._v(" "),r("h3",{attrs:{id:"添加警告规则弹窗组件实践"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#添加警告规则弹窗组件实践"}},[e._v("#")]),e._v(" 添加警告规则弹窗组件实践")]),e._v(" "),r("p",[r("img",{attrs:{src:"/tech/front/hooks20200826/addRule.gif",alt:"addRule"}})]),e._v(" "),r("p",[e._v("[组件目录]")]),e._v(" "),r("ul",[r("li",[e._v("components\n"),r("ul",[r("li",[e._v("addRule.jsx")]),e._v(" "),r("li",[e._v("RuleList.jsx")])])]),e._v(" "),r("li",[e._v("index.jsx")]),e._v(" "),r("li",[e._v("index.less")])]),e._v(" "),r("p",[e._v("[目录描述] addRule是点击弹窗后弹出的主体组件")]),e._v(" "),r("p",[e._v("[源码分析] addRule是添加规则的弹窗，其中在告警规则一栏中，需要对列表中的行进行加减操作，这里最先想到的就是利用useState进行数据的管理，但其实useState是useReducer的语法糖，后续源码中会分析，我们看到使用了useState后可以将所有状态抽离到顶部，后续凡是需要使用trNum或setTrNum的便可以直接使用，这样就省去了在setState中的设置以及对相应this的绑定问题，使得数据的操作更加纯粹而且明晰")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const AddRule = (props) => {\n  const { children, title } = props;\n  ......\n\n  const [trNum, setTrNum] = useState(1);\n\n  const trLoop = (n) => {\n    let arr = [];\n    for(let i=0; i< n; i++) {\n      arr.push(\n        <tr>\n          <td>\n            <Select\n              placeholder='请选择'\n              defaultValue='0'\n              style={{width:'120px'}}\n            >\n                {options.params.map((d) => (\n                    <Select.Option value={d.status} key={d.status}>\n                    {d.text}\n                    </Select.Option>\n                ))}\n            </Select>\n          </td>\n          <td>\n            <Select\n              placeholder='请选择'\n              defaultValue='0'\n            >\n                {options.compare.map((d) => (\n                    <Select.Option value={d.status} key={d.status}>\n                    {d.text}\n                    </Select.Option>\n                ))}\n            </Select>\n          </td>\n          <td>\n            <Select\n              placeholder='请选择'\n              defaultValue={currentType}\n              onChange={val => setTypeValue(val)}\n            >\n                {options.type.map((d) => (\n                    <Select.Option value={d.status} key={d.status}>\n                    {d.text}\n                    </Select.Option>\n                ))}\n            </Select>\n          </td>\n          <td>\n            { typeValue == options.type[1].status \n            ? \n              <span style={{display: 'inline-flex', verticalAlign: 'middle', lineHeight: '32px', width: '120px'}}>\n                <Input placeholder=\"\"/>dBm\n              </span>\n            : \n              <Select\n                placeholder='请选择'\n                defaultValue='0'\n                style={{width:'120px'}}\n              >\n                  {options.params.map((d) => (\n                      <Select.Option value={d.status} key={d.status}>\n                      {d.text}\n                      </Select.Option>\n                  ))}\n              </Select>\n            }\n          </td>\n          <td>\n            <PlusOutlined style={{color: '#1890ff'}} onClick={()=>setTrNum(trNum + 1)}/>\n          </td>\n          <td>\n            <CloseOutlined style={{color: '#ff4d4f'}} onClick={()=> trNum>1 && setTrNum(trNum - 1)}/>\n          </td>\n        </tr>\n      )\n    };\n    return arr;\n  };\n\n  ......\n\n  return (\n    <>\n      <span onClick={showModelHandler}>{children}</span>\n      <Modal\n        title={title}\n        visible={visible}\n        onCancel={hideModelHandler}\n        onOk={handleOk}\n        maskClosable={false}\n        destroyOnClose\n      >\n        <Form form={form} layout=\"vertical\">\n          ......\n          <Form.Item name=\"告警规则\" label=\"告警规则\">\n              <div style={{width: '100%', backgroundColor: '#ececec', padding: '10px'}}>\n                <span>\n                  符合以下&nbsp;<Select\n                    placeholder='请选择'\n                    defaultValue='0'\n                    style={{width: '120px'}}\n                  >\n                      {options.rule.map((d) => (\n                          <Select.Option value={d.status} key={d.status}>\n                          {d.text}\n                          </Select.Option>\n                      ))}\n                  </Select>&nbsp;条件：\n                </span>\n                <div \n                  style={{\n                    border: '1px solid #ccc',\n                    width: '100%', \n                    background: '#fff', \n                    marginTop: '10px', \n                    padding: '4px'\n                  }}\n                >\n                  <table >\n                    <tbody >\n                      { trLoop(trNum) }\n                    </tbody>\n                  </table>\n                </div>\n              </div>\n          </Form.Item>\n          ......\n        </Form>\n      </Modal>\n    </>\n  );\n};\n")])])]),r("h3",{attrs:{id:"react-hooks源码解读"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react-hooks源码解读"}},[e._v("#")]),e._v(" React Hooks源码解读")]),e._v(" "),r("p",[r("img",{attrs:{src:"/tech/front/hooks20200826/hooks01.png",alt:"hooks01"}})]),e._v(" "),r("p",[e._v("[组件目录]")]),e._v(" "),r("ul",[r("li",[e._v("packages\n"),r("ul",[r("li",[e._v("react\n"),r("ul",[r("li",[e._v("src\n"),r("ul",[r("li",[e._v("ReactHooks.js")])])])])])])])]),e._v(" "),r("p",[e._v("这里仅仅是做了一个名称的导出包括：")]),e._v(" "),r("ul",[r("li",[e._v("useContext")]),e._v(" "),r("li",[e._v("useState")]),e._v(" "),r("li",[e._v("useReducer")]),e._v(" "),r("li",[e._v("useRef")]),e._v(" "),r("li",[e._v("useEffect")]),e._v(" "),r("li",[e._v("useLayoutEffect")]),e._v(" "),r("li",[e._v("useCallback")]),e._v(" "),r("li",[e._v("useMemo")]),e._v(" "),r("li",[e._v("useImperativeHandles")]),e._v(" "),r("li",[e._v("useDebugValue")]),e._v(" "),r("li",[e._v("useTransition")]),e._v(" "),r("li",[e._v("useDeferredValue")]),e._v(" "),r("li",[e._v("useOpaqueIdentifier")]),e._v(" "),r("li",[e._v("useMutableSource")])]),e._v(" "),r("p",[e._v("这里真正的源码是放在了packages/react-reconciler/src/ReactFiberHooks.js里，可以看出其利用的仍然是React的核心数据结构Fiber的调度作用")]),e._v(" "),r("p",[r("img",{attrs:{src:"/tech/front/hooks20200826/hooks02.png",alt:"hooks02"}})]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("export function renderWithHooks<Props, SecondArg>(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: (p: Props, arg: SecondArg) => any,\n  props: Props,\n  secondArg: SecondArg,\n  nextRenderLanes: Lanes,\n): any {\n  renderLanes = nextRenderLanes;\n  currentlyRenderingFiber = workInProgress;\n\n  if (__DEV__) {\n    hookTypesDev =\n      current !== null\n        ? ((current._debugHookTypes: any): Array<HookType>)\n        : null;\n    hookTypesUpdateIndexDev = -1;\n    // Used for hot reloading:\n    ignorePreviousDependencies =\n      current !== null && current.type !== workInProgress.type;\n  }\n\n  workInProgress.memoizedState = null;\n  workInProgress.updateQueue = null;\n  workInProgress.lanes = NoLanes;\n\n  // The following should have already been reset\n  // currentHook = null;\n  // workInProgressHook = null;\n\n  // didScheduleRenderPhaseUpdate = false;\n\n  // TODO Warn if no hooks are used at all during mount, then some are used during update.\n  // Currently we will identify the update render as a mount because memoizedState === null.\n  // This is tricky because it's valid for certain types of components (e.g. React.lazy)\n\n  // Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.\n  // Non-stateful hooks (e.g. context) don't get added to memoizedState,\n  // so memoizedState would be null during updates and mounts.\n  if (__DEV__) {\n    if (current !== null && current.memoizedState !== null) {\n      ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;\n    } else if (hookTypesDev !== null) {\n      // This dispatcher handles an edge case where a component is updating,\n      // but no stateful hooks have been used.\n      // We want to match the production code behavior (which will use HooksDispatcherOnMount),\n      // but with the extra DEV validation to ensure hooks ordering hasn't changed.\n      // This dispatcher does that.\n      ReactCurrentDispatcher.current = HooksDispatcherOnMountWithHookTypesInDEV;\n    } else {\n      ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;\n    }\n  } else {\n    ReactCurrentDispatcher.current =\n      current === null || current.memoizedState === null\n        ? HooksDispatcherOnMount\n        : HooksDispatcherOnUpdate;\n  }\n\n  let children = Component(props, secondArg);\n\n  // Check if there was a render phase update\n  if (didScheduleRenderPhaseUpdateDuringThisPass) {\n    // Keep rendering in a loop for as long as render phase updates continue to\n    // be scheduled. Use a counter to prevent infinite loops.\n    let numberOfReRenders: number = 0;\n    do {\n      didScheduleRenderPhaseUpdateDuringThisPass = false;\n      invariant(\n        numberOfReRenders < RE_RENDER_LIMIT,\n        'Too many re-renders. React limits the number of renders to prevent ' +\n          'an infinite loop.',\n      );\n\n      numberOfReRenders += 1;\n      if (__DEV__) {\n        // Even when hot reloading, allow dependencies to stabilize\n        // after first render to prevent infinite render phase updates.\n        ignorePreviousDependencies = false;\n      }\n\n      // Start over from the beginning of the list\n      currentHook = null;\n      workInProgressHook = null;\n\n      workInProgress.updateQueue = null;\n\n      if (__DEV__) {\n        // Also validate hook order for cascading updates.\n        hookTypesUpdateIndexDev = -1;\n      }\n\n      ReactCurrentDispatcher.current = __DEV__\n        ? HooksDispatcherOnRerenderInDEV\n        : HooksDispatcherOnRerender;\n\n      children = Component(props, secondArg);\n    } while (didScheduleRenderPhaseUpdateDuringThisPass);\n  }\n\n  // We can assume the previous dispatcher is always this one, since we set it\n  // at the beginning of the render phase and there's no re-entrancy.\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n\n  if (__DEV__) {\n    workInProgress._debugHookTypes = hookTypesDev;\n  }\n\n  // This check uses currentHook so that it works the same in DEV and prod bundles.\n  // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\n  const didRenderTooFewHooks =\n    currentHook !== null && currentHook.next !== null;\n\n  renderLanes = NoLanes;\n  currentlyRenderingFiber = (null: any);\n\n  currentHook = null;\n  workInProgressHook = null;\n\n  if (__DEV__) {\n    currentHookNameInDev = null;\n    hookTypesDev = null;\n    hookTypesUpdateIndexDev = -1;\n  }\n\n  didScheduleRenderPhaseUpdate = false;\n\n  invariant(\n    !didRenderTooFewHooks,\n    'Rendered fewer hooks than expected. This may be caused by an accidental ' +\n      'early return statement.',\n  );\n\n  return children;\n}\n")])])]),r("p",[e._v("从中抽离出核心的hooks渲染，其他的具体的use方法可以在其上进行扩展，可以看出其实质是是基于Fiber的workInProgress的全局变量的更改与调度，其中包含记录当前hook状态的memoizedState以及需要更新的队列updateQueue，hooks的队列通过memoizedState及next构成了一个链表，整个hook的核心是基于Dispatcher的切换hook的调用，这里就涉及到Fiber的整个数据结构，在下一节中进行描述")]),e._v(" "),r("h3",{attrs:{id:"react-fiber数据结构分析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react-fiber数据结构分析"}},[e._v("#")]),e._v(" React Fiber数据结构分析")]),e._v(" "),r("p",[r("img",{attrs:{src:"/tech/front/hooks20200826/hooks03.jpg",alt:"hooks03"}})]),e._v(" "),r("p",[r("img",{attrs:{src:"/tech/front/hooks20200826/hooks04.png",alt:"hooks04"}})]),e._v(" "),r("p",[e._v("[组件目录]")]),e._v(" "),r("ul",[r("li",[e._v("packages\n"),r("ul",[r("li",[e._v("react-reconciler\n"),r("ul",[r("li",[e._v("src\n"),r("ul",[r("li",[e._v("ReactFiber.js")])])])])])])])]),e._v(" "),r("p",[e._v("简单来说React的Fiber数据结构是维护了一个如下的数据格式：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("Fiber = {\n    // 标识 fiber 类型的标签，详情参看下述 WorkTag\n    tag: WorkTag,\n\n    // 指向父节点\n    return: Fiber | null,\n\n    // 指向子节点\n    child: Fiber | null,\n\n    // 指向兄弟节点\n    sibling: Fiber | null,\n\n    // 在开始执行时设置 props 值\n    pendingProps: any,\n\n    // 在结束时设置的 props 值\n    memoizedProps: any,\n\n    // 当前 state\n    memoizedState: any,\n\n    // Effect 类型，详情查看以下 effectTag\n    effectTag: SideEffectTag,\n\n    // effect 节点指针，指向下一个 effect\n    nextEffect: Fiber | null,\n\n    // effect list 是单向链表，第一个 effect\n    firstEffect: Fiber | null,\n\n    // effect list 是单向链表，最后一个 effect\n    lastEffect: Fiber | null,\n\n    // work 的过期时间，可用于标识一个 work 优先级顺序\n    expirationTime: ExpirationTime,\n};\n")])])]),r("p",[r("img",{attrs:{src:"/tech/front/hooks20200826/lifecycle.jpg",alt:"lifecycle"}})]),e._v(" "),r("p",[e._v("该数据结构是一个通过链表实现的树的结构，整个React的阶段可分为Render Phase、Pre-Commit Phase以及Commit Phase，Fiber的设计初衷是利用浏览器渲染过程中剩余的时间碎片来进行render，而要达到这个目的需要能够对渲染过程的工作进行暂停、终止以及复用，Fiber便是利用数据结构实现了这样一个虚拟堆栈帧。")]),e._v(" "),r("p",[r("img",{attrs:{src:"/tech/front/hooks20200826/hooks05.jpg",alt:"hooks05"}})]),e._v(" "),r("p",[e._v("这里不再对协调(Reconciliation)和调度(Scheduling)的具体过程，如expirationTime的权重设计、Effect lists的DFS算法设计等进行讲述，有兴趣的同学可以参看这篇文章("),r("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/179934120",target:"_blank",rel:"noopener noreferrer"}},[e._v("React Fiber 源码解析"),r("OutboundLink")],1),e._v(")")]),e._v(" "),r("p",[e._v("基于React Hooks涉及到的workInProgress，我们重点看一下这里的设计")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// This is used to create an alternate fiber to do work on.\nexport function createWorkInProgress(current: Fiber, pendingProps: any): Fiber {\n  let workInProgress = current.alternate;\n  if (workInProgress === null) {\n    // We use a double buffering pooling technique because we know that we'll\n    // only ever need at most two versions of a tree. We pool the \"other\" unused\n    // node that we're free to reuse. This is lazily created to avoid allocating\n    // extra objects for things that are never updated. It also allow us to\n    // reclaim the extra memory if needed.\n    workInProgress = createFiber(\n      current.tag,\n      pendingProps,\n      current.key,\n      current.mode,\n    );\n    workInProgress.elementType = current.elementType;\n    workInProgress.type = current.type;\n    workInProgress.stateNode = current.stateNode;\n\n    if (__DEV__) {\n      // DEV-only fields\n      workInProgress._debugID = current._debugID;\n      workInProgress._debugSource = current._debugSource;\n      workInProgress._debugOwner = current._debugOwner;\n      workInProgress._debugHookTypes = current._debugHookTypes;\n    }\n\n    workInProgress.alternate = current;\n    current.alternate = workInProgress;\n  } else {\n    workInProgress.pendingProps = pendingProps;\n    // Needed because Blocks store data on type.\n    workInProgress.type = current.type;\n\n    // We already have an alternate.\n    workInProgress.subtreeTag = NoSubtreeEffect;\n    workInProgress.deletions = null;\n\n    // The effect list is no longer valid.\n    workInProgress.nextEffect = null;\n    workInProgress.firstEffect = null;\n    workInProgress.lastEffect = null;\n\n    if (enableProfilerTimer) {\n      // We intentionally reset, rather than copy, actualDuration & actualStartTime.\n      // This prevents time from endlessly accumulating in new commits.\n      // This has the downside of resetting values for different priority renders,\n      // But works for yielding (the common case) and should support resuming.\n      workInProgress.actualDuration = 0;\n      workInProgress.actualStartTime = -1;\n    }\n  }\n\n  // Reset all effects except static ones.\n  // Static effects are not specific to a render.\n  workInProgress.effectTag = current.effectTag & StaticMask;\n  workInProgress.childLanes = current.childLanes;\n  workInProgress.lanes = current.lanes;\n\n  workInProgress.child = current.child;\n  workInProgress.memoizedProps = current.memoizedProps;\n  workInProgress.memoizedState = current.memoizedState;\n  workInProgress.updateQueue = current.updateQueue;\n\n  // Clone the dependencies object. This is mutated during the render phase, so\n  // it cannot be shared with the current fiber.\n  const currentDependencies = current.dependencies;\n  workInProgress.dependencies =\n    currentDependencies === null\n      ? null\n      : {\n          lanes: currentDependencies.lanes,\n          firstContext: currentDependencies.firstContext,\n        };\n\n  // These will be overridden during the parent's reconciliation\n  workInProgress.sibling = current.sibling;\n  workInProgress.index = current.index;\n  workInProgress.ref = current.ref;\n\n  if (enableProfilerTimer) {\n    workInProgress.selfBaseDuration = current.selfBaseDuration;\n    workInProgress.treeBaseDuration = current.treeBaseDuration;\n  }\n\n  if (__DEV__) {\n    workInProgress._debugNeedsRemount = current._debugNeedsRemount;\n    switch (workInProgress.tag) {\n      case IndeterminateComponent:\n      case FunctionComponent:\n      case SimpleMemoComponent:\n        workInProgress.type = resolveFunctionForHotReloading(current.type);\n        break;\n      case ClassComponent:\n        workInProgress.type = resolveClassForHotReloading(current.type);\n        break;\n      case ForwardRef:\n        workInProgress.type = resolveForwardRefForHotReloading(current.type);\n        break;\n      default:\n        break;\n    }\n  }\n\n  return workInProgress;\n}\n")])])]),r("p",[e._v("这里涉及到的workInProgress和current两个树通过alternate这个指针的互相指引操作来实现首次渲染和非首次渲染的对比更新，保证两个队列都更新而不会丢失，并且确保更新始终是workInProgress的一部分，这里还做了一个内存缓冲，奇次更新和偶次更新的循环复用")]),e._v(" "),r("h2",{attrs:{id:"总结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),r("p",[e._v("通过学习React16关于Fiber源码及React Hooks的源码，我们发现整个React16的底层核心是基于Fiber的优化与扩展，包括dom-diff的扩展等，相较于Vue3对于Vue2的更新，可以看出React的优化迭代思路更加充满对计算机原理底层的思考与发现，当然这两个框架从出发点设计上也是有所不同，Vue是基于组件级的优化，因而并不需要这样一个Fiber的数据结构去构建，但从真正的设计来看Fiber的架构设计思维方式确实更加符合国外程序员的方法与韵味。(ps: 想要了解Andrew Clark介绍Fiber的同学，可以参看这篇文章"),r("a",{attrs:{href:"https://github.com/acdlite/react-fiber-architecture",target:"_blank",rel:"noopener noreferrer"}},[e._v("react-fiber-architecure"),r("OutboundLink")],1),e._v(")")]),e._v(" "),r("h2",{attrs:{id:"参考"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-intro.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Hook 简介"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://mp.weixin.qq.com/s/9Uuy5t-TL9cnCWY_GtQpNQ",target:"_blank",rel:"noopener noreferrer"}},[e._v("【第2044期】React Hooks 设计思想"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://mp.weixin.qq.com/s/FpksXaQUv2zplOPvgTh_Hw",target:"_blank",rel:"noopener noreferrer"}},[e._v("【第2037期】React Hooks 实践指南"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://www.jianshu.com/p/8a65fb1bb713",target:"_blank",rel:"noopener noreferrer"}},[e._v("ReactHooks源码解析之useEffect"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://www.jianshu.com/p/63711e9c0f84",target:"_blank",rel:"noopener noreferrer"}},[e._v("react hooks 源码分析 --- useState"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://www.jianshu.com/p/72720ec4341f",target:"_blank",rel:"noopener noreferrer"}},[e._v("剖析React Hooks底层源码"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://mp.weixin.qq.com/s/lHoLGxJsfNfKXyIFNHMoZQ",target:"_blank",rel:"noopener noreferrer"}},[e._v("React Hook 的体系设计之一 - 分层"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://mp.weixin.qq.com/s/ZJRsT1ZRZenW2AxvR8eObw",target:"_blank",rel:"noopener noreferrer"}},[e._v("React Hooks 的体系设计之二 - 状态粒度"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://mp.weixin.qq.com/s/UnX1oe5jOqOjx9i0X-n13Q",target:"_blank",rel:"noopener noreferrer"}},[e._v("React Hooks 的体系设计之三 - 什么是 ref"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://www.jianshu.com/p/fc31704ad0ee?from=timeline",target:"_blank",rel:"noopener noreferrer"}},[e._v("React Hooks 源码解析（译）"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/57346388",target:"_blank",rel:"noopener noreferrer"}},[e._v("[译]深入React fiber架构及源码"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/179934120",target:"_blank",rel:"noopener noreferrer"}},[e._v("React Fiber 源码解析"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);n.default=o.exports}}]);
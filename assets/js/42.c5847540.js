(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{244:function(n,e,t){"use strict";t.r(e);var r=t(0),a=Object(r.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"ng全家桶全栈项目实践总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ng全家桶全栈项目实践总结"}},[n._v("#")]),n._v(" NG全家桶全栈项目实践总结")]),n._v(" "),t("h2",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[n._v("#")]),n._v(" 前言")]),n._v(" "),t("p",[n._v("Angular在国内使用的人并不像国外那么多，基本都是外企在用，但其框架的思想却仍可以为我们所借鉴，在某些问题没有思路的时候可以参考ng相关的处理，ng处理方式和思维确实比较超前，但也因此而曲高和寡。本文旨在通过ng全家桶项目（前端Angular10 + 后端NestJS7）的实践来总结对于ng架构中一些亮点的关注与思考，Angular和Nest在前后端框架的处理上同出一脉，对比起来更有借鉴意义。")]),n._v(" "),t("p",[t("img",{attrs:{src:"/tech/back/ng20201030/ng01.png",alt:"图片"}})]),n._v(" "),t("h2",{attrs:{id:"目录"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[n._v("#")]),n._v(" 目录")]),n._v(" "),t("ul",[t("li",[n._v("前端项目实践")]),n._v(" "),t("li",[n._v("后端项目实践")]),n._v(" "),t("li",[n._v("源码简析")])]),n._v(" "),t("h2",{attrs:{id:"案例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#案例"}},[n._v("#")]),n._v(" 案例")]),n._v(" "),t("h3",{attrs:{id:"前端项目实践"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端项目实践"}},[n._v("#")]),n._v(" 前端项目实践")]),n._v(" "),t("p",[t("img",{attrs:{src:"/tech/back/ng20201030/ng02.gif",alt:"图片"}})]),n._v(" "),t("p",[n._v("[目录结构]")]),n._v(" "),t("ul",[t("li",[n._v("src\n"),t("ul",[t("li",[n._v("app\n"),t("ul",[t("li",[n._v("login\n"),t("ul",[t("li",[n._v("login.component.html")]),n._v(" "),t("li",[n._v("login.component.scss")]),n._v(" "),t("li",[n._v("login.component.spec.ts")]),n._v(" "),t("li",[n._v("login.component.ts")])])]),n._v(" "),t("li",[n._v("main\n"),t("ul",[t("li",[n._v("main.component.html")]),n._v(" "),t("li",[n._v("main.component.scss")]),n._v(" "),t("li",[n._v("main.component.spec.ts")]),n._v(" "),t("li",[n._v("main.component.ts")])])]),n._v(" "),t("li",[n._v("app.component.html")]),n._v(" "),t("li",[n._v("app.component.scss")]),n._v(" "),t("li",[n._v("app.component.spec.ts")]),n._v(" "),t("li",[n._v("app.component.ts")]),n._v(" "),t("li",[n._v("app.module.ts")]),n._v(" "),t("li",[n._v("app.service.ts")]),n._v(" "),t("li",[n._v("user.ts")])])]),n._v(" "),t("li",[n._v("main.ts")]),n._v(" "),t("li",[n._v("index.html")])])]),n._v(" "),t("li",[n._v("angular.json")])]),n._v(" "),t("p",[n._v("[目录描述]")]),n._v(" "),t("p",[n._v("整个前端项目是基于angular脚手架生成的，其基本目录结构是在src的app下进行相关组件和页面的模块开发，main.ts和index.html是整个单页应用的主入口，根目录下angular.json用于配置相关的打包编译等环境配置参数")]),n._v(" "),t("p",[t("img",{attrs:{src:"/tech/back/ng20201030/ng03.png",alt:"图片"}})]),n._v(" "),t("p",[n._v("[实践分享]")]),n._v(" "),t("ul",[t("li",[t("p",[n._v("脚手架版本问题：对于ng10.1.x以上的版本其脚手架版本与库版本有出入，会导致引入HttpModule及其他部分模块时报错，需要将@angular/compiler这个库进行相关版本的升级 "),t("code",[n._v("This likely means that the library (@angular/common/http) which declares HttpClientModule has not been processed correctly by ngcc, or is not compatible with Angular Ivy. Check if a newer version of the library is available, and update if so. Also consider checking with the library's authors to see if the library is expected to be compatible with Ivy.")])])]),n._v(" "),t("li",[t("p",[n._v("输入框双向数据绑定无效问题：对于forms表单的想使用"),t("code",[n._v("[(ngModal)]")]),n._v("指令，必须在module中引入FormsModule")])])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("import { FormsModule } from '@angular/forms';\n\n@NgModule({\n  imports: [\n    FormsModule\n  ]\n})\n")])])]),t("ul",[t("li",[t("p",[n._v("组件库使用有问题：目前ng的组件库主要有 "),t("a",{attrs:{href:"https://material.angular.cn/",target:"_blank",rel:"noopener noreferrer"}},[n._v("官方 MATERIAL 组件库"),t("OutboundLink")],1),n._v("、"),t("a",{attrs:{href:"https://ng.ant.design/docs/introduce/zh",target:"_blank",rel:"noopener noreferrer"}},[n._v("NG-ZORRO 组件库"),t("OutboundLink")],1),n._v("、"),t("a",{attrs:{href:"https://ngnest.com/index/docs/zh_CN/ng-nest",target:"_blank",rel:"noopener noreferrer"}},[n._v("NG-NEST 组件库"),t("OutboundLink")],1),n._v("，但这几个主要的组件库都在10以下或10.0版本，会有部分bug，因而本次未引入组件库，直接使用html和scss来优化页面")])]),n._v(" "),t("li",[t("p",[n._v("Animation引入问题：同样的跟版本有关系，想使用ng自带的animation动画库需要配合对应的版本，在做提示框消失时本想使用ng的动画，后来改用了animation直接写")])])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v(".app-message {\n    width: 300px;\n    height: 40px;\n    background: #fff;\n    transition: all 2s none;\n    border: 1px solid #ececec;\n    border-radius: 4px;\n    position: fixed;\n    left: 50%;\n    top: 10px;\n    margin-left: -150px;\n    text-align: center;\n    \n\n    &-show {\n        animation: a 3s ease-out forwards;\n        animation-direction: alternate;\n        animation-iteration-count: 1;\n        @keyframes a {\n            0% {opacity: 1;}\n            100% {opacity: 0;}\n        }\n    }\n\n    &-hide {\n        opacity: 0;\n    }\n}\n")])])]),t("h3",{attrs:{id:"后端项目踩坑实践"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#后端项目踩坑实践"}},[n._v("#")]),n._v(" 后端项目踩坑实践")]),n._v(" "),t("p",[t("img",{attrs:{src:"/tech/back/ng20201030/ng04.png",alt:"图片"}})]),n._v(" "),t("p",[n._v("[目录结构]")]),n._v(" "),t("ul",[t("li",[n._v("src\n"),t("ul",[t("li",[n._v("api\n"),t("ul",[t("li",[n._v("article\n"),t("ul",[t("li",[n._v("article.controller.ts")]),n._v(" "),t("li",[n._v("article.module.ts")])])]),n._v(" "),t("li",[n._v("audio\n"),t("ul",[t("li",[n._v("audio.controller.ts")]),n._v(" "),t("li",[n._v("audio.module.ts")]),n._v(" "),t("li",[n._v("audio.processor.ts")])])]),n._v(" "),t("li",[n._v("user\n"),t("ul",[t("li",[n._v("dto\n"),t("ul",[t("li",[n._v("create-user.dto.ts")]),n._v(" "),t("li",[n._v("get-user.dto.ts")]),n._v(" "),t("li",[n._v("update-user.dto.ts")])])]),n._v(" "),t("li",[n._v("user.controller.ts")]),n._v(" "),t("li",[n._v("user.entity.ts")]),n._v(" "),t("li",[n._v("user.interface.ts")]),n._v(" "),t("li",[n._v("user.module.ts")]),n._v(" "),t("li",[n._v("user.service.ts")])])])])]),n._v(" "),t("li",[n._v("auth\n"),t("ul",[t("li",[n._v("auth.controller.ts")]),n._v(" "),t("li",[n._v("auth.service.ts")]),n._v(" "),t("li",[n._v("constants.ts")]),n._v(" "),t("li",[n._v("jwt.strategy.ts")])])]),n._v(" "),t("li",[n._v("filters\n"),t("ul",[t("li",[n._v("exception\n"),t("ul",[t("li",[n._v("http-exception.filter.ts")])])])])]),n._v(" "),t("li",[n._v("guard\n"),t("ul",[t("li",[n._v("roles.guard.ts")])])]),n._v(" "),t("li",[n._v("interceptors\n"),t("ul",[t("li",[n._v("cache.interceptor.ts")]),n._v(" "),t("li",[n._v("exception.interceptor.ts")]),n._v(" "),t("li",[n._v("logger.interceptor.ts")]),n._v(" "),t("li",[n._v("timeout.interceptor.ts")]),n._v(" "),t("li",[n._v("transform.interceptor.ts")])])]),n._v(" "),t("li",[n._v("middlewares\n"),t("ul",[t("li",[n._v("logger\n"),t("ul",[t("li",[n._v("logger.middleware.ts")]),n._v(" "),t("li",[n._v("logger.ts")])])])])]),n._v(" "),t("li",[n._v("pipes\n"),t("ul",[t("li",[n._v("parse-int.pipe.ts")]),n._v(" "),t("li",[n._v("validate.pipe.ts")])])]),n._v(" "),t("li",[n._v("main.ts")]),n._v(" "),t("li",[n._v("app.module.ts")])])]),n._v(" "),t("li",[n._v("nest-cli.json")])]),n._v(" "),t("p",[n._v("[目录描述]")]),n._v(" "),t("p",[n._v("后端项目是基于nestjs框架的大型后台项目配置，api模块主要是对外输出的接口，auth、filters、guard、interceptors、middlewares、pipes等是对于需要的模块进行统一的收集处理，main.ts是主入口文件，用于启动及相关配置等，app.module.ts是用来收集所有模块的导入，ng基于模块的方式可以起到非常好的隔离效果")]),n._v(" "),t("p",[t("img",{attrs:{src:"/tech/back/ng20201030/ng05.png",alt:"图片"}})]),n._v(" "),t("p",[n._v("[实践分享]")]),n._v(" "),t("ul",[t("li",[t("p",[n._v("typeorm数据库连接：使用navicat连接需要先创建数据库，否则无法连接")])]),n._v(" "),t("li",[t("p",[n._v("bull消息队列：nestjs的消息队列使用的是bull.js这个库，其实现了一个调度的消息队列机制")])]),n._v(" "),t("li",[t("p",[n._v("微服务：nestjs默认使用的基础的类似java的spring框架，并未采用微服务，如需使用，需要完全重构")])])]),n._v(" "),t("h3",{attrs:{id:"源码简析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#源码简析"}},[n._v("#")]),n._v(" 源码简析")]),n._v(" "),t("h4",{attrs:{id:"angular"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#angular"}},[n._v("#")]),n._v(" Angular")]),n._v(" "),t("p",[t("img",{attrs:{src:"/tech/back/ng20201030/ng06.png",alt:"图片"}})]),n._v(" "),t("p",[t("img",{attrs:{src:"/tech/back/ng20201030/ng07.png",alt:"图片"}})]),n._v(" "),t("p",[n._v("首先，对于没有用过ng的同学科普一下，angular其实分为两个大版本，一个是angular1.x的，也就是ng1，也就是现在还有的angularjs，另一个版本是ng2以后的版本，ng2之后被谷歌收购后，完全重写了框架，唯一和1.x相通的估计也就剩那几个思想还在了：模块化、依赖注入、双向绑定、MVC，对于1.x感兴趣的同学可以去看Vue的1.x的版本，基本算是简化版的ng1.x，Vue2之后就和后来的ng分道扬镳了，vue2主要是以发布订阅来替代依赖注入的思路，扯远了...(ps: 想看ng1版本的可以看这个地址，居然还有更新... "),t("a",{attrs:{href:"https://github.com/angular/angular.js",target:"_blank",rel:"noopener noreferrer"}},[n._v("angularjs官方仓库"),t("OutboundLink")],1),n._v(")，这里分析的主要是Ng10，ng8之后除了引入Ivy("),t("a",{attrs:{href:"https://github.com/angular/angular/blob/master/packages/compiler/design/architecture.md",target:"_blank",rel:"noopener noreferrer"}},[n._v("Ivy架构官方介绍"),t("OutboundLink")],1),n._v(")这个编译渲染器之外，其实改动不大，主要就是在优化以及废除和新建一些api等等。Ng的源码很庞大，goggle自研了一个bazel自动化构建工具，ng自然也是靠这个构建的，对bazel感兴趣的同学，可以看这个"),t("a",{attrs:{href:"https://www.cnblogs.com/Jack47/p/build-in-the-cloud.html",target:"_blank",rel:"noopener noreferrer"}},[n._v("Google软件构建工具Bazel原理及使用方法介绍"),t("OutboundLink")],1),n._v("，我这里就不展开所有的源码，整体的核心大框架如下：")]),n._v(" "),t("ul",[t("li",[n._v("packages\n"),t("ul",[t("li",[n._v("complier (ps: 不展开了，这个编译部分做的很优秀，本篇讲不完，回头写编译器部分专门说吧，尤其是Ivy那个，后续react的fiber以及vue3的最新的compiler部分都有其影响)\n"),t("ul",[t("li",[n._v("src\n"),t("ul",[t("li",[n._v("aot")]),n._v(" "),t("li",[n._v("css_parser")]),n._v(" "),t("li",[n._v("expression_parser")]),n._v(" "),t("li",[n._v("jit")]),n._v(" "),t("li",[n._v("ml_parser")]),n._v(" "),t("li",[n._v("template_parser")])])])])]),n._v(" "),t("li",[n._v("core\n"),t("ul",[t("li",[n._v("src\n"),t("ul",[t("li",[n._v("di\n"),t("ul",[t("li",[n._v("injector.ts")])])]),n._v(" "),t("li",[n._v("reflection\n"),t("ul",[t("li",[n._v("reflector.ts")])])]),n._v(" "),t("li",[n._v("view\n"),t("ul",[t("li",[n._v("provider.ts")])])]),n._v(" "),t("li",[n._v("render3 (ps: Ivy的渲染部分)")])])])])])])])]),n._v(" "),t("h4",{attrs:{id:"nest"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nest"}},[n._v("#")]),n._v(" Nest")]),n._v(" "),t("p",[t("img",{attrs:{src:"/tech/back/ng20201030/ng08.png",alt:"图片"}})]),n._v(" "),t("p",[n._v("nestjs是nodejs的web应用的一个大的集成，它最初是基于express封装的一个后端框架，后来将服务端各种理念都使用js实现了一下，虽然不能和成熟的服务端语言框架如java等进行媲美，但是服务端所需要的东西基本都具备了，对于有需求想要使用js来开发后端的同学是个不错的选择，个人认为简单的bff，比如想自己模拟的开发个后台接收请求，选择node直接写或者使用express、koa就可以，对于有一定的中间层给前端处理，可以选用阿里的egg，对于如何基于egg构建中间层，可以看看这篇文章"),t("a",{attrs:{href:"https://mp.weixin.qq.com/s/WhqDlckGMwraEeOAs6IfTA",target:"_blank",rel:"noopener noreferrer"}},[n._v("如何为团队定制自己的 Node.js 框架？（基于 EggJS）"),t("OutboundLink")],1),n._v("，对于大型的服务端，尤其是前端是以ng为主栈的，可以优先考虑使用nestjs；其次对于io较多而计算较少的（js本身的特质），或者服务端需要与c++配合的，大型服务端应用也可以使用nest。nest默认是不采用微服务的形式的，nest将不同的平台封在了不同的platform下，这里只分析普通的以express为platform的形式，对于喜欢微服务的同学，可以对比和java的springcloud的区别，这里就不做表述了，其整体的核心结构大致如下：")]),n._v(" "),t("ul",[t("li",[n._v("packages\n"),t("ul",[t("li",[n._v("core\n"),t("ul",[t("li",[n._v("injector\n"),t("ul",[t("li",[n._v("injector.ts")]),n._v(" "),t("li",[n._v("module.ts")])])]),n._v(" "),t("li",[n._v("services\n"),t("ul",[t("li",[n._v("reflector.service.ts")])])])])]),n._v(" "),t("li",[n._v("platform-express")])])])]),n._v(" "),t("h4",{attrs:{id:"源码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#源码"}},[n._v("#")]),n._v(" 源码")]),n._v(" "),t("p",[n._v("这里主要在对依赖注入的实现做一个简单的理解分享，其思路是一脉相承的，对于理解后端理念的依赖注入有很好的理解，这也正是后端前端化的一个体现，也是最早的MVC框架向后来的MVVM框架过度的一个历史过程，依赖注入方式对于最早的前端框架还是有纪念意义的，但是对于ng全家桶来说，这算是其基本哲学的一个基本面")]),n._v(" "),t("p",[t("b",[n._v("Angular")])]),n._v(" "),t("p",[n._v("先来看一下ng是如何实现injector的，这里重点在于使用了抽象类来重载不同函数的使用，对于provider循环依赖的处理，利用了一个Map数据结构来区分不同的Provider")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 抽象类\nexport abstract class Injector {\n    // get方法重载的使用\n    abstract get<T>(\n        token: Type<T>|InjectionToken<T>|AbstractType<T>, notFoundValue?: T, flags?: InjectFlags\n    ): T;\n\n    abstract get(\n        token: any, \n        notFoundValue?: any\n    ): any;\n  \n    // create方法重载的使用\n    static create(\n        providers: StaticProvider[], \n        parent?: Injector\n    ): Injector;\n  \n    static create(\n        options: {\n            providers: StaticProvider[], \n            parent?: Injector, \n            name?: string\n        }\n    ): Injector;\n  \n  \n    static create(\n        options: StaticProvider[]|{providers: StaticProvider[], parent?: Injector, name?: string},\n        parent?: Injector\n    ): Injector {\n      if (Array.isArray(options)) {\n        return INJECTOR_IMPL(options, parent, '');\n      } else {\n        return INJECTOR_IMPL(options.providers, options.parent, options.name || '');\n      }\n    }\n  \n    static __NG_ELEMENT_ID__ = -1;\n  }\n\n  // 记录判断prodiver的数据结构，这里使用interface来承载\n  interface Record {\n    fn: Function;\n    useNew: boolean;\n    deps: DependencyRecord[];\n    value: any;\n  }\n  \n  interface DependencyRecord {\n    token: any;\n    options: number;\n  }\n\n  // 实现抽象类\n  export class StaticInjector implements Injector {\n    readonly parent: Injector;\n    readonly source: string|null;\n    readonly scope: string|null;\n  \n    private _records: Map<any, Record|null>;\n  \n    constructor(\n        providers: StaticProvider[], \n        parent: Injector = Injector.NULL, \n        source: string|null = null\n    ) {\n      this.parent = parent;\n      this.source = source;\n      const records = this._records = new Map<any, Record>();\n      records.set(\n          Injector, \n          <Record>{token: Injector, fn: IDENT, deps: EMPTY, value: this, useNew: false}\n      );\n      records.set(\n          INJECTOR, \n          <Record>{token: INJECTOR, fn: IDENT, deps: EMPTY, value: this, useNew: false}\n      );\n      this.scope = recursivelyProcessProviders(records, providers);\n    }\n  \n    get<T>(token: Type<T>|InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\n\n    get(token: any, notFoundValue?: any): any;\n\n    get(token: any, notFoundValue?: any, flags: InjectFlags = InjectFlags.Default): any {\n      const records = this._records;\n      // record的缓存队列\n      let record = records.get(token);\n      // 利用record避免循环提供的问题\n      if (record === undefined) {\n        // This means we have never seen this record, see if it is tree shakable provider.\n        const injectableDef = getInjectableDef(token);\n        if (injectableDef) {\n          const providedIn = injectableDef && injectableDef.providedIn;\n          if (providedIn === 'any' || providedIn != null && providedIn === this.scope) {\n            records.set(\n                token,\n                record = resolveProvider(\n                    {provide: token, useFactory: injectableDef.factory, deps: EMPTY}));\n          }\n        }\n        if (record === undefined) {\n          // Set record to null to make sure that we don't go through expensive lookup above again.\n          records.set(token, null);\n        }\n      }\n      let lastInjector = setCurrentInjector(this);\n      try {\n        return tryResolveToken(token, record, records, this.parent, notFoundValue, flags);\n      } catch (e) {\n        return catchInjectorError(e, token, 'StaticInjectorError', this.source);\n      } finally {\n        setCurrentInjector(lastInjector);\n      }\n    }\n  \n    toString() {\n      const tokens = <string[]>[], records = this._records;\n      records.forEach((v, token) => tokens.push(stringify(token)));\n      return `StaticInjector[${tokens.join(', ')}]`;\n    }\n}\n\n  // 解析Provider的函数\nfunction resolveProvider(\n    provider: SupportedProvider): Record \n{\n    const deps = computeDeps(provider);\n    let fn: Function = IDENT;\n    let value: any = EMPTY;\n    let useNew: boolean = false;\n    let provide = resolveForwardRef(provider.provide);\n    // 一些错误处理\n    ...\n    return {deps, fn, useNew, value};\n}\n\n  // 处理循环依赖的问题\nfunction recursivelyProcessProviders(\n  records: Map<any, Record>, \n  provider: StaticProvider): string|null \n{\n    let scope: string|null = null;\n    // 根据不同情况处理一些错误  \n    ...\n    return scope;\n}\n\n// 解析Token的函数\nfunction resolveToken(\n    token: any, \n    record: Record|undefined|null, \n    records: Map<any, Record|null>, parent: Injector,\n    notFoundValue: any, \n    flags: InjectFlags\n): any {\n  let value;\n  ...\n  return value;\n}\n\n// 计算依赖函数\nfunction computeDeps(\n    provider: StaticProvider): DependencyRecord[] \n{\n  let deps: DependencyRecord[] = EMPTY;\n  const providerDeps: any[] =\n      (provider as ExistingProvider & StaticClassProvider & ConstructorProvider).deps;\n  if (providerDeps && providerDeps.length) {\n    deps = [];\n    for (let i = 0; i < providerDeps.length; i++) {\n      let options = OptionFlags.Default;\n      let token = resolveForwardRef(providerDeps[i]);\n      if (Array.isArray(token)) {\n        for (let j = 0, annotations = token; j < annotations.length; j++) {\n          const annotation = annotations[j];\n          if (annotation instanceof Optional || annotation == Optional) {\n            options = options | OptionFlags.Optional;\n          } else if (annotation instanceof SkipSelf || annotation == SkipSelf) {\n            options = options & ~OptionFlags.CheckSelf;\n          } else if (annotation instanceof Self || annotation == Self) {\n            options = options & ~OptionFlags.CheckParent;\n          } else if (annotation instanceof Inject) {\n            token = (annotation as Inject).token;\n          } else {\n            token = resolveForwardRef(annotation);\n          }\n        }\n      }\n      deps.push({token, options});\n    }\n  }\n  ...\n  return deps;\n}\n")])])]),t("p",[t("b",[n._v("Nest")])]),n._v(" "),t("p",[n._v("再来看一下，nest的实现，不同于ng的实现，nest是利用参数和继承父类参数来确定整个的循环依赖关系的，其没有使用重载来实现，但都对循环依赖做了处理，其基本思路是一致的。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("export type InjectorDependency = Type<any> | Function | string | symbol;\n\nexport interface PropertyDependency {\n  key: string;\n  name: InjectorDependency;\n  isOptional?: boolean;\n  instance?: any;\n}\n\nexport interface InjectorDependencyContext {\n  key?: string | symbol;\n  name?: string | symbol;\n  index?: number;\n  dependencies?: InjectorDependency[];\n}\n\nexport class Injector {\n  // 加载中间件 基于express的load方式\n  public async loadMiddleware(\n    wrapper: InstanceWrapper,\n    collection: Map<string, InstanceWrapper>,\n    moduleRef: Module,\n    contextId = STATIC_CONTEXT,\n    inquirer?: InstanceWrapper,\n  ) {\n    ...\n  }\n\n  // 记载控制器\n  public async loadController(\n    wrapper: InstanceWrapper<Controller>,\n    moduleRef: Module,\n    contextId = STATIC_CONTEXT,\n  ) {\n    ...\n  }\n\n  public async loadInjectable<T = any>(\n    wrapper: InstanceWrapper<T>,\n    moduleRef: Module,\n    contextId = STATIC_CONTEXT,\n    inquirer?: InstanceWrapper,\n  ) {\n    const injectables = moduleRef.injectables;\n    await this.loadInstance<T>(\n      wrapper,\n      injectables,\n      moduleRef,\n      contextId,\n      inquirer,\n    );\n  }\n\n  // 加载Provider\n  public async loadProvider(\n    wrapper: InstanceWrapper<Injectable>,\n    moduleRef: Module,\n    contextId = STATIC_CONTEXT,\n    inquirer?: InstanceWrapper,\n  ) {\n    const providers = moduleRef.providers;\n    await this.loadInstance<Injectable>(\n      wrapper,\n      providers,\n      moduleRef,\n      contextId,\n      inquirer,\n    );\n    await this.loadEnhancersPerContext(wrapper, contextId, wrapper);\n  }\n\n  public loadPrototype<T>(\n    { name }: InstanceWrapper<T>,\n    collection: Map<string, InstanceWrapper<T>>,\n    contextId = STATIC_CONTEXT,\n  ) {\n   ...\n  }\n\n  // 解析继承父类的参数\n  public async resolveConstructorParams<T>(\n    wrapper: InstanceWrapper<T>,\n    moduleRef: Module,\n    inject: InjectorDependency[],\n    callback: (args: unknown[]) => void,\n    contextId = STATIC_CONTEXT,\n    inquirer?: InstanceWrapper,\n    parentInquirer?: InstanceWrapper,\n  ) {\n    ...\n  }\n\n  // 反射继承父类的参数\n  public reflectConstructorParams<T>(\n      type: Type<T>\n    ): any[] \n  {\n    ...\n  }\n\n  // 反射功能参数\n  public reflectOptionalParams<T>(\n      type: Type<T>\n    ): any[] \n  {\n    ...\n  }\n\n  // 反射自己的参数\n  public reflectSelfParams<T>(\n      type: Type<T>\n  ): any[] \n  {\n    ...\n  }\n\n  // 解析单个参数\n  public async resolveSingleParam<T>\n  (\n    wrapper: InstanceWrapper<T>,\n    param: Type<any> | string | symbol | any,\n    dependencyContext: InjectorDependencyContext,\n    moduleRef: Module,\n    contextId = STATIC_CONTEXT,\n    inquirer?: InstanceWrapper,\n    keyOrIndex?: string | number,\n  ) {\n    if (isUndefined(param)) {\n      throw new UndefinedDependencyException(\n        wrapper.name,\n        dependencyContext,\n        moduleRef,\n      );\n    }\n    const token = this.resolveParamToken(wrapper, param);\n    return this.resolveComponentInstance<T>(\n      moduleRef,\n      isFunction(token) ? (token as Type<any>).name : token,\n      dependencyContext,\n      wrapper,\n      contextId,\n      inquirer,\n      keyOrIndex,\n    );\n  }\n\n  // 解析参数的token\n  public resolveParamToken<T>(\n    wrapper: InstanceWrapper<T>,\n    param: Type<any> | string | symbol | any,\n  ) {\n    if (!param.forwardRef) {\n      return param;\n    }\n    wrapper.forwardRef = true;\n    return param.forwardRef();\n  }\n}\n")])])]),t("p",[n._v("总结：从nest和ng对injector的实现可以看出，虽然都是注射器的实现，但是由于呈现方式的不同，因而在实现方式上也会有所不同，对于ts而言，选用interface还是抽象类，确实可以借鉴java的模式思路，对于习惯js的我们来说，对于整个数据类型的扩展（如：抽象类、接口）等是需要向后端借鉴的。整体来说，对于依赖注入的实现最关键的就是在于处理provider的整个依赖问题，这两者都是采用token的方式来区分对待到底是属于哪一个provider，然后对于特殊的相关依赖循环的问题做对应的处理")]),n._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[n._v("#")]),n._v(" 总结")]),n._v(" "),t("p",[n._v("ng整个生态体系在国内应用的并不广，但并不妨碍其作为前端理念的扩展先行者的这样一个角色，个人认为其在隔离性以及系统性方面都是要优于vue和react的，因而对于目前比较流行的微前端框架(ps: 对于ng的微前端应用，可以参考这篇文章"),t("a",{attrs:{href:"https://mp.weixin.qq.com/s/ochbPM5f84u-1BcNRXVOLA%5D",target:"_blank",rel:"noopener noreferrer"}},[n._v("【第1789期】使用 Angular 打造微前端架构的 ToB 企业级应用"),t("OutboundLink")],1),n._v(")，个人觉得在沙箱隔离等系统融合方面确实可以借鉴一下ng的某些思路，或许正是由于这个原因，它才是三大框架中最先上ts的，也有可能整个ng的开发者更像是传统的软件工程师，对于整个开发要做到定义数据、定义模型、系统设计等等，对于大型项目而言，这样确实会减少很多因bug而需要重复修改的时间，但是对于小型项目，个人认为还是vue更合适。虽然对于国内，ng基本已经属于明日黄花了，但是它的一些理念及设计思路确实还是值得借鉴的，在这个内卷的时代，各大应用都在向着高级化、大型化发展，说不定哪天ng又在国内重回巅峰了呢，虽然很难~~哈哈哈，各位加油！")]),n._v(" "),t("p",[n._v("仓库地址，欢迎star：\n"),t("a",{attrs:{href:"https://gitee.com/wildwood/nest-angular.git",target:"_blank",rel:"noopener noreferrer"}},[n._v("前端仓库地址"),t("OutboundLink")],1),n._v(" "),t("a",{attrs:{href:"https://gitee.com/wildwood/nest-spring.git",target:"_blank",rel:"noopener noreferrer"}},[n._v("后端仓库地址"),t("OutboundLink")],1)]),n._v(" "),t("h2",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[n._v("#")]),n._v(" 参考")]),n._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://github.com/angular/angular",target:"_blank",rel:"noopener noreferrer"}},[n._v("Angular源码"),t("OutboundLink")],1)]),n._v(" "),t("li",[t("a",{attrs:{href:"https://angular.cn/docs",target:"_blank",rel:"noopener noreferrer"}},[n._v("Angular中文文档"),t("OutboundLink")],1)]),n._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/nestjs/nest",target:"_blank",rel:"noopener noreferrer"}},[n._v("Nest源码"),t("OutboundLink")],1)]),n._v(" "),t("li",[t("a",{attrs:{href:"https://docs.nestjs.cn/",target:"_blank",rel:"noopener noreferrer"}},[n._v("Nest中文文档"),t("OutboundLink")],1)]),n._v(" "),t("li",[t("a",{attrs:{href:"https://blog.csdn.net/xiaolizh/article/details/82320545",target:"_blank",rel:"noopener noreferrer"}},[n._v("AngularJs和angular的对比"),t("OutboundLink")],1)]),n._v(" "),t("li",[t("a",{attrs:{href:"https://blog.csdn.net/hu_zhenghui/article/details/105781355",target:"_blank",rel:"noopener noreferrer"}},[n._v("Angular 9.1.0在项目路径包含软链接时编译某些包时报错，9.1.1已修正"),t("OutboundLink")],1)]),n._v(" "),t("li",[t("a",{attrs:{href:"https://www.cnblogs.com/web2-developer/category/751303.html",target:"_blank",rel:"noopener noreferrer"}},[n._v("angularjs源码分析"),t("OutboundLink")],1)]),n._v(" "),t("li",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/WhqDlckGMwraEeOAs6IfTA",target:"_blank",rel:"noopener noreferrer"}},[n._v("如何为团队定制自己的 Node.js 框架？（基于 EggJS）"),t("OutboundLink")],1)]),n._v(" "),t("li",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/ochbPM5f84u-1BcNRXVOLA%5D",target:"_blank",rel:"noopener noreferrer"}},[n._v("【第1789期】使用 Angular 打造微前端架构的 ToB 企业级应用"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=a.exports}}]);